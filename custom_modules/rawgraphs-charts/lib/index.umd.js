(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rawcharts = {}));
}(this, (function (exports) { 'use strict';

  var img = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3ccircle class='cls-1' cx='22.5' cy='39.5' r='3.5'/%3e %3ccircle class='cls-1' cx='17' cy='20' r='6'/%3e %3ccircle class='cls-1' cx='41.5' cy='37.5' r='2.5'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3ccircle class='cls-2' cx='31.5' cy='28.5' r='6.5'/%3e %3ccircle class='cls-2' cx='37.5' cy='15.5' r='3.5'/%3e %3c/g%3e%3c/svg%3e";

  var img$1 = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: none%3b stroke: black%3b %7d .cls-3 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-4 %7b fill: %239e0142%3b %7d .cls-5 %7b fill: %234696b3%3b %7d .cls-6 %7b fill: %235e4fa2%3b %7d .cls-7 %7b fill: %23d5ee9f%3b %7d .cls-8 %7b fill: %2389cfa5%3b %7d .cls-9 %7b fill: %23fed281%3b %7d .cls-10 %7b fill: %23db494a%3b %7d .cls-11 %7b fill: %23f88e53%3b %7d .cls-12 %7b fill: %23fbf8b0%3b %7d %3c/style%3e %3c/defs%3e %3crect id='background' class='cls-1' width='320' height='160'/%3e %3cg id='visualization'%3e %3cg id='axis'%3e %3cg%3e %3cpath class='cls-2' d='M26.5%2c150v-5.5h284V150'/%3e %3cg%3e %3cline class='cls-2' x1='26.5' y1='144' x2='26.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(19.5493 160.1)'%3e6.2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='45.5' y1='144' x2='45.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(38.5493 160.1)'%3e6.4%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='64.5' y1='144' x2='64.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(57.5493 160.1)'%3e6.6%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='83.5' y1='144' x2='83.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(76.5493 160.1)'%3e6.8%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='102.5' y1='144' x2='102.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(95.5493 160.1)'%3e7.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='121.5' y1='144' x2='121.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(114.5493 160.1)'%3e7.2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='140.5' y1='144' x2='140.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(133.5493 160.1)'%3e7.4%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.5' y1='144' x2='159.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(152.5493 160.1)'%3e7.6%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='177.5' y1='144' x2='177.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(170.5488 160.1)'%3e7.8%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='196.5' y1='144' x2='196.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(189.5488 160.1)'%3e8.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='215.5' y1='144' x2='215.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(208.5488 160.1)'%3e8.2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='234.5' y1='144' x2='234.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(227.5488 160.1)'%3e8.4%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='253.5' y1='144' x2='253.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(246.5488 160.1)'%3e8.6%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='272.5' y1='144' x2='272.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(265.5488 160.1)'%3e8.8%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='291.5' y1='144' x2='291.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(284.5488 160.1)'%3e9.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='310.5' y1='144' x2='310.5' y2='150'/%3e %3ctext class='cls-3' transform='translate(303.5488 160.1)'%3e9.2%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-2' d='M20%2c144.5h6.5V10.5H20'/%3e %3cg%3e %3cline class='cls-2' x1='26' y1='129.5' x2='20' y2='129.5'/%3e %3ctext class='cls-3' transform='translate(5.877 132.7)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='112.5' x2='20' y2='112.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 115.7)'%3e100%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='94.5' x2='20' y2='94.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 97.7)'%3e150%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='77.5' x2='20' y2='77.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 80.7)'%3e200%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='60.5' x2='20' y2='60.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 63.7)'%3e250%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='43.5' x2='20' y2='43.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 46.7)'%3e300%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='26' y1='26.5' x2='20' y2='26.5'/%3e %3ctext class='cls-3' transform='translate(0.3154 29.7)'%3e350%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='viz'%3e %3ccircle class='cls-4' cx='177' cy='48' r='10'/%3e %3ccircle class='cls-4' cx='253' cy='132' r='5'/%3e %3ccircle class='cls-4' cx='234' cy='20' r='10'/%3e %3ccircle class='cls-5' cx='187' cy='52' r='9'/%3e %3ccircle class='cls-4' cx='206' cy='101' r='6'/%3e %3ccircle class='cls-6' cx='244' cy='23' r='9'/%3e %3ccircle class='cls-7' cx='102' cy='89' r='8'/%3e %3ccircle class='cls-4' cx='54' cy='76' r='6'/%3e %3ccircle class='cls-4' cx='196' cy='59' r='7'/%3e %3ccircle class='cls-6' cx='263' cy='121' r='4'/%3e %3ccircle class='cls-8' cx='102' cy='92' r='5'/%3e %3ccircle class='cls-4' cx='111' cy='75' r='7'/%3e %3ccircle class='cls-4' cx='102' cy='108' r='2'/%3e %3ccircle class='cls-7' cx='130' cy='36' r='6'/%3e %3ccircle class='cls-4' cx='130' cy='10' r='7'/%3e %3ccircle class='cls-4' cx='168' cy='131' r='2'/%3e %3ccircle class='cls-4' cx='272' cy='94' r='6'/%3e %3ccircle class='cls-6' cx='130' cy='76' r='7'/%3e %3ccircle class='cls-4' cx='102' cy='56' r='7'/%3e %3ccircle class='cls-4' cx='225' cy='114' r='4'/%3e %3ccircle class='cls-4' cx='121' cy='69' r='7'/%3e %3ccircle class='cls-7' cx='26' cy='83' r='7'/%3e %3ccircle class='cls-7' cx='206' cy='134' r='4'/%3e %3ccircle class='cls-7' cx='177' cy='44' r='9'/%3e %3ccircle class='cls-9' cx='196' cy='122' r='3'/%3e %3ccircle class='cls-8' cx='177' cy='135' r='5'/%3e %3ccircle class='cls-10' cx='177' cy='64' r='2'/%3e %3ccircle class='cls-7' cx='196' cy='112' r='3'/%3e %3ccircle class='cls-11' cx='159' cy='143' r='4'/%3e %3ccircle class='cls-10' cx='196' cy='132' r='4'/%3e %3ccircle class='cls-5' cx='196' cy='128' r='4'/%3e %3ccircle class='cls-11' cx='121' cy='137' r='3'/%3e %3ccircle class='cls-11' cx='244' cy='115' r='6'/%3e %3ccircle class='cls-11' cx='159' cy='139' r='4'/%3e %3ccircle class='cls-10' cx='206' cy='81' r='2'/%3e %3ccircle class='cls-10' cx='282' cy='97' r='6'/%3e %3ccircle class='cls-11' cx='92' cy='55' r='8'/%3e %3ccircle class='cls-10' cx='159' cy='75' r='6'/%3e %3ccircle class='cls-11' cx='130' cy='140' r='3'/%3e %3ccircle class='cls-10' cx='206' cy='76' r='7'/%3e %3ccircle class='cls-11' cx='130' cy='144' r='3'/%3e %3ccircle class='cls-7' cx='272' cy='105' r='5'/%3e %3ccircle class='cls-10' cx='263' cy='96' r='6'/%3e %3ccircle class='cls-11' cx='140' cy='87' r='7'/%3e %3ccircle class='cls-11' cx='92' cy='94' r='7'/%3e %3ccircle class='cls-11' cx='206' cy='97' r='6'/%3e %3ccircle class='cls-10' cx='140' cy='90' r='6'/%3e %3ccircle class='cls-11' cx='121' cy='70' r='6'/%3e %3ccircle class='cls-12' cx='310' cy='135' r='3'/%3e %3ccircle class='cls-6' cx='121' cy='138' r='4'/%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata = {
    name: 'Diagramme en bulles',
    id: 'rawgraphs.bubblechart',
    thumbnail: img$1,
    icon: img,
    categories: ['correlations', 'proportions'],
    description: 'La disposition de base est un nuage de points, qui permet de voir les corrélations entre deux dimensions continues. Une dimension quantitative supplémentaire avec la taille et une dimension quantitative ou catégorielle avec la couleur.',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false
  }, {
    id: 'connectedBy',
    name: 'Connexion avec',
    validTypes: ['number', 'date'],
    required: false
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true
  }];

  const mapData = {
    x: 'get',
    y: 'get',
    size: 'get',
    color: 'get',
    label: 'get',
    connectedBy: 'get'
  };

  var version = "6.5.0";

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(f) {
    let delta = f;
    let compare = f;

    if (f.length === 1) {
      delta = (d, x) => f(d) - x;
      compare = ascendingComparator(f);
    }

    function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        const mid = (lo + hi) >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    }

    function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        const mid = (lo + hi) >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }

    function center(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      const i = left(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }

    return {left, center, right};
  }

  function ascendingComparator(f) {
    return (d, x) => ascending(f(d), x);
  }

  function number(x) {
    return x === null ? NaN : +x;
  }

  function* numbers(values, valueof) {
    if (valueof === undefined) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }

  const ascendingBisect = bisector(ascending);
  const bisectRight = ascendingBisect.right;
  const bisectLeft = ascendingBisect.left;
  const bisectCenter = bisector(number).center;

  function count(values, valueof) {
    let count = 0;
    if (valueof === undefined) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          ++count;
        }
      }
    }
    return count;
  }

  function length(array) {
    return array.length | 0;
  }

  function empty(length) {
    return !(length > 0);
  }

  function arrayify(values) {
    return typeof values !== "object" || "length" in values ? values : Array.from(values);
  }

  function reducer(reduce) {
    return values => reduce(...values);
  }

  function cross(...values) {
    const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
    values = values.map(arrayify);
    const lengths = values.map(length);
    const j = values.length - 1;
    const index = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some(empty)) return product;
    while (true) {
      product.push(index.map((j, i) => values[i][j]));
      let i = j;
      while (++index[i] === lengths[i]) {
        if (i === 0) return reduce ? product.map(reduce) : product;
        index[i--] = 0;
      }
    }
  }

  function cumsum(values, valueof) {
    var sum = 0, index = 0;
    return Float64Array.from(values, valueof === undefined
      ? v => (sum += +v || 0)
      : v => (sum += +valueof(v, index++, values) || 0));
  }

  function descending(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function variance(values, valueof) {
    let count = 0;
    let delta;
    let mean = 0;
    let sum = 0;
    if (valueof === undefined) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          delta = value - mean;
          mean += delta / ++count;
          sum += delta * (value - mean);
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          delta = value - mean;
          mean += delta / ++count;
          sum += delta * (value - mean);
        }
      }
    }
    if (count > 1) return sum / (count - 1);
  }

  function deviation(values, valueof) {
    const v = variance(values, valueof);
    return v ? Math.sqrt(v) : v;
  }

  function extent(values, valueof) {
    let min;
    let max;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null) {
          if (min === undefined) {
            if (value >= value) min = max = value;
          } else {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null) {
          if (min === undefined) {
            if (value >= value) min = max = value;
          } else {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
    return [min, max];
  }

  // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
  class Adder {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y = p[j],
          hi = x + y,
          lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
        if (lo) p[i++] = lo;
        x = hi;
      }
      p[i] = x;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x, y, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x = hi;
          y = p[--n];
          hi = x + y;
          lo = y - (hi - x);
          if (lo) break;
        }
        if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
          y = lo * 2;
          x = hi + y;
          if (y == x - hi) hi = x;
        }
      }
      return hi;
    }
  }

  function fsum(values, valueof) {
    const adder = new Adder();
    if (valueof === undefined) {
      for (let value of values) {
        if (value = +value) {
          adder.add(value);
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index, values)) {
          adder.add(value);
        }
      }
    }
    return +adder;
  }

  class InternMap extends Map {
    constructor(entries = [], key = keyof) {
      super();
      Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
      for (const [key, value] of entries) this.set(key, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }

  class InternSet extends Set {
    constructor(values = [], key = keyof) {
      super();
      Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
      for (const value of values) this.add(value);
    }
    has(value) {
      return super.has(intern_get(this, value));
    }
    add(value) {
      return super.add(intern_set(this, value));
    }
    delete(value) {
      return super.delete(intern_delete(this, value));
    }
  }

  function intern_get({_intern, _key}, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }

  function intern_set({_intern, _key}, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }

  function intern_delete({_intern, _key}, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(value);
      _intern.delete(key);
    }
    return value;
  }

  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  function identity(x) {
    return x;
  }

  function group(values, ...keys) {
    return nest(values, identity, identity, keys);
  }

  function groups(values, ...keys) {
    return nest(values, Array.from, identity, keys);
  }

  function rollup(values, reduce, ...keys) {
    return nest(values, identity, reduce, keys);
  }

  function rollups(values, reduce, ...keys) {
    return nest(values, Array.from, reduce, keys);
  }

  function index(values, ...keys) {
    return nest(values, identity, unique, keys);
  }

  function indexes(values, ...keys) {
    return nest(values, Array.from, unique, keys);
  }

  function unique(values) {
    if (values.length !== 1) throw new Error("duplicate key");
    return values[0];
  }

  function nest(values, map, reduce, keys) {
    return (function regroup(values, i) {
      if (i >= keys.length) return reduce(values);
      const groups = new InternMap();
      const keyof = keys[i++];
      let index = -1;
      for (const value of values) {
        const key = keyof(value, ++index, values);
        const group = groups.get(key);
        if (group) group.push(value);
        else groups.set(key, [value]);
      }
      for (const [key, values] of groups) {
        groups.set(key, regroup(values, i));
      }
      return map(groups);
    })(values, 0);
  }

  function permute(source, keys) {
    return Array.from(keys, key => source[key]);
  }

  function sort(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f = ascending] = F;
    if (f.length === 1 || F.length > 1) {
      const index = Uint32Array.from(values, (d, i) => i);
      if (F.length > 1) {
        F = F.map(f => values.map(f));
        index.sort((i, j) => {
          for (const f of F) {
            const c = ascending(f[i], f[j]);
            if (c) return c;
          }
        });
      } else {
        f = values.map(f);
        index.sort((i, j) => ascending(f[i], f[j]));
      }
      return permute(values, index);
    }
    return values.sort(f);
  }

  function groupSort(values, reduce, key) {
    return (reduce.length === 1
      ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)))
      : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))))
      .map(([key]) => key);
  }

  var array = Array.prototype;

  var slice = array.slice;

  function constant(x) {
    return function() {
      return x;
    };
  }

  var e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);

  function ticks(start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      step = -step;
      start = Math.ceil(start * step);
      stop = Math.floor(stop * step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  }

  function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function nice(start, stop, count) {
    let prestep;
    while (true) {
      const step = tickIncrement(start, stop, count);
      if (step === prestep || step === 0 || !isFinite(step)) {
        return [start, stop];
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      }
      prestep = step;
    }
  }

  function thresholdSturges(values) {
    return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
  }

  function bin() {
    var value = identity,
        domain = extent,
        threshold = thresholdSturges;

    function histogram(data) {
      if (!Array.isArray(data)) data = Array.from(data);

      var i,
          n = data.length,
          x,
          values = new Array(n);

      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = xz[0],
          x1 = xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds, and nice the
      // default domain accordingly.
      if (!Array.isArray(tz)) {
        const max = x1, tn = +tz;
        if (domain === extent) [x0, x1] = nice(x0, x1, tn);
        tz = ticks(x0, x1, tn);

        // If the last threshold is coincident with the domain’s upper bound, the
        // last bin will be zero-width. If the default domain is used, and this
        // last threshold is coincident with the maximum input value, we can
        // extend the niced upper bound by one tick to ensure uniform bin widths;
        // otherwise, we simply remove the last threshold. Note that we don’t
        // coerce values or the domain to numbers, and thus must be careful to
        // compare order (>=) rather than strict equality (===)!
        if (tz[tz.length - 1] >= x1) {
          if (max >= x1 && domain === extent) {
            const step = tickIncrement(x0, x1, tn);
            if (isFinite(step)) {
              if (step > 0) {
                x1 = (Math.floor(x1 / step) + 1) * step;
              } else if (step < 0) {
                x1 = (Math.ceil(x1 * -step) + 1) / -step;
              }
            }
          } else {
            tz.pop();
          }
        }
      }

      // Remove any thresholds outside the domain.
      var m = tz.length;
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] > x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
    };

    histogram.domain = function(_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
    };

    histogram.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };

    return histogram;
  }

  function max(values, valueof) {
    let max;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (max < value || (max === undefined && value >= value))) {
          max = value;
        }
      }
    }
    return max;
  }

  function min(values, valueof) {
    let min;
    if (valueof === undefined) {
      for (const value of values) {
        if (value != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (min > value || (min === undefined && value >= value))) {
          min = value;
        }
      }
    }
    return min;
  }

  // Based on https://github.com/mourner/quickselect
  // ISC license, Copyright 2018 Vladimir Agafonkin.
  function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const m = k - left + 1;
        const z = Math.log(n);
        const s = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        quickselect(array, k, newLeft, newRight, compare);
      }

      const t = array[k];
      let i = left;
      let j = right;

      swap(array, left, k);
      if (compare(array[right], t) > 0) swap(array, left, right);

      while (i < j) {
        swap(array, i, j), ++i, --j;
        while (compare(array[i], t) < 0) ++i;
        while (compare(array[j], t) > 0) --j;
      }

      if (compare(array[left], t) === 0) swap(array, left, j);
      else ++j, swap(array, j, right);

      if (j <= k) left = j + 1;
      if (k <= j) right = j - 1;
    }
    return array;
  }

  function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
  }

  function quantile(values, p, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return min(values);
    if (p >= 1) return max(values);
    var n,
        i = (n - 1) * p,
        i0 = Math.floor(i),
        value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
        value1 = min(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }

  function quantileSorted(values, p, valueof = number) {
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n,
        i = (n - 1) * p,
        i0 = Math.floor(i),
        value0 = +valueof(values[i0], i0, values),
        value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }

  function freedmanDiaconis(values, min, max) {
    return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
  }

  function scott(values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
  }

  function maxIndex(values, valueof) {
    let max;
    let maxIndex = -1;
    let index = -1;
    if (valueof === undefined) {
      for (const value of values) {
        ++index;
        if (value != null
            && (max < value || (max === undefined && value >= value))) {
          max = value, maxIndex = index;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (max < value || (max === undefined && value >= value))) {
          max = value, maxIndex = index;
        }
      }
    }
    return maxIndex;
  }

  function mean(values, valueof) {
    let count = 0;
    let sum = 0;
    if (valueof === undefined) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    }
    if (count) return sum / count;
  }

  function median(values, valueof) {
    return quantile(values, 0.5, valueof);
  }

  function* flatten(arrays) {
    for (const array of arrays) {
      yield* array;
    }
  }

  function merge(arrays) {
    return Array.from(flatten(arrays));
  }

  function minIndex(values, valueof) {
    let min;
    let minIndex = -1;
    let index = -1;
    if (valueof === undefined) {
      for (const value of values) {
        ++index;
        if (value != null
            && (min > value || (min === undefined && value >= value))) {
          min = value, minIndex = index;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index, values)) != null
            && (min > value || (min === undefined && value >= value))) {
          min = value, minIndex = index;
        }
      }
    }
    return minIndex;
  }

  function pairs(values, pairof = pair) {
    const pairs = [];
    let previous;
    let first = false;
    for (const value of values) {
      if (first) pairs.push(pairof(previous, value));
      previous = value;
      first = true;
    }
    return pairs;
  }

  function pair(a, b) {
    return [a, b];
  }

  function sequence(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  function least(values, compare = ascending) {
    let min;
    let defined = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values) {
        const value = compare(element);
        if (defined
            ? ascending(value, minValue) < 0
            : ascending(value, value) === 0) {
          min = element;
          minValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined
            ? compare(value, min) < 0
            : compare(value, value) === 0) {
          min = value;
          defined = true;
        }
      }
    }
    return min;
  }

  function leastIndex(values, compare = ascending) {
    if (compare.length === 1) return minIndex(values, compare);
    let minValue;
    let min = -1;
    let index = -1;
    for (const value of values) {
      ++index;
      if (min < 0
          ? compare(value, value) === 0
          : compare(value, minValue) < 0) {
        minValue = value;
        min = index;
      }
    }
    return min;
  }

  function greatest(values, compare = ascending) {
    let max;
    let defined = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value = compare(element);
        if (defined
            ? ascending(value, maxValue) > 0
            : ascending(value, value) === 0) {
          max = element;
          maxValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined
            ? compare(value, max) > 0
            : compare(value, value) === 0) {
          max = value;
          defined = true;
        }
      }
    }
    return max;
  }

  function greatestIndex(values, compare = ascending) {
    if (compare.length === 1) return maxIndex(values, compare);
    let maxValue;
    let max = -1;
    let index = -1;
    for (const value of values) {
      ++index;
      if (max < 0
          ? compare(value, value) === 0
          : compare(value, maxValue) > 0) {
        maxValue = value;
        max = index;
      }
    }
    return max;
  }

  function scan(values, compare) {
    const index = leastIndex(values, compare);
    return index < 0 ? undefined : index;
  }

  var shuffle = shuffler(Math.random);

  function shuffler(random) {
    return function shuffle(array, i0 = 0, i1 = array.length) {
      let m = i1 - (i0 = +i0);
      while (m) {
        const i = random() * m-- | 0, t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
      }
      return array;
    };
  }

  function sum(values, valueof) {
    let sum = 0;
    if (valueof === undefined) {
      for (let value of values) {
        if (value = +value) {
          sum += value;
        }
      }
    } else {
      let index = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index, values)) {
          sum += value;
        }
      }
    }
    return sum;
  }

  function transpose(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length$1), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  }

  function length$1(d) {
    return d.length;
  }

  function zip() {
    return transpose(arguments);
  }

  function every(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index = -1;
    for (const value of values) {
      if (!test(value, ++index, values)) {
        return false;
      }
    }
    return true;
  }

  function some(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    let index = -1;
    for (const value of values) {
      if (test(value, ++index, values)) {
        return true;
      }
    }
    return false;
  }

  function filter(values, test) {
    if (typeof test !== "function") throw new TypeError("test is not a function");
    const array = [];
    let index = -1;
    for (const value of values) {
      if (test(value, ++index, values)) {
        array.push(value);
      }
    }
    return array;
  }

  function map(values, mapper) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
    return Array.from(values, (value, index) => mapper(value, index, values));
  }

  function reduce(values, reducer, value) {
    if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
    const iterator = values[Symbol.iterator]();
    let done, next, index = -1;
    if (arguments.length < 3) {
      ({done, value} = iterator.next());
      if (done) return;
      ++index;
    }
    while (({done, value: next} = iterator.next()), !done) {
      value = reducer(value, next, ++index, values);
    }
    return value;
  }

  function reverse(values) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    return Array.from(values).reverse();
  }

  function difference(values, ...others) {
    values = new Set(values);
    for (const other of others) {
      for (const value of other) {
        values.delete(value);
      }
    }
    return values;
  }

  function disjoint(values, other) {
    const iterator = other[Symbol.iterator](), set = new Set();
    for (const v of values) {
      if (set.has(v)) return false;
      let value, done;
      while (({value, done} = iterator.next())) {
        if (done) break;
        if (Object.is(v, value)) return false;
        set.add(value);
      }
    }
    return true;
  }

  function set(values) {
    return values instanceof Set ? values : new Set(values);
  }

  function intersection(values, ...others) {
    values = new Set(values);
    others = others.map(set);
    out: for (const value of values) {
      for (const other of others) {
        if (!other.has(value)) {
          values.delete(value);
          continue out;
        }
      }
    }
    return values;
  }

  function superset(values, other) {
    const iterator = values[Symbol.iterator](), set = new Set();
    for (const o of other) {
      if (set.has(o)) continue;
      let value, done;
      while (({value, done} = iterator.next())) {
        if (done) return false;
        set.add(value);
        if (Object.is(o, value)) break;
      }
    }
    return true;
  }

  function subset(values, other) {
    return superset(other, values);
  }

  function union(...others) {
    const set = new Set();
    for (const other of others) {
      for (const o of other) {
        set.add(o);
      }
    }
    return set;
  }

  var slice$1 = Array.prototype.slice;

  function identity$1(x) {
    return x;
  }

  var top = 1,
      right = 2,
      bottom = 3,
      left = 4,
      epsilon = 1e-6;

  function translateX(x) {
    return "translate(" + (x + 0.5) + ",0)";
  }

  function translateY(y) {
    return "translate(0," + (y + 0.5) + ")";
  }

  function number$1(scale) {
    return d => +scale(d);
  }

  function center(scale) {
    var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scale.round()) offset = Math.round(offset);
    return function(d) {
      return +scale(d) + offset;
    };
  }

  function entering() {
    return !this.__axis;
  }

  function axis(orient, scale) {
    var tickArguments = [],
        tickValues = null,
        tickFormat = null,
        tickSizeInner = 6,
        tickSizeOuter = 6,
        tickPadding = 3,
        k = orient === top || orient === left ? -1 : 1,
        x = orient === left || orient === right ? "x" : "y",
        transform = orient === top || orient === bottom ? translateX : translateY;

    function axis(context) {
      var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
          format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
          spacing = Math.max(tickSizeInner, 0) + tickPadding,
          range = scale.range(),
          range0 = +range[0] + 0.5,
          range1 = +range[range.length - 1] + 0.5,
          position = (scale.bandwidth ? center : number$1)(scale.copy()),
          selection = context.selection ? context.selection() : context,
          path = selection.selectAll(".domain").data([null]),
          tick = selection.selectAll(".tick").data(values, scale).order(),
          tickExit = tick.exit(),
          tickEnter = tick.enter().append("g").attr("class", "tick"),
          line = tick.select("line"),
          text = tick.select("text");

      path = path.merge(path.enter().insert("path", ".tick")
          .attr("class", "domain")
          .attr("stroke", "currentColor"));

      tick = tick.merge(tickEnter);

      line = line.merge(tickEnter.append("line")
          .attr("stroke", "currentColor")
          .attr(x + "2", k * tickSizeInner));

      text = text.merge(tickEnter.append("text")
          .attr("fill", "currentColor")
          .attr(x, k * spacing)
          .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

      if (context !== selection) {
        path = path.transition(context);
        tick = tick.transition(context);
        line = line.transition(context);
        text = text.transition(context);

        tickExit = tickExit.transition(context)
            .attr("opacity", epsilon)
            .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

        tickEnter
            .attr("opacity", epsilon)
            .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
      }

      tickExit.remove();

      path
          .attr("d", orient === left || orient == right
              ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
              : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

      tick
          .attr("opacity", 1)
          .attr("transform", function(d) { return transform(position(d)); });

      line
          .attr(x + "2", k * tickSizeInner);

      text
          .attr(x, k * spacing)
          .text(format);

      selection.filter(entering)
          .attr("fill", "none")
          .attr("font-size", 10)
          .attr("font-family", "sans-serif")
          .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

      selection
          .each(function() { this.__axis = position; });
    }

    axis.scale = function(_) {
      return arguments.length ? (scale = _, axis) : scale;
    };

    axis.ticks = function() {
      return tickArguments = slice$1.call(arguments), axis;
    };

    axis.tickArguments = function(_) {
      return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
    };

    axis.tickValues = function(_) {
      return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
    };

    axis.tickFormat = function(_) {
      return arguments.length ? (tickFormat = _, axis) : tickFormat;
    };

    axis.tickSize = function(_) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
    };

    axis.tickSizeInner = function(_) {
      return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
    };

    axis.tickSizeOuter = function(_) {
      return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
    };

    axis.tickPadding = function(_) {
      return arguments.length ? (tickPadding = +_, axis) : tickPadding;
    };

    return axis;
  }

  function axisTop(scale) {
    return axis(top, scale);
  }

  function axisRight(scale) {
    return axis(right, scale);
  }

  function axisBottom(scale) {
    return axis(bottom, scale);
  }

  function axisLeft(scale) {
    return axis(left, scale);
  }

  var noop = {value: () => {}};

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set$1(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function array$1(x) {
    return typeof x === "object" && "length" in x
      ? x // Array, TypedArray, NodeList, array-like
      : Array.from(x); // Map, Set, iterable, string, or anything else
  }

  function empty$1() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty$1 : function() {
      return this.querySelectorAll(selector);
    };
  }

  function arrayAll(select) {
    return function() {
      var group = select.apply(this, arguments);
      return group == null ? [] : array$1(group);
    };
  }

  function selection_selectAll(select) {
    if (typeof select === "function") select = arrayAll(select);
    else select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  var find = Array.prototype.find;

  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }

  function childFirst() {
    return this.firstElementChild;
  }

  function selection_selectChild(match) {
    return this.select(match == null ? childFirst
        : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  var filter$1 = Array.prototype.filter;

  function children() {
    return this.children;
  }

  function childrenFilter(match) {
    return function() {
      return filter$1.call(this.children, match);
    };
  }

  function selection_selectChildren(match) {
    return this.selectAll(match == null ? children
        : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = new Map,
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
        exit[i] = node;
      }
    }
  }

  function datum(node) {
    return node.__data__;
  }

  function selection_data(value, key) {
    if (!arguments.length) return Array.from(this, datum);

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant$1(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = array$1(value.call(parent, parent && parent.__data__, j, parents)),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {
    if (!(selection instanceof Selection)) throw new Error("invalid merge");

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending$1;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    return Array.from(this);
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    let size = 0;
    for (const node of this) ++size; // eslint-disable-line no-unused-vars
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }

  function parseTypenames$1(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, options) {
    var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  function* selection_iterator() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) yield node;
      }
    }
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  function selection_selection() {
    return this;
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    selectChild: selection_selectChild,
    selectChildren: selection_selectChildren,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    selection: selection_selection,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch,
    [Symbol.iterator]: selection_iterator
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function create(name) {
    return select(creator(name).call(document.documentElement));
  }

  var nextId = 0;

  function local() {
    return new Local;
  }

  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }

  Local.prototype = local.prototype = {
    constructor: Local,
    get: function(node) {
      var id = this._;
      while (!(id in node)) if (!(node = node.parentNode)) return;
      return node[id];
    },
    set: function(node, value) {
      return node[this._] = value;
    },
    remove: function(node) {
      return this._ in node && delete node[this._];
    },
    toString: function() {
      return this._;
    }
  };

  function sourceEvent(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent) event = sourceEvent;
    return event;
  }

  function pointer(event, node) {
    event = sourceEvent(event);
    if (node === undefined) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  function pointers(events, node) {
    if (events.target) { // i.e., instanceof Event, not TouchList or iterable
      events = sourceEvent(events);
      if (node === undefined) node = events.currentTarget;
      events = events.touches || [events];
    }
    return Array.from(events, event => pointer(event, node));
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : array$1(selector)], root);
  }

  function nopropagation(event) {
    event.stopImmediatePropagation();
  }

  function noevent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  function dragDisable(view) {
    var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", noevent, true);
    if ("onselectstart" in root) {
      selection.on("selectstart.drag", noevent, true);
    } else {
      root.__noselect = root.style.MozUserSelect;
      root.style.MozUserSelect = "none";
    }
  }

  function yesdrag(view, noclick) {
    var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", null);
    if (noclick) {
      selection.on("click.drag", noevent, true);
      setTimeout(function() { selection.on("click.drag", null); }, 0);
    }
    if ("onselectstart" in root) {
      selection.on("selectstart.drag", null);
    } else {
      root.style.MozUserSelect = root.__noselect;
      delete root.__noselect;
    }
  }

  var constant$2 = x => () => x;

  function DragEvent(type, {
    sourceEvent,
    subject,
    target,
    identifier,
    active,
    x, y, dx, dy,
    dispatch
  }) {
    Object.defineProperties(this, {
      type: {value: type, enumerable: true, configurable: true},
      sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
      subject: {value: subject, enumerable: true, configurable: true},
      target: {value: target, enumerable: true, configurable: true},
      identifier: {value: identifier, enumerable: true, configurable: true},
      active: {value: active, enumerable: true, configurable: true},
      x: {value: x, enumerable: true, configurable: true},
      y: {value: y, enumerable: true, configurable: true},
      dx: {value: dx, enumerable: true, configurable: true},
      dy: {value: dy, enumerable: true, configurable: true},
      _: {value: dispatch}
    });
  }

  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // Ignore right-click, since that should open the context menu.
  function defaultFilter(event) {
    return !event.ctrlKey && !event.button;
  }

  function defaultContainer() {
    return this.parentNode;
  }

  function defaultSubject(event, d) {
    return d == null ? {x: event.x, y: event.y} : d;
  }

  function defaultTouchable() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
  }

  function drag() {
    var filter = defaultFilter,
        container = defaultContainer,
        subject = defaultSubject,
        touchable = defaultTouchable,
        gestures = {},
        listeners = dispatch("start", "drag", "end"),
        active = 0,
        mousedownx,
        mousedowny,
        mousemoving,
        touchending,
        clickDistance2 = 0;

    function drag(selection) {
      selection
          .on("mousedown.drag", mousedowned)
        .filter(touchable)
          .on("touchstart.drag", touchstarted)
          .on("touchmove.drag", touchmoved)
          .on("touchend.drag touchcancel.drag", touchended)
          .style("touch-action", "none")
          .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }

    function mousedowned(event, d) {
      if (touchending || !filter.call(this, event, d)) return;
      var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
      if (!gesture) return;
      select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
      dragDisable(event.view);
      nopropagation(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }

    function mousemoved(event) {
      noevent(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }

    function mouseupped(event) {
      select(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent(event);
      gestures.mouse("end", event);
    }

    function touchstarted(event, d) {
      if (!filter.call(this, event, d)) return;
      var touches = event.changedTouches,
          c = container.call(this, event, d),
          n = touches.length, i, gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
          nopropagation(event);
          gesture("start", event, touches[i]);
        }
      }
    }

    function touchmoved(event) {
      var touches = event.changedTouches,
          n = touches.length, i, gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          noevent(event);
          gesture("drag", event, touches[i]);
        }
      }
    }

    function touchended(event) {
      var touches = event.changedTouches,
          n = touches.length, i, gesture;

      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          nopropagation(event);
          gesture("end", event, touches[i]);
        }
      }
    }

    function beforestart(that, container, event, d, identifier, touch) {
      var dispatch = listeners.copy(),
          p = pointer(touch || event, container), dx, dy,
          s;

      if ((s = subject.call(that, new DragEvent("beforestart", {
          sourceEvent: event,
          target: drag,
          identifier,
          active,
          x: p[0],
          y: p[1],
          dx: 0,
          dy: 0,
          dispatch
        }), d)) == null) return;

      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;

      return function gesture(type, event, touch) {
        var p0 = p, n;
        switch (type) {
          case "start": gestures[identifier] = gesture, n = active++; break;
          case "end": delete gestures[identifier], --active; // nobreak
          case "drag": p = pointer(touch || event, container), n = active; break;
        }
        dispatch.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event,
            subject: s,
            target: drag,
            identifier,
            active: n,
            x: p[0] + dx,
            y: p[1] + dy,
            dx: p[0] - p0[0],
            dy: p[1] - p0[1],
            dispatch
          }),
          d
        );
      };
    }

    drag.filter = function(_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
    };

    drag.container = function(_) {
      return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
    };

    drag.subject = function(_) {
      return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
    };

    drag.touchable = function(_) {
      return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
    };

    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };

    drag.clickDistance = function(_) {
      return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
    };

    return drag;
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }

  function rgb_formatRgb() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  const radians = Math.PI / 180;
  const degrees = 180 / Math.PI;

  // https://observablehq.com/@mbostock/lab-and-rgb
  const K = 18,
      Xn = 0.96422,
      Yn = 1,
      Zn = 0.82521,
      t0 = 4 / 29,
      t1 = 6 / 29,
      t2 = 3 * t1 * t1,
      t3 = t1 * t1 * t1;

  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) return hcl2lab(o);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = rgb2lrgb(o.r),
        g = rgb2lrgb(o.g),
        b = rgb2lrgb(o.b),
        y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
    if (r === g && g === b) x = z = y; else {
      x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }

  function gray(l, opacity) {
    return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
  }

  function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
  }

  function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Lab, lab, extend(Color, {
    brighter: function(k) {
      return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function(k) {
      return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function() {
      var y = (this.l + 16) / 116,
          x = isNaN(this.a) ? y : y + this.a / 500,
          z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn * lab2xyz(x);
      y = Yn * lab2xyz(y);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
        lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
        this.opacity
      );
    }
  }));

  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }

  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }

  function lrgb2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }

  function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * degrees;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }

  function lch(l, c, h, opacity) {
    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }

  function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }

  function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }

  function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * radians;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  define(Hcl, hcl, extend(Color, {
    brighter: function(k) {
      return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
    },
    darker: function(k) {
      return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
    },
    rgb: function() {
      return hcl2lab(this).rgb();
    }
  }));

  var A = -0.14861,
      B = +1.78277,
      C = -0.29227,
      D = -0.90649,
      E = +1.97294,
      ED = E * D,
      EB = E * B,
      BC_DA = B * C - D * A;

  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
        bl = b - l,
        k = (E * (g - l) - C * bl) / D,
        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
  }

  function cubehelix(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
  }

  function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Cubehelix, cubehelix, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians,
          l = +this.l,
          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
          cosh = Math.cos(h),
          sinh = Math.sin(h);
      return new Rgb(
        255 * (l + a * (A * cosh + B * sinh)),
        255 * (l + a * (C * cosh + D * sinh)),
        255 * (l + a * (E * cosh)),
        this.opacity
      );
    }
  }));

  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0
        + (4 - 6 * t2 + 3 * t3) * v1
        + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
        + t3 * v3) / 6;
  }

  function basis$1(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
          v1 = values[i],
          v2 = values[i + 1],
          v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
          v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  function basisClosed(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
          v0 = values[(i + n - 1) % n],
          v1 = values[i % n],
          v2 = values[(i + 1) % n],
          v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  var constant$3 = x => () => x;

  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
  }

  var interpolateRgb = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb$1(start, end) {
      var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb$1.gamma = rgbGamma;

    return rgb$1;
  })(1);

  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length,
          r = new Array(n),
          g = new Array(n),
          b = new Array(n),
          i, color;
      for (i = 0; i < n; ++i) {
        color = rgb(colors[i]);
        r[i] = color.r || 0;
        g[i] = color.g || 0;
        b[i] = color.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color.opacity = 1;
      return function(t) {
        color.r = r(t);
        color.g = g(t);
        color.b = b(t);
        return color + "";
      };
    };
  }

  var rgbBasis = rgbSpline(basis$1);
  var rgbBasisClosed = rgbSpline(basisClosed);

  function numberArray(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function array$2(a, b) {
    return (isNumberArray(b) ? numberArray : genericArray)(a, b);
  }

  function genericArray(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function interpolateNumber(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolate(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function interpolateString(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolate(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$3(b)
        : (t === "number" ? interpolateNumber
        : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
        : b instanceof color ? interpolateRgb
        : b instanceof Date ? date
        : isNumberArray(b) ? numberArray
        : Array.isArray(b) ? genericArray
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
        : interpolateNumber)(a, b);
  }

  function discrete(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  function hue$1(a, b) {
    var i = hue(+a, +b);
    return function(t) {
      var x = i(t);
      return x - 360 * Math.floor(x / 360);
    };
  }

  function interpolateRound(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  var degrees$1 = 180 / Math.PI;

  var identity$2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };

  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees$1,
      skewX: Math.atan(skewX) * degrees$1,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var svgNode;

  /* eslint-disable no-undef */
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity$2 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
  }

  function parseSvg(value) {
    if (value == null) return identity$2;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  function interpolateTransform(parse, pxComma, pxParen, degParen) {

    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }

    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }

    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
        q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }

    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }

    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }

    return function(a, b) {
      var s = [], // string constants and placeholders
          q = []; // number interpolators
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null; // gc
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }

  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  var epsilon2 = 1e-12;

  function cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }

  function sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }

  function tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }

  var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

    // p0 = [ux0, uy0, w0]
    // p1 = [ux1, uy1, w1]
    function zoom(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
          ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
          dx = ux1 - ux0,
          dy = uy1 - uy0,
          d2 = dx * dx + dy * dy,
          i,
          S;

      // Special case for u0 ≅ u1.
      if (d2 < epsilon2) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S)
          ];
        };
      }

      // General case.
      else {
        var d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
            b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function(t) {
          var s = t * S,
              coshr0 = cosh(r0),
              u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
          return [
            ux0 + u * dx,
            uy0 + u * dy,
            w0 * coshr0 / cosh(rho * s + r0)
          ];
        };
      }

      i.duration = S * 1000 * rho / Math.SQRT2;

      return i;
    }

    zoom.rho = function(_) {
      var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
      return zoomRho(_1, _2, _4);
    };

    return zoom;
  })(Math.SQRT2, 2, 4);

  function hsl$1(hue) {
    return function(start, end) {
      var h = hue((start = hsl(start)).h, (end = hsl(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
  }

  var hsl$2 = hsl$1(hue);
  var hslLong = hsl$1(nogamma);

  function lab$1(start, end) {
    var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
        a = nogamma(start.a, end.a),
        b = nogamma(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.l = l(t);
      start.a = a(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  function hcl$1(hue) {
    return function(start, end) {
      var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
          c = nogamma(start.c, end.c),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.c = c(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
  }

  var hcl$2 = hcl$1(hue);
  var hclLong = hcl$1(nogamma);

  function cubehelix$1(hue) {
    return (function cubehelixGamma(y) {
      y = +y;

      function cubehelix$1(start, end) {
        var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }

      cubehelix$1.gamma = cubehelixGamma;

      return cubehelix$1;
    })(1);
  }

  var cubehelix$2 = cubehelix$1(hue);
  var cubehelixLong = cubehelix$1(nogamma);

  function piecewise(interpolate$1, values) {
    if (values === undefined) values = interpolate$1, interpolate$1 = interpolate;
    var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
    while (i < n) I[i] = interpolate$1(v, v = values[++i]);
    return function(t) {
      var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
      return I[i](t - i);
    };
  }

  function quantize(interpolator, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
    return samples;
  }

  var frame = 0, // is an animation frame pending?
      timeout = 0, // is a timeout pending?
      interval = 0, // are any timers active?
      pokeDelay = 1000, // how frequently we check for clock skew
      taskHead,
      taskTail,
      clockLast = 0,
      clockNow = 0,
      clockSkew = 0,
      clock = typeof performance === "object" && performance.now ? performance : Date,
      setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }

  function clearNow() {
    clockNow = 0;
  }

  function Timer() {
    this._call =
    this._time =
    this._next = null;
  }

  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };

  function timer(callback, delay, time) {
    var t = new Timer;
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush() {
    now(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
      t = t._next;
    }
    --frame;
  }

  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }

  function poke() {
    var now = clock.now(), delay = now - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
  }

  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }

  function sleep(time) {
    if (frame) return; // Soonest alarm already set, or will be.
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  function timeout$1(callback, delay, time) {
    var t = new Timer;
    delay = delay == null ? 0 : +delay;
    t.restart(elapsed => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  function interval$1(callback, delay, time) {
    var t = new Timer, total = delay;
    if (delay == null) return t.restart(callback, delay, time), t;
    t._restart = t.restart;
    t.restart = function(callback, delay, time) {
      delay = +delay, time = time == null ? now() : +time;
      t._restart(function tick(elapsed) {
        elapsed += total;
        t._restart(tick, total += delay, time);
        callback(elapsed);
      }, delay, time);
    };
    t.restart(callback, delay, time);
    return t;
  }

  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];

  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;

  function schedule(node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id in schedules) return;
    create$1(node, id, {
      name: name,
      index: index, // For context during callback.
      group: group, // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }

  function init(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }

  function set$2(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }

  function get$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
    return schedule;
  }

  function create$1(node, id, self) {
    var schedules = node.__transition,
        tween;

    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = timer(schedule, 0, self.time);

    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start, self.delay, self.time);

      // If the elapsed delay is less than our first sleep, start immediately.
      if (self.delay <= elapsed) start(elapsed - self.delay);
    }

    function start(elapsed) {
      var i, j, n, o;

      // If the state is not SCHEDULED, then we previously errored on start.
      if (self.state !== SCHEDULED) return stop();

      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name) continue;

        // While this element already has a starting transition during this frame,
        // defer starting an interrupting transition until that transition has a
        // chance to tick (and possibly end); see d3/d3-transition#54!
        if (o.state === STARTED) return timeout$1(start);

        // Interrupt the active transition, if any.
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }

        // Cancel any pre-empted transitions.
        else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }

      // Defer the first tick to end of the current frame; see d3/d3#1576.
      // Note the transition may be canceled after start and before the first tick!
      // Note this must be scheduled before the start event; see d3/d3-transition#16!
      // Assuming this is successful, subsequent callbacks go straight to tick.
      timeout$1(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });

      // Dispatch the start event.
      // Note this must be done before the tween are initialized.
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING) return; // interrupted
      self.state = STARTED;

      // Initialize the tween, deleting null tween.
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }

    function tick(elapsed) {
      var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
          i = -1,
          n = tween.length;

      while (++i < n) {
        tween[i].call(node, t);
      }

      // Dispatch the end event.
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }

    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id];
      for (var i in schedules) return; // eslint-disable-line no-unused-vars
      delete node.__transition;
    }
  }

  function interrupt(node, name) {
    var schedules = node.__transition,
        schedule,
        active,
        empty = true,
        i;

    if (!schedules) return;

    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }

    if (empty) delete node.__transition;
  }

  function selection_interrupt(name) {
    return this.each(function() {
      interrupt(this, name);
    });
  }

  function tweenRemove(id, name) {
    var tween0, tween1;
    return function() {
      var schedule = set$2(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }

      schedule.tween = tween1;
    };
  }

  function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error;
    return function() {
      var schedule = set$2(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) tween1.push(t);
      }

      schedule.tween = tween1;
    };
  }

  function transition_tween(name, value) {
    var id = this._id;

    name += "";

    if (arguments.length < 2) {
      var tween = get$1(this.node(), id).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }

    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
  }

  function tweenValue(transition, name, value) {
    var id = transition._id;

    transition.each(function() {
      var schedule = set$2(this, id);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });

    return function(node) {
      return get$1(node, id).value[name];
    };
  }

  function interpolate$1(a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber
        : b instanceof color ? interpolateRgb
        : (c = color(b)) ? (b = c, interpolateRgb)
        : interpolateString)(a, b);
  }

  function attrRemove$1(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrConstantNS$1(fullname, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function attrFunctionNS$1(fullname, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function transition_attr(name, value) {
    var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
    return this.attrTween(name, typeof value === "function"
        ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
        : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
        : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
  }

  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i.call(this, t));
    };
  }

  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }

  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function transition_attrTween(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  function delayFunction(id, value) {
    return function() {
      init(this, id).delay = +value.apply(this, arguments);
    };
  }

  function delayConstant(id, value) {
    return value = +value, function() {
      init(this, id).delay = value;
    };
  }

  function transition_delay(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? delayFunction
            : delayConstant)(id, value))
        : get$1(this.node(), id).delay;
  }

  function durationFunction(id, value) {
    return function() {
      set$2(this, id).duration = +value.apply(this, arguments);
    };
  }

  function durationConstant(id, value) {
    return value = +value, function() {
      set$2(this, id).duration = value;
    };
  }

  function transition_duration(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? durationFunction
            : durationConstant)(id, value))
        : get$1(this.node(), id).duration;
  }

  function easeConstant(id, value) {
    if (typeof value !== "function") throw new Error;
    return function() {
      set$2(this, id).ease = value;
    };
  }

  function transition_ease(value) {
    var id = this._id;

    return arguments.length
        ? this.each(easeConstant(id, value))
        : get$1(this.node(), id).ease;
  }

  function easeVarying(id, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function") throw new Error;
      set$2(this, id).ease = v;
    };
  }

  function transition_easeVarying(value) {
    if (typeof value !== "function") throw new Error;
    return this.each(easeVarying(this._id, value));
  }

  function transition_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  function transition_merge(transition) {
    if (transition._id !== this._id) throw new Error;

    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Transition(merges, this._parents, this._name, this._id);
  }

  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0) t = t.slice(0, i);
      return !t || t === "start";
    });
  }

  function onFunction(id, name, listener) {
    var on0, on1, sit = start(name) ? init : set$2;
    return function() {
      var schedule = sit(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

      schedule.on = on1;
    };
  }

  function transition_on(name, listener) {
    var id = this._id;

    return arguments.length < 2
        ? get$1(this.node(), id).on.on(name)
        : this.each(onFunction(id, name, listener));
  }

  function removeFunction(id) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition) if (+i !== id) return;
      if (parent) parent.removeChild(this);
    };
  }

  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }

  function transition_select(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
        }
      }
    }

    return new Transition(subgroups, this._parents, name, id);
  }

  function transition_selectAll(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
            if (child = children[k]) {
              schedule(child, name, id, k, children, inherit);
            }
          }
          subgroups.push(children);
          parents.push(node);
        }
      }
    }

    return new Transition(subgroups, parents, name, id);
  }

  var Selection$1 = selection.prototype.constructor;

  function transition_selection() {
    return new Selection$1(this._groups, this._parents);
  }

  function styleNull(name, interpolate) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }

  function styleRemove$1(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function styleFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          value1 = value(this),
          string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function styleMaybeRemove(id, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
    return function() {
      var schedule = set$2(this, id),
          on = schedule.on,
          listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

      schedule.on = on1;
    };
  }

  function transition_style(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
    return value == null ? this
        .styleTween(name, styleNull(name, i))
        .on("end.style." + name, styleRemove$1(name))
      : typeof value === "function" ? this
        .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
        .each(styleMaybeRemove(this._id, name))
      : this
        .styleTween(name, styleConstant$1(name, i, value), priority)
        .on("end.style." + name, null);
  }

  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i.call(this, t), priority);
    };
  }

  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }

  function transition_styleTween(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction$1(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }

  function transition_text(value) {
    return this.tween("text", typeof value === "function"
        ? textFunction$1(tweenValue(this, "text", value))
        : textConstant$1(value == null ? "" : value + ""));
  }

  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }

  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, textTween(value));
  }

  function transition_transition() {
    var name = this._name,
        id0 = this._id,
        id1 = newId();

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit = get$1(node, id0);
          schedule(node, name, id1, i, group, {
            time: inherit.time + inherit.delay + inherit.duration,
            delay: 0,
            duration: inherit.duration,
            ease: inherit.ease
          });
        }
      }
    }

    return new Transition(groups, this._parents, name, id1);
  }

  function transition_end() {
    var on0, on1, that = this, id = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = {value: reject},
          end = {value: function() { if (--size === 0) resolve(); }};

      that.each(function() {
        var schedule = set$2(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }

        schedule.on = on1;
      });

      // The selection was empty, resolve end immediately
      if (size === 0) resolve();
    });
  }

  var id = 0;

  function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
  }

  function transition(name) {
    return selection().transition(name);
  }

  function newId() {
    return ++id;
  }

  var selection_prototype = selection.prototype;

  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    easeVarying: transition_easeVarying,
    end: transition_end,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  const linear$1 = t => +t;

  function quadIn(t) {
    return t * t;
  }

  function quadOut(t) {
    return t * (2 - t);
  }

  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }

  function cubicIn(t) {
    return t * t * t;
  }

  function cubicOut(t) {
    return --t * t * t + 1;
  }

  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  var exponent = 3;

  var polyIn = (function custom(e) {
    e = +e;

    function polyIn(t) {
      return Math.pow(t, e);
    }

    polyIn.exponent = custom;

    return polyIn;
  })(exponent);

  var polyOut = (function custom(e) {
    e = +e;

    function polyOut(t) {
      return 1 - Math.pow(1 - t, e);
    }

    polyOut.exponent = custom;

    return polyOut;
  })(exponent);

  var polyInOut = (function custom(e) {
    e = +e;

    function polyInOut(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }

    polyInOut.exponent = custom;

    return polyInOut;
  })(exponent);

  var pi = Math.PI,
      halfPi = pi / 2;

  function sinIn(t) {
    return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
  }

  function sinOut(t) {
    return Math.sin(t * halfPi);
  }

  function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
  }

  // tpmt is two power minus ten times t scaled to [0,1]
  function tpmt(x) {
    return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
  }

  function expIn(t) {
    return tpmt(1 - +t);
  }

  function expOut(t) {
    return 1 - tpmt(t);
  }

  function expInOut(t) {
    return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
  }

  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }

  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }

  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }

  var b1 = 4 / 11,
      b2 = 6 / 11,
      b3 = 8 / 11,
      b4 = 3 / 4,
      b5 = 9 / 11,
      b6 = 10 / 11,
      b7 = 15 / 16,
      b8 = 21 / 22,
      b9 = 63 / 64,
      b0 = 1 / b1 / b1;

  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }

  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }

  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }

  var overshoot = 1.70158;

  var backIn = (function custom(s) {
    s = +s;

    function backIn(t) {
      return (t = +t) * t * (s * (t - 1) + t);
    }

    backIn.overshoot = custom;

    return backIn;
  })(overshoot);

  var backOut = (function custom(s) {
    s = +s;

    function backOut(t) {
      return --t * t * ((t + 1) * s + t) + 1;
    }

    backOut.overshoot = custom;

    return backOut;
  })(overshoot);

  var backInOut = (function custom(s) {
    s = +s;

    function backInOut(t) {
      return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
    }

    backInOut.overshoot = custom;

    return backInOut;
  })(overshoot);

  var tau = 2 * Math.PI,
      amplitude = 1,
      period = 0.3;

  var elasticIn = (function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticIn(t) {
      return a * tpmt(-(--t)) * Math.sin((s - t) / p);
    }

    elasticIn.amplitude = function(a) { return custom(a, p * tau); };
    elasticIn.period = function(p) { return custom(a, p); };

    return elasticIn;
  })(amplitude, period);

  var elasticOut = (function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticOut(t) {
      return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
    }

    elasticOut.amplitude = function(a) { return custom(a, p * tau); };
    elasticOut.period = function(p) { return custom(a, p); };

    return elasticOut;
  })(amplitude, period);

  var elasticInOut = (function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticInOut(t) {
      return ((t = t * 2 - 1) < 0
          ? a * tpmt(-t) * Math.sin((s - t) / p)
          : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
    }

    elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
    elasticInOut.period = function(p) { return custom(a, p); };

    return elasticInOut;
  })(amplitude, period);

  var defaultTiming = {
    time: null, // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };

  function inherit(node, id) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id} not found`);
      }
    }
    return timing;
  }

  function selection_transition(name) {
    var id,
        timing;

    if (name instanceof Transition) {
      id = name._id, name = name._name;
    } else {
      id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule(node, name, id, i, group, timing || inherit(node, id));
        }
      }
    }

    return new Transition(groups, this._parents, name, id);
  }

  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;

  var root$1 = [null];

  function active(node, name) {
    var schedules = node.__transition,
        schedule,
        i;

    if (schedules) {
      name = name == null ? null : name + "";
      for (i in schedules) {
        if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
          return new Transition([[node]], root$1, name, +i);
        }
      }
    }

    return null;
  }

  var constant$4 = x => () => x;

  function BrushEvent(type, {
    sourceEvent,
    target,
    selection,
    mode,
    dispatch
  }) {
    Object.defineProperties(this, {
      type: {value: type, enumerable: true, configurable: true},
      sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
      target: {value: target, enumerable: true, configurable: true},
      selection: {value: selection, enumerable: true, configurable: true},
      mode: {value: mode, enumerable: true, configurable: true},
      _: {value: dispatch}
    });
  }

  function nopropagation$1(event) {
    event.stopImmediatePropagation();
  }

  function noevent$1(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  var MODE_DRAG = {name: "drag"},
      MODE_SPACE = {name: "space"},
      MODE_HANDLE = {name: "handle"},
      MODE_CENTER = {name: "center"};

  const {abs, max: max$1, min: min$1} = Math;

  function number1(e) {
    return [+e[0], +e[1]];
  }

  function number2(e) {
    return [number1(e[0]), number1(e[1])];
  }

  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
    output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
  };

  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
    output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
  };

  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) { return xy == null ? null : number2(xy); },
    output: function(xy) { return xy; }
  };

  var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };

  var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
  };

  var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
  };

  var signsX = {
    overlay: +1,
    selection: +1,
    n: null,
    e: +1,
    s: null,
    w: -1,
    nw: -1,
    ne: +1,
    se: +1,
    sw: -1
  };

  var signsY = {
    overlay: +1,
    selection: +1,
    n: -1,
    e: null,
    s: +1,
    w: null,
    nw: -1,
    ne: -1,
    se: +1,
    sw: +1
  };

  function type(t) {
    return {type: t};
  }

  // Ignore right-click, since that should open the context menu.
  function defaultFilter$1(event) {
    return !event.ctrlKey && !event.button;
  }

  function defaultExtent() {
    var svg = this.ownerSVGElement || this;
    if (svg.hasAttribute("viewBox")) {
      svg = svg.viewBox.baseVal;
      return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
    }
    return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
  }

  function defaultTouchable$1() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
  }

  // Like d3.local, but with the name “__brush” rather than auto-generated.
  function local$1(node) {
    while (!node.__brush) if (!(node = node.parentNode)) return;
    return node.__brush;
  }

  function empty$2(extent) {
    return extent[0][0] === extent[1][0]
        || extent[0][1] === extent[1][1];
  }

  function brushSelection(node) {
    var state = node.__brush;
    return state ? state.dim.output(state.selection) : null;
  }

  function brushX() {
    return brush$1(X);
  }

  function brushY() {
    return brush$1(Y);
  }

  function brush() {
    return brush$1(XY);
  }

  function brush$1(dim) {
    var extent = defaultExtent,
        filter = defaultFilter$1,
        touchable = defaultTouchable$1,
        keys = true,
        listeners = dispatch("start", "brush", "end"),
        handleSize = 6,
        touchending;

    function brush(group) {
      var overlay = group
          .property("__brush", initialize)
        .selectAll(".overlay")
        .data([type("overlay")]);

      overlay.enter().append("rect")
          .attr("class", "overlay")
          .attr("pointer-events", "all")
          .attr("cursor", cursors.overlay)
        .merge(overlay)
          .each(function() {
            var extent = local$1(this).extent;
            select(this)
                .attr("x", extent[0][0])
                .attr("y", extent[0][1])
                .attr("width", extent[1][0] - extent[0][0])
                .attr("height", extent[1][1] - extent[0][1]);
          });

      group.selectAll(".selection")
        .data([type("selection")])
        .enter().append("rect")
          .attr("class", "selection")
          .attr("cursor", cursors.selection)
          .attr("fill", "#777")
          .attr("fill-opacity", 0.3)
          .attr("stroke", "#fff")
          .attr("shape-rendering", "crispEdges");

      var handle = group.selectAll(".handle")
        .data(dim.handles, function(d) { return d.type; });

      handle.exit().remove();

      handle.enter().append("rect")
          .attr("class", function(d) { return "handle handle--" + d.type; })
          .attr("cursor", function(d) { return cursors[d.type]; });

      group
          .each(redraw)
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .on("mousedown.brush", started)
        .filter(touchable)
          .on("touchstart.brush", started)
          .on("touchmove.brush", touchmoved)
          .on("touchend.brush touchcancel.brush", touchended)
          .style("touch-action", "none")
          .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }

    brush.move = function(group, selection) {
      if (group.tween) {
        group
            .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
            .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
            .tween("brush", function() {
              var that = this,
                  state = that.__brush,
                  emit = emitter(that, arguments),
                  selection0 = state.selection,
                  selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                  i = interpolate(selection0, selection1);

              function tween(t) {
                state.selection = t === 1 && selection1 === null ? null : i(t);
                redraw.call(that);
                emit.brush();
              }

              return selection0 !== null && selection1 !== null ? tween : tween(1);
            });
      } else {
        group
            .each(function() {
              var that = this,
                  args = arguments,
                  state = that.__brush,
                  selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                  emit = emitter(that, args).beforestart();

              interrupt(that);
              state.selection = selection1 === null ? null : selection1;
              redraw.call(that);
              emit.start().brush().end();
            });
      }
    };

    brush.clear = function(group) {
      brush.move(group, null);
    };

    function redraw() {
      var group = select(this),
          selection = local$1(this).selection;

      if (selection) {
        group.selectAll(".selection")
            .style("display", null)
            .attr("x", selection[0][0])
            .attr("y", selection[0][1])
            .attr("width", selection[1][0] - selection[0][0])
            .attr("height", selection[1][1] - selection[0][1]);

        group.selectAll(".handle")
            .style("display", null)
            .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
            .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
            .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
            .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
      }

      else {
        group.selectAll(".selection,.handle")
            .style("display", "none")
            .attr("x", null)
            .attr("y", null)
            .attr("width", null)
            .attr("height", null);
      }
    }

    function emitter(that, args, clean) {
      var emit = that.__brush.emitter;
      return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
    }

    function Emitter(that, args, clean) {
      this.that = that;
      this.args = args;
      this.state = that.__brush;
      this.active = 0;
      this.clean = clean;
    }

    Emitter.prototype = {
      beforestart: function() {
        if (++this.active === 1) this.state.emitter = this, this.starting = true;
        return this;
      },
      start: function(event, mode) {
        if (this.starting) this.starting = false, this.emit("start", event, mode);
        else this.emit("brush", event);
        return this;
      },
      brush: function(event, mode) {
        this.emit("brush", event, mode);
        return this;
      },
      end: function(event, mode) {
        if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
        return this;
      },
      emit: function(type, event, mode) {
        var d = select(this.that).datum();
        listeners.call(
          type,
          this.that,
          new BrushEvent(type, {
            sourceEvent: event,
            target: brush,
            selection: dim.output(this.state.selection),
            mode,
            dispatch: listeners
          }),
          d
        );
      }
    };

    function started(event) {
      if (touchending && !event.touches) return;
      if (!filter.apply(this, arguments)) return;

      var that = this,
          type = event.target.__data__.type,
          mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
          signX = dim === Y ? null : signsX[type],
          signY = dim === X ? null : signsY[type],
          state = local$1(that),
          extent = state.extent,
          selection = state.selection,
          W = extent[0][0], w0, w1,
          N = extent[0][1], n0, n1,
          E = extent[1][0], e0, e1,
          S = extent[1][1], s0, s1,
          dx = 0,
          dy = 0,
          moving,
          shifting = signX && signY && keys && event.shiftKey,
          lockX,
          lockY,
          points = Array.from(event.touches || [event], t => {
            const i = t.identifier;
            t = pointer(t, that);
            t.point0 = t.slice();
            t.identifier = i;
            return t;
          });

      if (type === "overlay") {
        if (selection) moving = true;
        const pts = [points[0], points[1] || points[0]];
        state.selection = selection = [[
            w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
            n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
          ], [
            e0 = dim === Y ? E : max$1(pts[0][0], pts[1][0]),
            s0 = dim === X ? S : max$1(pts[0][1], pts[1][1])
          ]];
        if (points.length > 1) move();
      } else {
        w0 = selection[0][0];
        n0 = selection[0][1];
        e0 = selection[1][0];
        s0 = selection[1][1];
      }

      w1 = w0;
      n1 = n0;
      e1 = e0;
      s1 = s0;

      var group = select(that)
          .attr("pointer-events", "none");

      var overlay = group.selectAll(".overlay")
          .attr("cursor", cursors[type]);

      interrupt(that);
      var emit = emitter(that, arguments, true).beforestart();

      if (event.touches) {
        emit.moved = moved;
        emit.ended = ended;
      } else {
        var view = select(event.view)
            .on("mousemove.brush", moved, true)
            .on("mouseup.brush", ended, true);
        if (keys) view
            .on("keydown.brush", keydowned, true)
            .on("keyup.brush", keyupped, true);

        dragDisable(event.view);
      }

      redraw.call(that);
      emit.start(event, mode.name);

      function moved(event) {
        for (const p of event.changedTouches || [event]) {
          for (const d of points)
            if (d.identifier === p.identifier) d.cur = pointer(p, that);
        }
        if (shifting && !lockX && !lockY && points.length === 1) {
          const point = points[0];
          if (abs(point.cur[0] - point[0]) > abs(point.cur[1] - point[1]))
            lockY = true;
          else
            lockX = true;
        }
        for (const point of points)
          if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
        moving = true;
        noevent$1(event);
        move(event);
      }

      function move(event) {
        const point = points[0], point0 = point.point0;
        var t;

        dx = point[0] - point0[0];
        dy = point[1] - point0[1];

        switch (mode) {
          case MODE_SPACE:
          case MODE_DRAG: {
            if (signX) dx = max$1(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = max$1(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }
          case MODE_HANDLE: {
            if (points[1]) {
              if (signX) w1 = max$1(W, min$1(E, points[0][0])), e1 = max$1(W, min$1(E, points[1][0])), signX = 1;
              if (signY) n1 = max$1(N, min$1(S, points[0][1])), s1 = max$1(N, min$1(S, points[1][1])), signY = 1;
            } else {
              if (signX < 0) dx = max$1(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
              else if (signX > 0) dx = max$1(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0) dy = max$1(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
              else if (signY > 0) dy = max$1(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            }
            break;
          }
          case MODE_CENTER: {
            if (signX) w1 = max$1(W, min$1(E, w0 - dx * signX)), e1 = max$1(W, min$1(E, e0 + dx * signX));
            if (signY) n1 = max$1(N, min$1(S, n0 - dy * signY)), s1 = max$1(N, min$1(S, s0 + dy * signY));
            break;
          }
        }

        if (e1 < w1) {
          signX *= -1;
          t = w0, w0 = e0, e0 = t;
          t = w1, w1 = e1, e1 = t;
          if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
        }

        if (s1 < n1) {
          signY *= -1;
          t = n0, n0 = s0, s0 = t;
          t = n1, n1 = s1, s1 = t;
          if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
        }

        if (state.selection) selection = state.selection; // May be set by brush.move!
        if (lockX) w1 = selection[0][0], e1 = selection[1][0];
        if (lockY) n1 = selection[0][1], s1 = selection[1][1];

        if (selection[0][0] !== w1
            || selection[0][1] !== n1
            || selection[1][0] !== e1
            || selection[1][1] !== s1) {
          state.selection = [[w1, n1], [e1, s1]];
          redraw.call(that);
          emit.brush(event, mode.name);
        }
      }

      function ended(event) {
        nopropagation$1(event);
        if (event.touches) {
          if (event.touches.length) return;
          if (touchending) clearTimeout(touchending);
          touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        } else {
          yesdrag(event.view, moving);
          view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
        }
        group.attr("pointer-events", "all");
        overlay.attr("cursor", cursors.overlay);
        if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
        if (empty$2(selection)) state.selection = null, redraw.call(that);
        emit.end(event, mode.name);
      }

      function keydowned(event) {
        switch (event.keyCode) {
          case 16: { // SHIFT
            shifting = signX && signY;
            break;
          }
          case 18: { // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move();
            }
            break;
          }
          case 32: { // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move();
            }
            break;
          }
          default: return;
        }
        noevent$1(event);
      }

      function keyupped(event) {
        switch (event.keyCode) {
          case 16: { // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move();
            }
            break;
          }
          case 18: { // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move();
            }
            break;
          }
          case 32: { // SPACE
            if (mode === MODE_SPACE) {
              if (event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }
              overlay.attr("cursor", cursors[type]);
              move();
            }
            break;
          }
          default: return;
        }
        noevent$1(event);
      }
    }

    function touchmoved(event) {
      emitter(this, arguments).moved(event);
    }

    function touchended(event) {
      emitter(this, arguments).ended(event);
    }

    function initialize() {
      var state = this.__brush || {selection: null};
      state.extent = number2(extent.apply(this, arguments));
      state.dim = dim;
      return state;
    }

    brush.extent = function(_) {
      return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4(number2(_)), brush) : extent;
    };

    brush.filter = function(_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), brush) : filter;
    };

    brush.touchable = function(_) {
      return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), brush) : touchable;
    };

    brush.handleSize = function(_) {
      return arguments.length ? (handleSize = +_, brush) : handleSize;
    };

    brush.keyModifiers = function(_) {
      return arguments.length ? (keys = !!_, brush) : keys;
    };

    brush.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? brush : value;
    };

    return brush;
  }

  var abs$1 = Math.abs;
  var cos = Math.cos;
  var sin = Math.sin;
  var pi$1 = Math.PI;
  var halfPi$1 = pi$1 / 2;
  var tau$1 = pi$1 * 2;
  var max$2 = Math.max;
  var epsilon$1 = 1e-12;

  function range(i, j) {
    return Array.from({length: j - i}, (_, k) => i + k);
  }

  function compareValue(compare) {
    return function(a, b) {
      return compare(
        a.source.value + a.target.value,
        b.source.value + b.target.value
      );
    };
  }

  function chord() {
    return chord$1(false, false);
  }

  function chordTranspose() {
    return chord$1(false, true);
  }

  function chordDirected() {
    return chord$1(true, false);
  }

  function chord$1(directed, transpose) {
    var padAngle = 0,
        sortGroups = null,
        sortSubgroups = null,
        sortChords = null;

    function chord(matrix) {
      var n = matrix.length,
          groupSums = new Array(n),
          groupIndex = range(0, n),
          chords = new Array(n * n),
          groups = new Array(n),
          k = 0, dx;

      matrix = Float64Array.from({length: n * n}, transpose
          ? (_, i) => matrix[i % n][i / n | 0]
          : (_, i) => matrix[i / n | 0][i % n]);

      // Compute the scaling factor from value to angle in [0, 2pi].
      for (let i = 0; i < n; ++i) {
        let x = 0;
        for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
        k += groupSums[i] = x;
      }
      k = max$2(0, tau$1 - padAngle * n) / k;
      dx = k ? padAngle : tau$1 / n;

      // Compute the angles for each group and constituent chord.
      {
        let x = 0;
        if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
        for (const i of groupIndex) {
          const x0 = x;
          if (directed) {
            const subgroupIndex = range(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
            if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
            for (const j of subgroupIndex) {
              if (j < 0) {
                const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
              } else {
                const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
              }
            }
            groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
          } else {
            const subgroupIndex = range(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
            if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
            for (const j of subgroupIndex) {
              let chord;
              if (i < j) {
                chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
              } else {
                chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                if (i === j) chord.source = chord.target;
              }
              if (chord.source && chord.target && chord.source.value < chord.target.value) {
                const source = chord.source;
                chord.source = chord.target;
                chord.target = source;
              }
            }
            groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
          }
          x += dx;
        }
      }

      // Remove empty chords.
      chords = Object.values(chords);
      chords.groups = groups;
      return sortChords ? chords.sort(sortChords) : chords;
    }

    chord.padAngle = function(_) {
      return arguments.length ? (padAngle = max$2(0, _), chord) : padAngle;
    };

    chord.sortGroups = function(_) {
      return arguments.length ? (sortGroups = _, chord) : sortGroups;
    };

    chord.sortSubgroups = function(_) {
      return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
    };

    chord.sortChords = function(_) {
      return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
    };

    return chord;
  }

  const pi$2 = Math.PI,
      tau$2 = 2 * pi$2,
      epsilon$2 = 1e-6,
      tauEpsilon = tau$2 - epsilon$2;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path;
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon$2));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$2) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon$2) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau$2 + tau$2;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon$2) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  var slice$2 = Array.prototype.slice;

  function constant$5(x) {
    return function() {
      return x;
    };
  }

  function defaultSource(d) {
    return d.source;
  }

  function defaultTarget(d) {
    return d.target;
  }

  function defaultRadius(d) {
    return d.radius;
  }

  function defaultStartAngle(d) {
    return d.startAngle;
  }

  function defaultEndAngle(d) {
    return d.endAngle;
  }

  function defaultPadAngle() {
    return 0;
  }

  function defaultArrowheadRadius() {
    return 10;
  }

  function ribbon(headRadius) {
    var source = defaultSource,
        target = defaultTarget,
        sourceRadius = defaultRadius,
        targetRadius = defaultRadius,
        startAngle = defaultStartAngle,
        endAngle = defaultEndAngle,
        padAngle = defaultPadAngle,
        context = null;

    function ribbon() {
      var buffer,
          s = source.apply(this, arguments),
          t = target.apply(this, arguments),
          ap = padAngle.apply(this, arguments) / 2,
          argv = slice$2.call(arguments),
          sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
          sa0 = startAngle.apply(this, argv) - halfPi$1,
          sa1 = endAngle.apply(this, argv) - halfPi$1,
          tr = +targetRadius.apply(this, (argv[0] = t, argv)),
          ta0 = startAngle.apply(this, argv) - halfPi$1,
          ta1 = endAngle.apply(this, argv) - halfPi$1;

      if (!context) context = buffer = path();

      if (ap > epsilon$1) {
        if (abs$1(sa1 - sa0) > ap * 2 + epsilon$1) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
        else sa0 = sa1 = (sa0 + sa1) / 2;
        if (abs$1(ta1 - ta0) > ap * 2 + epsilon$1) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
        else ta0 = ta1 = (ta0 + ta1) / 2;
      }

      context.moveTo(sr * cos(sa0), sr * sin(sa0));
      context.arc(0, 0, sr, sa0, sa1);
      if (sa0 !== ta0 || sa1 !== ta1) {
        if (headRadius) {
          var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
          context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));
          context.lineTo(tr * cos(ta2), tr * sin(ta2));
          context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));
        } else {
          context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
          context.arc(0, 0, tr, ta0, ta1);
        }
      }
      context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));
      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    if (headRadius) ribbon.headRadius = function(_) {
      return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : headRadius;
    };

    ribbon.radius = function(_) {
      return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : sourceRadius;
    };

    ribbon.sourceRadius = function(_) {
      return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : sourceRadius;
    };

    ribbon.targetRadius = function(_) {
      return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : targetRadius;
    };

    ribbon.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : startAngle;
    };

    ribbon.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : endAngle;
    };

    ribbon.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : padAngle;
    };

    ribbon.source = function(_) {
      return arguments.length ? (source = _, ribbon) : source;
    };

    ribbon.target = function(_) {
      return arguments.length ? (target = _, ribbon) : target;
    };

    ribbon.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
    };

    return ribbon;
  }

  function ribbon$1() {
    return ribbon();
  }

  function ribbonArrow() {
    return ribbon(defaultArrowheadRadius);
  }

  var array$3 = Array.prototype;

  var slice$3 = array$3.slice;

  function ascending$2(a, b) {
    return a - b;
  }

  function area(ring) {
    var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
    while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
    return area;
  }

  var constant$6 = x => () => x;

  function contains(ring, hole) {
    var i = -1, n = hole.length, c;
    while (++i < n) if (c = ringContains(ring, hole[i])) return c;
    return 0;
  }

  function ringContains(ring, point) {
    var x = point[0], y = point[1], contains = -1;
    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
      var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
      if (segmentContains(pi, pj, point)) return 0;
      if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
    }
    return contains;
  }

  function segmentContains(a, b, c) {
    var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
  }

  function collinear(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
  }

  function within(p, q, r) {
    return p <= q && q <= r || r <= q && q <= p;
  }

  function noop$1() {}

  var cases = [
    [],
    [[[1.0, 1.5], [0.5, 1.0]]],
    [[[1.5, 1.0], [1.0, 1.5]]],
    [[[1.5, 1.0], [0.5, 1.0]]],
    [[[1.0, 0.5], [1.5, 1.0]]],
    [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
    [[[1.0, 0.5], [1.0, 1.5]]],
    [[[1.0, 0.5], [0.5, 1.0]]],
    [[[0.5, 1.0], [1.0, 0.5]]],
    [[[1.0, 1.5], [1.0, 0.5]]],
    [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
    [[[1.5, 1.0], [1.0, 0.5]]],
    [[[0.5, 1.0], [1.5, 1.0]]],
    [[[1.0, 1.5], [1.5, 1.0]]],
    [[[0.5, 1.0], [1.0, 1.5]]],
    []
  ];

  function contours() {
    var dx = 1,
        dy = 1,
        threshold = thresholdSturges,
        smooth = smoothLinear;

    function contours(values) {
      var tz = threshold(values);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) {
        var domain = extent(values), start = domain[0], stop = domain[1];
        tz = tickStep(start, stop, tz);
        tz = sequence(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
      } else {
        tz = tz.slice().sort(ascending$2);
      }

      return tz.map(function(value) {
        return contour(values, value);
      });
    }

    // Accumulate, smooth contour rings, assign holes to exterior rings.
    // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
    function contour(values, value) {
      var polygons = [],
          holes = [];

      isorings(values, value, function(ring) {
        smooth(ring, values, value);
        if (area(ring) > 0) polygons.push([ring]);
        else holes.push(ring);
      });

      holes.forEach(function(hole) {
        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
          if (contains((polygon = polygons[i])[0], hole) !== -1) {
            polygon.push(hole);
            return;
          }
        }
      });

      return {
        type: "MultiPolygon",
        value: value,
        coordinates: polygons
      };
    }

    // Marching squares with isolines stitched into rings.
    // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
    function isorings(values, value, callback) {
      var fragmentByStart = new Array,
          fragmentByEnd = new Array,
          x, y, t0, t1, t2, t3;

      // Special case for the first row (y = -1, t2 = t3 = 0).
      x = y = -1;
      t1 = values[0] >= value;
      cases[t1 << 1].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[x + 1] >= value;
        cases[t0 | t1 << 1].forEach(stitch);
      }
      cases[t1 << 0].forEach(stitch);

      // General case for the intermediate rows.
      while (++y < dy - 1) {
        x = -1;
        t1 = values[y * dx + dx] >= value;
        t2 = values[y * dx] >= value;
        cases[t1 << 1 | t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t1 | t2 << 3].forEach(stitch);
      }

      // Special case for the last row (y = dy - 1, t0 = t1 = 0).
      x = -1;
      t2 = values[y * dx] >= value;
      cases[t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t2 << 3].forEach(stitch);

      function stitch(line) {
        var start = [line[0][0] + x, line[0][1] + y],
            end = [line[1][0] + x, line[1][1] + y],
            startIndex = index(start),
            endIndex = index(end),
            f, g;
        if (f = fragmentByEnd[startIndex]) {
          if (g = fragmentByStart[endIndex]) {
            delete fragmentByEnd[f.end];
            delete fragmentByStart[g.start];
            if (f === g) {
              f.ring.push(end);
              callback(f.ring);
            } else {
              fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
            }
          } else {
            delete fragmentByEnd[f.end];
            f.ring.push(end);
            fragmentByEnd[f.end = endIndex] = f;
          }
        } else if (f = fragmentByStart[endIndex]) {
          if (g = fragmentByEnd[startIndex]) {
            delete fragmentByStart[f.start];
            delete fragmentByEnd[g.end];
            if (f === g) {
              f.ring.push(end);
              callback(f.ring);
            } else {
              fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
            }
          } else {
            delete fragmentByStart[f.start];
            f.ring.unshift(start);
            fragmentByStart[f.start = startIndex] = f;
          }
        } else {
          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
        }
      }
    }

    function index(point) {
      return point[0] * 2 + point[1] * (dx + 1) * 4;
    }

    function smoothLinear(ring, values, value) {
      ring.forEach(function(point) {
        var x = point[0],
            y = point[1],
            xt = x | 0,
            yt = y | 0,
            v0,
            v1 = values[yt * dx + xt];
        if (x > 0 && x < dx && xt === x) {
          v0 = values[yt * dx + xt - 1];
          point[0] = x + (value - v0) / (v1 - v0) - 0.5;
        }
        if (y > 0 && y < dy && yt === y) {
          v0 = values[(yt - 1) * dx + xt];
          point[1] = y + (value - v0) / (v1 - v0) - 0.5;
        }
      });
    }

    contours.contour = contour;

    contours.size = function(_) {
      if (!arguments.length) return [dx, dy];
      var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, contours;
    };

    contours.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$3.call(_)) : constant$6(_), contours) : threshold;
    };

    contours.smooth = function(_) {
      return arguments.length ? (smooth = _ ? smoothLinear : noop$1, contours) : smooth === smoothLinear;
    };

    return contours;
  }

  // TODO Optimize edge cases.
  // TODO Optimize index calculation.
  // TODO Optimize arguments.
  function blurX(source, target, r) {
    var n = source.width,
        m = source.height,
        w = (r << 1) + 1;
    for (var j = 0; j < m; ++j) {
      for (var i = 0, sr = 0; i < n + r; ++i) {
        if (i < n) {
          sr += source.data[i + j * n];
        }
        if (i >= r) {
          if (i >= w) {
            sr -= source.data[i - w + j * n];
          }
          target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
        }
      }
    }
  }

  // TODO Optimize edge cases.
  // TODO Optimize index calculation.
  // TODO Optimize arguments.
  function blurY(source, target, r) {
    var n = source.width,
        m = source.height,
        w = (r << 1) + 1;
    for (var i = 0; i < n; ++i) {
      for (var j = 0, sr = 0; j < m + r; ++j) {
        if (j < m) {
          sr += source.data[i + j * n];
        }
        if (j >= r) {
          if (j >= w) {
            sr -= source.data[i + (j - w) * n];
          }
          target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
        }
      }
    }
  }

  function defaultX(d) {
    return d[0];
  }

  function defaultY(d) {
    return d[1];
  }

  function defaultWeight() {
    return 1;
  }

  function density() {
    var x = defaultX,
        y = defaultY,
        weight = defaultWeight,
        dx = 960,
        dy = 500,
        r = 20, // blur radius
        k = 2, // log2(grid cell size)
        o = r * 3, // grid offset, to pad for blur
        n = (dx + o * 2) >> k, // grid width
        m = (dy + o * 2) >> k, // grid height
        threshold = constant$6(20);

    function density(data) {
      var values0 = new Float32Array(n * m),
          values1 = new Float32Array(n * m);

      data.forEach(function(d, i, data) {
        var xi = (+x(d, i, data) + o) >> k,
            yi = (+y(d, i, data) + o) >> k,
            wi = +weight(d, i, data);
        if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
          values0[xi + yi * n] += wi;
        }
      });

      // TODO Optimize.
      blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
      blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
      blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
      blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
      blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
      blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

      var tz = threshold(values0);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) {
        var stop = max(values0);
        tz = tickStep(0, stop, tz);
        tz = sequence(0, Math.floor(stop / tz) * tz, tz);
        tz.shift();
      }

      return contours()
          .thresholds(tz)
          .size([n, m])
        (values0)
          .map(transform);
    }

    function transform(geometry) {
      geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
      geometry.coordinates.forEach(transformPolygon);
      return geometry;
    }

    function transformPolygon(coordinates) {
      coordinates.forEach(transformRing);
    }

    function transformRing(coordinates) {
      coordinates.forEach(transformPoint);
    }

    // TODO Optimize.
    function transformPoint(coordinates) {
      coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
      coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
    }

    function resize() {
      o = r * 3;
      n = (dx + o * 2) >> k;
      m = (dy + o * 2) >> k;
      return density;
    }

    density.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), density) : x;
    };

    density.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), density) : y;
    };

    density.weight = function(_) {
      return arguments.length ? (weight = typeof _ === "function" ? _ : constant$6(+_), density) : weight;
    };

    density.size = function(_) {
      if (!arguments.length) return [dx, dy];
      var _0 = +_[0], _1 = +_[1];
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, resize();
    };

    density.cellSize = function(_) {
      if (!arguments.length) return 1 << k;
      if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
      return k = Math.floor(Math.log(_) / Math.LN2), resize();
    };

    density.thresholds = function(_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$3.call(_)) : constant$6(_), density) : threshold;
    };

    density.bandwidth = function(_) {
      if (!arguments.length) return Math.sqrt(r * (r + 1));
      if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
      return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
    };

    return density;
  }

  const EPSILON = Math.pow(2, -52);
  const EDGE_STACK = new Uint32Array(512);

  class Delaunator {

      static from(points, getX = defaultGetX, getY = defaultGetY) {
          const n = points.length;
          const coords = new Float64Array(n * 2);

          for (let i = 0; i < n; i++) {
              const p = points[i];
              coords[2 * i] = getX(p);
              coords[2 * i + 1] = getY(p);
          }

          return new Delaunator(coords);
      }

      constructor(coords) {
          const n = coords.length >> 1;
          if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

          this.coords = coords;

          // arrays that will store the triangulation graph
          const maxTriangles = Math.max(2 * n - 5, 0);
          this._triangles = new Uint32Array(maxTriangles * 3);
          this._halfedges = new Int32Array(maxTriangles * 3);

          // temporary arrays for tracking the edges of the advancing convex hull
          this._hashSize = Math.ceil(Math.sqrt(n));
          this._hullPrev = new Uint32Array(n); // edge to prev edge
          this._hullNext = new Uint32Array(n); // edge to next edge
          this._hullTri = new Uint32Array(n); // edge to adjacent triangle
          this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

          // temporary arrays for sorting points
          this._ids = new Uint32Array(n);
          this._dists = new Float64Array(n);

          this.update();
      }

      update() {
          const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
          const n = coords.length >> 1;

          // populate an array of point indices; calculate input data bbox
          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;

          for (let i = 0; i < n; i++) {
              const x = coords[2 * i];
              const y = coords[2 * i + 1];
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
              this._ids[i] = i;
          }
          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;

          let minDist = Infinity;
          let i0, i1, i2;

          // pick a seed point close to the center
          for (let i = 0; i < n; i++) {
              const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
              if (d < minDist) {
                  i0 = i;
                  minDist = d;
              }
          }
          const i0x = coords[2 * i0];
          const i0y = coords[2 * i0 + 1];

          minDist = Infinity;

          // find the point closest to the seed
          for (let i = 0; i < n; i++) {
              if (i === i0) continue;
              const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
              if (d < minDist && d > 0) {
                  i1 = i;
                  minDist = d;
              }
          }
          let i1x = coords[2 * i1];
          let i1y = coords[2 * i1 + 1];

          let minRadius = Infinity;

          // find the third point which forms the smallest circumcircle with the first two
          for (let i = 0; i < n; i++) {
              if (i === i0 || i === i1) continue;
              const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
              if (r < minRadius) {
                  i2 = i;
                  minRadius = r;
              }
          }
          let i2x = coords[2 * i2];
          let i2y = coords[2 * i2 + 1];

          if (minRadius === Infinity) {
              // order collinear points by dx (or dy if all x are identical)
              // and return the list as a hull
              for (let i = 0; i < n; i++) {
                  this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
              }
              quicksort(this._ids, this._dists, 0, n - 1);
              const hull = new Uint32Array(n);
              let j = 0;
              for (let i = 0, d0 = -Infinity; i < n; i++) {
                  const id = this._ids[i];
                  if (this._dists[id] > d0) {
                      hull[j++] = id;
                      d0 = this._dists[id];
                  }
              }
              this.hull = hull.subarray(0, j);
              this.triangles = new Uint32Array(0);
              this.halfedges = new Uint32Array(0);
              return;
          }

          // swap the order of the seed points for counter-clockwise orientation
          if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
              const i = i1;
              const x = i1x;
              const y = i1y;
              i1 = i2;
              i1x = i2x;
              i1y = i2y;
              i2 = i;
              i2x = x;
              i2y = y;
          }

          const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
          this._cx = center.x;
          this._cy = center.y;

          for (let i = 0; i < n; i++) {
              this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
          }

          // sort the points by distance from the seed triangle circumcenter
          quicksort(this._ids, this._dists, 0, n - 1);

          // set up the seed triangle as the starting hull
          this._hullStart = i0;
          let hullSize = 3;

          hullNext[i0] = hullPrev[i2] = i1;
          hullNext[i1] = hullPrev[i0] = i2;
          hullNext[i2] = hullPrev[i1] = i0;

          hullTri[i0] = 0;
          hullTri[i1] = 1;
          hullTri[i2] = 2;

          hullHash.fill(-1);
          hullHash[this._hashKey(i0x, i0y)] = i0;
          hullHash[this._hashKey(i1x, i1y)] = i1;
          hullHash[this._hashKey(i2x, i2y)] = i2;

          this.trianglesLen = 0;
          this._addTriangle(i0, i1, i2, -1, -1, -1);

          for (let k = 0, xp, yp; k < this._ids.length; k++) {
              const i = this._ids[k];
              const x = coords[2 * i];
              const y = coords[2 * i + 1];

              // skip near-duplicate points
              if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
              xp = x;
              yp = y;

              // skip seed triangle points
              if (i === i0 || i === i1 || i === i2) continue;

              // find a visible edge on the convex hull using edge hash
              let start = 0;
              for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                  start = hullHash[(key + j) % this._hashSize];
                  if (start !== -1 && start !== hullNext[start]) break;
              }

              start = hullPrev[start];
              let e = start, q;
              while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                  e = q;
                  if (e === start) {
                      e = -1;
                      break;
                  }
              }
              if (e === -1) continue; // likely a near-duplicate point; skip it

              // add the first triangle from the point
              let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

              // recursively flip triangles from the point until they satisfy the Delaunay condition
              hullTri[i] = this._legalize(t + 2);
              hullTri[e] = t; // keep track of boundary triangles on the hull
              hullSize++;

              // walk forward through the hull, adding more triangles and flipping recursively
              let n = hullNext[e];
              while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                  t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                  hullTri[i] = this._legalize(t + 2);
                  hullNext[n] = n; // mark as removed
                  hullSize--;
                  n = q;
              }

              // walk backward from the other side, adding more triangles and flipping
              if (e === start) {
                  while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                      t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                      this._legalize(t + 2);
                      hullTri[q] = t;
                      hullNext[e] = e; // mark as removed
                      hullSize--;
                      e = q;
                  }
              }

              // update the hull indices
              this._hullStart = hullPrev[i] = e;
              hullNext[e] = hullPrev[n] = i;
              hullNext[i] = n;

              // save the two new edges in the hash table
              hullHash[this._hashKey(x, y)] = i;
              hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
          }

          this.hull = new Uint32Array(hullSize);
          for (let i = 0, e = this._hullStart; i < hullSize; i++) {
              this.hull[i] = e;
              e = hullNext[e];
          }

          // trim typed triangle mesh arrays
          this.triangles = this._triangles.subarray(0, this.trianglesLen);
          this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }

      _hashKey(x, y) {
          return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
      }

      _legalize(a) {
          const {_triangles: triangles, _halfedges: halfedges, coords} = this;

          let i = 0;
          let ar = 0;

          // recursion eliminated with a fixed-size stack
          while (true) {
              const b = halfedges[a];

              /* if the pair of triangles doesn't satisfy the Delaunay condition
               * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
               * then do the same check/flip recursively for the new pair of triangles
               *
               *           pl                    pl
               *          /||\                  /  \
               *       al/ || \bl            al/    \a
               *        /  ||  \              /      \
               *       /  a||b  \    flip    /___ar___\
               *     p0\   ||   /p1   =>   p0\---bl---/p1
               *        \  ||  /              \      /
               *       ar\ || /br             b\    /br
               *          \||/                  \  /
               *           pr                    pr
               */
              const a0 = a - a % 3;
              ar = a0 + (a + 2) % 3;

              if (b === -1) { // convex hull edge
                  if (i === 0) break;
                  a = EDGE_STACK[--i];
                  continue;
              }

              const b0 = b - b % 3;
              const al = a0 + (a + 1) % 3;
              const bl = b0 + (b + 2) % 3;

              const p0 = triangles[ar];
              const pr = triangles[a];
              const pl = triangles[al];
              const p1 = triangles[bl];

              const illegal = inCircle(
                  coords[2 * p0], coords[2 * p0 + 1],
                  coords[2 * pr], coords[2 * pr + 1],
                  coords[2 * pl], coords[2 * pl + 1],
                  coords[2 * p1], coords[2 * p1 + 1]);

              if (illegal) {
                  triangles[a] = p1;
                  triangles[b] = p0;

                  const hbl = halfedges[bl];

                  // edge swapped on the other side of the hull (rare); fix the halfedge reference
                  if (hbl === -1) {
                      let e = this._hullStart;
                      do {
                          if (this._hullTri[e] === bl) {
                              this._hullTri[e] = a;
                              break;
                          }
                          e = this._hullPrev[e];
                      } while (e !== this._hullStart);
                  }
                  this._link(a, hbl);
                  this._link(b, halfedges[ar]);
                  this._link(ar, bl);

                  const br = b0 + (b + 1) % 3;

                  // don't worry about hitting the cap: it can only happen on extremely degenerate input
                  if (i < EDGE_STACK.length) {
                      EDGE_STACK[i++] = br;
                  }
              } else {
                  if (i === 0) break;
                  a = EDGE_STACK[--i];
              }
          }

          return ar;
      }

      _link(a, b) {
          this._halfedges[a] = b;
          if (b !== -1) this._halfedges[b] = a;
      }

      // add a new triangle given vertex indices and adjacent half-edge ids
      _addTriangle(i0, i1, i2, a, b, c) {
          const t = this.trianglesLen;

          this._triangles[t] = i0;
          this._triangles[t + 1] = i1;
          this._triangles[t + 2] = i2;

          this._link(t, a);
          this._link(t + 1, b);
          this._link(t + 2, c);

          this.trianglesLen += 3;

          return t;
      }
  }

  // monotonically increases with real angle, but doesn't need expensive trigonometry
  function pseudoAngle(dx, dy) {
      const p = dx / (Math.abs(dx) + Math.abs(dy));
      return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
  }

  function dist(ax, ay, bx, by) {
      const dx = ax - bx;
      const dy = ay - by;
      return dx * dx + dy * dy;
  }

  // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
  function orientIfSure(px, py, rx, ry, qx, qy) {
      const l = (ry - py) * (qx - px);
      const r = (rx - px) * (qy - py);
      return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
  }

  // a more robust orientation test that's stable in a given triangle (to fix robustness issues)
  function orient(rx, ry, qx, qy, px, py) {
      const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
      orientIfSure(rx, ry, qx, qy, px, py) ||
      orientIfSure(qx, qy, px, py, rx, ry);
      return sign < 0;
  }

  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
      const dx = ax - px;
      const dy = ay - py;
      const ex = bx - px;
      const ey = by - py;
      const fx = cx - px;
      const fy = cy - py;

      const ap = dx * dx + dy * dy;
      const bp = ex * ex + ey * ey;
      const cp = fx * fx + fy * fy;

      return dx * (ey * cp - bp * fy) -
             dy * (ex * cp - bp * fx) +
             ap * (ex * fy - ey * fx) < 0;
  }

  function circumradius(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;

      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);

      const x = (ey * bl - dy * cl) * d;
      const y = (dx * cl - ex * bl) * d;

      return x * x + y * y;
  }

  function circumcenter(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;

      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);

      const x = ax + (ey * bl - dy * cl) * d;
      const y = ay + (dx * cl - ex * bl) * d;

      return {x, y};
  }

  function quicksort(ids, dists, left, right) {
      if (right - left <= 20) {
          for (let i = left + 1; i <= right; i++) {
              const temp = ids[i];
              const tempDist = dists[temp];
              let j = i - 1;
              while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
              ids[j + 1] = temp;
          }
      } else {
          const median = (left + right) >> 1;
          let i = left + 1;
          let j = right;
          swap$1(ids, median, i);
          if (dists[ids[left]] > dists[ids[right]]) swap$1(ids, left, right);
          if (dists[ids[i]] > dists[ids[right]]) swap$1(ids, i, right);
          if (dists[ids[left]] > dists[ids[i]]) swap$1(ids, left, i);

          const temp = ids[i];
          const tempDist = dists[temp];
          while (true) {
              do i++; while (dists[ids[i]] < tempDist);
              do j--; while (dists[ids[j]] > tempDist);
              if (j < i) break;
              swap$1(ids, i, j);
          }
          ids[left + 1] = ids[j];
          ids[j] = temp;

          if (right - i + 1 >= j - left) {
              quicksort(ids, dists, i, right);
              quicksort(ids, dists, left, j - 1);
          } else {
              quicksort(ids, dists, left, j - 1);
              quicksort(ids, dists, i, right);
          }
      }
  }

  function swap$1(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultGetX(p) {
      return p[0];
  }
  function defaultGetY(p) {
      return p[1];
  }

  const epsilon$3 = 1e-6;

  class Path$1 {
    constructor() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }
    moveTo(x, y) {
      this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    }
    lineTo(x, y) {
      this._ += `L${this._x1 = +x},${this._y1 = +y}`;
    }
    arc(x, y, r) {
      x = +x, y = +y, r = +r;
      const x0 = x + r;
      const y0 = y;
      if (r < 0) throw new Error("negative radius");
      if (this._x1 === null) this._ += `M${x0},${y0}`;
      else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) this._ += "L" + x0 + "," + y0;
      if (!r) return;
      this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
    }
    rect(x, y, w, h) {
      this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
    }
    value() {
      return this._ || null;
    }
  }

  class Polygon {
    constructor() {
      this._ = [];
    }
    moveTo(x, y) {
      this._.push([x, y]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(x, y) {
      this._.push([x, y]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  }

  class Voronoi {
    constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
      if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
      this.delaunay = delaunay;
      this._circumcenters = new Float64Array(delaunay.points.length * 2);
      this.vectors = new Float64Array(delaunay.points.length * 2);
      this.xmax = xmax, this.xmin = xmin;
      this.ymax = ymax, this.ymin = ymin;
      this._init();
    }
    update() {
      this.delaunay.update();
      this._init();
      return this;
    }
    _init() {
      const {delaunay: {points, hull, triangles}, vectors} = this;

      // Compute circumcenters.
      const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
      for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
        const t1 = triangles[i] * 2;
        const t2 = triangles[i + 1] * 2;
        const t3 = triangles[i + 2] * 2;
        const x1 = points[t1];
        const y1 = points[t1 + 1];
        const x2 = points[t2];
        const y2 = points[t2 + 1];
        const x3 = points[t3];
        const y3 = points[t3 + 1];

        const dx = x2 - x1;
        const dy = y2 - y1;
        const ex = x3 - x1;
        const ey = y3 - y1;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const ab = (dx * ey - dy * ex) * 2;

        if (!ab) {
          // degenerate case (collinear diagram)
          x = (x1 + x3) / 2 - 1e8 * ey;
          y = (y1 + y3) / 2 + 1e8 * ex;
        }
        else if (Math.abs(ab) < 1e-8) {
          // almost equal points (degenerate triangle)
          x = (x1 + x3) / 2;
          y = (y1 + y3) / 2;
        } else {
          const d = 1 / ab;
          x = x1 + (ey * bl - dy * cl) * d;
          y = y1 + (dx * cl - ex * bl) * d;
        }
        circumcenters[j] = x;
        circumcenters[j + 1] = y;
      }

      // Compute exterior cell rays.
      let h = hull[hull.length - 1];
      let p0, p1 = h * 4;
      let x0, x1 = points[2 * h];
      let y0, y1 = points[2 * h + 1];
      vectors.fill(0);
      for (let i = 0; i < hull.length; ++i) {
        h = hull[i];
        p0 = p1, x0 = x1, y0 = y1;
        p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
        vectors[p0 + 2] = vectors[p1] = y0 - y1;
        vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
      }
    }
    render(context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
      if (hull.length <= 1) return null;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j = halfedges[i];
        if (j < i) continue;
        const ti = Math.floor(i / 3) * 2;
        const tj = Math.floor(j / 3) * 2;
        const xi = circumcenters[ti];
        const yi = circumcenters[ti + 1];
        const xj = circumcenters[tj];
        const yj = circumcenters[tj + 1];
        this._renderSegment(xi, yi, xj, yj, context);
      }
      let h0, h1 = hull[hull.length - 1];
      for (let i = 0; i < hull.length; ++i) {
        h0 = h1, h1 = hull[i];
        const t = Math.floor(inedges[h1] / 3) * 2;
        const x = circumcenters[t];
        const y = circumcenters[t + 1];
        const v = h0 * 4;
        const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
        if (p) this._renderSegment(x, y, p[0], p[1], context);
      }
      return buffer && buffer.value();
    }
    renderBounds(context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
      return buffer && buffer.value();
    }
    renderCell(i, context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const points = this._clip(i);
      if (points === null || !points.length) return;
      context.moveTo(points[0], points[1]);
      let n = points.length;
      while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
      for (let i = 2; i < n; i += 2) {
        if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
          context.lineTo(points[i], points[i + 1]);
      }
      context.closePath();
      return buffer && buffer.value();
    }
    *cellPolygons() {
      const {delaunay: {points}} = this;
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const cell = this.cellPolygon(i);
        if (cell) cell.index = i, yield cell;
      }
    }
    cellPolygon(i) {
      const polygon = new Polygon;
      this.renderCell(i, polygon);
      return polygon.value();
    }
    _renderSegment(x0, y0, x1, y1, context) {
      let S;
      const c0 = this._regioncode(x0, y0);
      const c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
      } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
        context.moveTo(S[0], S[1]);
        context.lineTo(S[2], S[3]);
      }
    }
    contains(i, x, y) {
      if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
      return this.delaunay._step(i, x, y) === i;
    }
    *neighbors(i) {
      const ci = this._clip(i);
      if (ci) for (const j of this.delaunay.neighbors(i)) {
        const cj = this._clip(j);
        // find the common edge
        if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
          for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
            if (ci[ai] == cj[aj]
            && ci[ai + 1] == cj[aj + 1]
            && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
            && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
            ) {
              yield j;
              break loop;
            }
          }
        }
      }
    }
    _cell(i) {
      const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
      const e0 = inedges[i];
      if (e0 === -1) return null; // coincident point
      const points = [];
      let e = e0;
      do {
        const t = Math.floor(e / 3);
        points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) break; // bad triangulation
        e = halfedges[e];
      } while (e !== e0 && e !== -1);
      return points;
    }
    _clip(i) {
      // degenerate case (1 valid point: return the box)
      if (i === 0 && this.delaunay.hull.length === 1) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      const points = this._cell(i);
      if (points === null) return null;
      const {vectors: V} = this;
      const v = i * 4;
      return V[v] || V[v + 1]
          ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
          : this._clipFinite(i, points);
    }
    _clipFinite(i, points) {
      const n = points.length;
      let P = null;
      let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
      let c0, c1 = this._regioncode(x1, y1);
      let e0, e1;
      for (let j = 0; j < n; j += 2) {
        x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
        c0 = c1, c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          e0 = e1, e1 = 0;
          if (P) P.push(x1, y1);
          else P = [x1, y1];
        } else {
          let S, sx0, sy0, sx1, sy1;
          if (c0 === 0) {
            if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
            [sx0, sy0, sx1, sy1] = S;
          } else {
            if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
            [sx1, sy1, sx0, sy0] = S;
            e0 = e1, e1 = this._edgecode(sx0, sy0);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx0, sy0);
            else P = [sx0, sy0];
          }
          e0 = e1, e1 = this._edgecode(sx1, sy1);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx1, sy1);
          else P = [sx1, sy1];
        }
      }
      if (P) {
        e0 = e1, e1 = this._edgecode(P[0], P[1]);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      return P;
    }
    _clipSegment(x0, y0, x1, y1, c0, c1) {
      while (true) {
        if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
        if (c0 & c1) return null;
        let x, y, c = c0 || c1;
        if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
        else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
        else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
        else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
        if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
        else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
      }
    }
    _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
      let P = Array.from(points), p;
      if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
      if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
      if (P = this._clipFinite(i, P)) {
        for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
          c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
          if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
        }
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
      }
      return P;
    }
    _edge(i, e0, e1, P, j) {
      while (e0 !== e1) {
        let x, y;
        switch (e0) {
          case 0b0101: e0 = 0b0100; continue; // top-left
          case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
          case 0b0110: e0 = 0b0010; continue; // top-right
          case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
          case 0b1010: e0 = 0b1000; continue; // bottom-right
          case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
          case 0b1001: e0 = 0b0001; continue; // bottom-left
          case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
        }
        if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
          P.splice(j, 0, x, y), j += 2;
        }
      }
      if (P.length > 4) {
        for (let i = 0; i < P.length; i+= 2) {
          const j = (i + 2) % P.length, k = (i + 4) % P.length;
          if (P[i] === P[j] && P[j] === P[k]
          || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
            P.splice(j, 2), i -= 2;
        }
      }
      return j;
    }
    _project(x0, y0, vx, vy) {
      let t = Infinity, c, x, y;
      if (vy < 0) { // top
        if (y0 <= this.ymin) return null;
        if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
      } else if (vy > 0) { // bottom
        if (y0 >= this.ymax) return null;
        if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
      }
      if (vx > 0) { // right
        if (x0 >= this.xmax) return null;
        if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
      } else if (vx < 0) { // left
        if (x0 <= this.xmin) return null;
        if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
      }
      return [x, y];
    }
    _edgecode(x, y) {
      return (x === this.xmin ? 0b0001
          : x === this.xmax ? 0b0010 : 0b0000)
          | (y === this.ymin ? 0b0100
          : y === this.ymax ? 0b1000 : 0b0000);
    }
    _regioncode(x, y) {
      return (x < this.xmin ? 0b0001
          : x > this.xmax ? 0b0010 : 0b0000)
          | (y < this.ymin ? 0b0100
          : y > this.ymax ? 0b1000 : 0b0000);
    }
  }

  const tau$3 = 2 * Math.PI, pow = Math.pow;

  function pointX(p) {
    return p[0];
  }

  function pointY(p) {
    return p[1];
  }

  // A triangulation is collinear if all its triangles have a non-null area
  function collinear$1(d) {
    const {triangles, coords} = d;
    for (let i = 0; i < triangles.length; i += 3) {
      const a = 2 * triangles[i],
            b = 2 * triangles[i + 1],
            c = 2 * triangles[i + 2],
            cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                  - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
      if (cross > 1e-10) return false;
    }
    return true;
  }

  function jitter(x, y, r) {
    return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
  }

  class Delaunay {
    static from(points, fx = pointX, fy = pointY, that) {
      return new Delaunay("length" in points
          ? flatArray(points, fx, fy, that)
          : Float64Array.from(flatIterable(points, fx, fy, that)));
    }
    constructor(points) {
      this._delaunator = new Delaunator(points);
      this.inedges = new Int32Array(points.length / 2);
      this._hullIndex = new Int32Array(points.length / 2);
      this.points = this._delaunator.coords;
      this._init();
    }
    update() {
      this._delaunator.update();
      this._init();
      return this;
    }
    _init() {
      const d = this._delaunator, points = this.points;

      // check for collinear
      if (d.hull && d.hull.length > 2 && collinear$1(d)) {
        this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
          .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
        const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
          bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
          r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const p = jitter(points[2 * i], points[2 * i + 1], r);
          points[2 * i] = p[0];
          points[2 * i + 1] = p[1];
        }
        this._delaunator = new Delaunator(points);
      } else {
        delete this.collinear;
      }

      const halfedges = this.halfedges = this._delaunator.halfedges;
      const hull = this.hull = this._delaunator.hull;
      const triangles = this.triangles = this._delaunator.triangles;
      const inedges = this.inedges.fill(-1);
      const hullIndex = this._hullIndex.fill(-1);

      // Compute an index from each point to an (arbitrary) incoming halfedge
      // Used to give the first neighbor of each point; for this reason,
      // on the hull we give priority to exterior halfedges
      for (let e = 0, n = halfedges.length; e < n; ++e) {
        const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
        if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
      }
      for (let i = 0, n = hull.length; i < n; ++i) {
        hullIndex[hull[i]] = i;
      }

      // degenerate case: 1 or 2 (distinct) points
      if (hull.length <= 2 && hull.length > 0) {
        this.triangles = new Int32Array(3).fill(-1);
        this.halfedges = new Int32Array(3).fill(-1);
        this.triangles[0] = hull[0];
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
        inedges[hull[0]] = 1;
        if (hull.length === 2) inedges[hull[1]] = 0;
      }
    }
    voronoi(bounds) {
      return new Voronoi(this, bounds);
    }
    *neighbors(i) {
      const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

      // degenerate case with several collinear points
      if (collinear) {
        const l = collinear.indexOf(i);
        if (l > 0) yield collinear[l - 1];
        if (l < collinear.length - 1) yield collinear[l + 1];
        return;
      }

      const e0 = inedges[i];
      if (e0 === -1) return; // coincident point
      let e = e0, p0 = -1;
      do {
        yield p0 = triangles[e];
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) return; // bad triangulation
        e = halfedges[e];
        if (e === -1) {
          const p = hull[(_hullIndex[i] + 1) % hull.length];
          if (p !== p0) yield p;
          return;
        }
      } while (e !== e0);
    }
    find(x, y, i = 0) {
      if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
      const i0 = i;
      let c;
      while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
      return c;
    }
    _step(i, x, y) {
      const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
      if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
      let c = i;
      let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
      const e0 = inedges[i];
      let e = e0;
      do {
        let t = triangles[e];
        const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
        if (dt < dc) dc = dt, c = t;
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i) break; // bad triangulation
        e = halfedges[e];
        if (e === -1) {
          e = hull[(_hullIndex[i] + 1) % hull.length];
          if (e !== t) {
            if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
          }
          break;
        }
      } while (e !== e0);
      return c;
    }
    render(context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const {points, halfedges, triangles} = this;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j = halfedges[i];
        if (j < i) continue;
        const ti = triangles[i] * 2;
        const tj = triangles[j] * 2;
        context.moveTo(points[ti], points[ti + 1]);
        context.lineTo(points[tj], points[tj + 1]);
      }
      this.renderHull(context);
      return buffer && buffer.value();
    }
    renderPoints(context, r = 2) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const {points} = this;
      for (let i = 0, n = points.length; i < n; i += 2) {
        const x = points[i], y = points[i + 1];
        context.moveTo(x + r, y);
        context.arc(x, y, r, 0, tau$3);
      }
      return buffer && buffer.value();
    }
    renderHull(context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const {hull, points} = this;
      const h = hull[0] * 2, n = hull.length;
      context.moveTo(points[h], points[h + 1]);
      for (let i = 1; i < n; ++i) {
        const h = 2 * hull[i];
        context.lineTo(points[h], points[h + 1]);
      }
      context.closePath();
      return buffer && buffer.value();
    }
    hullPolygon() {
      const polygon = new Polygon;
      this.renderHull(polygon);
      return polygon.value();
    }
    renderTriangle(i, context) {
      const buffer = context == null ? context = new Path$1 : undefined;
      const {points, triangles} = this;
      const t0 = triangles[i *= 3] * 2;
      const t1 = triangles[i + 1] * 2;
      const t2 = triangles[i + 2] * 2;
      context.moveTo(points[t0], points[t0 + 1]);
      context.lineTo(points[t1], points[t1 + 1]);
      context.lineTo(points[t2], points[t2 + 1]);
      context.closePath();
      return buffer && buffer.value();
    }
    *trianglePolygons() {
      const {triangles} = this;
      for (let i = 0, n = triangles.length / 3; i < n; ++i) {
        yield this.trianglePolygon(i);
      }
    }
    trianglePolygon(i) {
      const polygon = new Polygon;
      this.renderTriangle(i, polygon);
      return polygon.value();
    }
  }

  function flatArray(points, fx, fy, that) {
    const n = points.length;
    const array = new Float64Array(n * 2);
    for (let i = 0; i < n; ++i) {
      const p = points[i];
      array[i * 2] = fx.call(that, p, i, points);
      array[i * 2 + 1] = fy.call(that, p, i, points);
    }
    return array;
  }

  function* flatIterable(points, fx, fy, that) {
    let i = 0;
    for (const p of points) {
      yield fx.call(that, p, i, points);
      yield fy.call(that, p, i, points);
      ++i;
    }
  }

  var EOL = {},
      EOF = {},
      QUOTE = 34,
      NEWLINE = 10,
      RETURN = 13;

  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + "] || \"\"";
    }).join(",") + "}");
  }

  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
      return f(object(row), i, columns);
    };
  }

  // Compute unique columns in order of discovery.
  function inferColumns(rows) {
    var columnSet = Object.create(null),
        columns = [];

    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });

    return columns;
  }

  function pad(value, width) {
    var s = value + "", length = s.length;
    return length < width ? new Array(width - length + 1).join(0) + s : s;
  }

  function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6)
      : year > 9999 ? "+" + pad(year, 6)
      : pad(year, 4);
  }

  function formatDate(date) {
    var hours = date.getUTCHours(),
        minutes = date.getUTCMinutes(),
        seconds = date.getUTCSeconds(),
        milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date"
        : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
        + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
        : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
        : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
        : "");
  }

  function dsvFormat(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
        DELIMITER = delimiter.charCodeAt(0);

    function parse(text, f) {
      var convert, columns, rows = parseRows(text, function(row, i) {
        if (convert) return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }

    function parseRows(text, f) {
      var rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // current line number
          t, // current token
          eof = N <= 0, // current token followed by EOF?
          eol = false; // current token followed by EOL?

      // Strip the trailing newline.
      if (text.charCodeAt(N - 1) === NEWLINE) --N;
      if (text.charCodeAt(N - 1) === RETURN) --N;

      function token() {
        if (eof) return EOF;
        if (eol) return eol = false, EOL;

        // Unescape quotes.
        var i, j = I, c;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
          if ((i = I) >= N) eof = true;
          else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
          return text.slice(j + 1, i - 1).replace(/""/g, "\"");
        }

        // Find next delimiter or newline.
        while (I < N) {
          if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
          else if (c !== DELIMITER) continue;
          return text.slice(j, i);
        }

        // Return last token before EOF.
        return eof = true, text.slice(j, N);
      }

      while ((t = token()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF) row.push(t), t = token();
        if (f && (row = f(row, n++)) == null) continue;
        rows.push(row);
      }

      return rows;
    }

    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      });
    }

    function format(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }

    function formatBody(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(value) {
      return value == null ? ""
          : value instanceof Date ? formatDate(value)
          : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
          : value;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatBody: formatBody,
      formatRows: formatRows,
      formatRow: formatRow,
      formatValue: formatValue
    };
  }

  var csv = dsvFormat(",");

  var csvParse = csv.parse;
  var csvParseRows = csv.parseRows;
  var csvFormat = csv.format;
  var csvFormatBody = csv.formatBody;
  var csvFormatRows = csv.formatRows;
  var csvFormatRow = csv.formatRow;
  var csvFormatValue = csv.formatValue;

  var tsv = dsvFormat("\t");

  var tsvParse = tsv.parse;
  var tsvParseRows = tsv.parseRows;
  var tsvFormat = tsv.format;
  var tsvFormatBody = tsv.formatBody;
  var tsvFormatRows = tsv.formatRows;
  var tsvFormatRow = tsv.formatRow;
  var tsvFormatValue = tsv.formatValue;

  function autoType(object) {
    for (var key in object) {
      var value = object[key].trim(), number, m;
      if (!value) value = null;
      else if (value === "true") value = true;
      else if (value === "false") value = false;
      else if (value === "NaN") value = NaN;
      else if (!isNaN(number = +value)) value = number;
      else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
        value = new Date(value);
      }
      else continue;
      object[key] = value;
    }
    return object;
  }

  // https://github.com/d3/d3-dsv/issues/45
  const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

  function responseBlob(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.blob();
  }

  function blob(input, init) {
    return fetch(input, init).then(responseBlob);
  }

  function responseArrayBuffer(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.arrayBuffer();
  }

  function buffer(input, init) {
    return fetch(input, init).then(responseArrayBuffer);
  }

  function responseText(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.text();
  }

  function text(input, init) {
    return fetch(input, init).then(responseText);
  }

  function dsvParse(parse) {
    return function(input, init, row) {
      if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
      return text(input, init).then(function(response) {
        return parse(response, row);
      });
    };
  }

  function dsv(delimiter, input, init, row) {
    if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
    var format = dsvFormat(delimiter);
    return text(input, init).then(function(response) {
      return format.parse(response, row);
    });
  }

  var csv$1 = dsvParse(csvParse);
  var tsv$1 = dsvParse(tsvParse);

  function image(input, init) {
    return new Promise(function(resolve, reject) {
      var image = new Image;
      for (var key in init) image[key] = init[key];
      image.onerror = reject;
      image.onload = function() { resolve(image); };
      image.src = input;
    });
  }

  function responseJson(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205) return;
    return response.json();
  }

  function json(input, init) {
    return fetch(input, init).then(responseJson);
  }

  function parser(type) {
    return (input, init) => text(input, init)
      .then(text => (new DOMParser).parseFromString(text, type));
  }

  var xml = parser("application/xml");

  var html = parser("text/html");

  var svg = parser("image/svg+xml");

  function center$1(x, y) {
    var nodes, strength = 1;

    if (x == null) x = 0;
    if (y == null) y = 0;

    function force() {
      var i,
          n = nodes.length,
          node,
          sx = 0,
          sy = 0;

      for (i = 0; i < n; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }

      for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }

    force.initialize = function(_) {
      nodes = _;
    };

    force.x = function(_) {
      return arguments.length ? (x = +_, force) : x;
    };

    force.y = function(_) {
      return arguments.length ? (y = +_, force) : y;
    };

    force.strength = function(_) {
      return arguments.length ? (strength = +_, force) : strength;
    };

    return force;
  }

  function tree_add(d) {
    const x = +this._x.call(null, d),
        y = +this._y.call(null, d);
    return add(this.cover(x, y), x, y, d);
  }

  function add(tree, x, y, d) {
    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

    var parent,
        node = tree._root,
        leaf = {data: d},
        x0 = tree._x0,
        y0 = tree._y0,
        x1 = tree._x1,
        y1 = tree._y1,
        xm,
        ym,
        xp,
        yp,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return tree._root = leaf, tree;

    // Find the existing leaf for the new point, or add it.
    while (node.length) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
    }

    // Is the new point is exactly coincident with the existing point?
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

    // Otherwise, split the leaf node until the old and new point are separated.
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
    return parent[j] = node, parent[i] = leaf, tree;
  }

  function addAll(data) {
    var d, i, n = data.length,
        x,
        y,
        xz = new Array(n),
        yz = new Array(n),
        x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    // Compute the points and their extent.
    for (i = 0; i < n; ++i) {
      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
      xz[i] = x;
      yz[i] = y;
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    // If there were no (valid) points, abort.
    if (x0 > x1 || y0 > y1) return this;

    // Expand the tree to cover the new points.
    this.cover(x0, y0).cover(x1, y1);

    // Add the new points.
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data[i]);
    }

    return this;
  }

  function tree_cover(x, y) {
    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

    var x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1;

    // If the quadtree has no extent, initialize them.
    // Integer extent are necessary so that if we later double the extent,
    // the existing quadrant boundaries don’t change due to floating point error!
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x)) + 1;
      y1 = (y0 = Math.floor(y)) + 1;
    }

    // Otherwise, double repeatedly to cover.
    else {
      var z = x1 - x0 || 1,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | (x < x0);
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0: x1 = x0 + z, y1 = y0 + z; break;
          case 1: x0 = x1 - z, y1 = y0 + z; break;
          case 2: x1 = x0 + z, y0 = y1 - z; break;
          case 3: x0 = x1 - z, y0 = y1 - z; break;
        }
      }

      if (this._root && this._root.length) this._root = node;
    }

    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  function tree_data() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) do data.push(node.data); while (node = node.next)
    });
    return data;
  }

  function tree_extent(_) {
    return arguments.length
        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  function Quad(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  function tree_find(x, y, radius) {
    var data,
        x0 = this._x0,
        y0 = this._y0,
        x1,
        y1,
        x2,
        y2,
        x3 = this._x1,
        y3 = this._y1,
        quads = [],
        node = this._root,
        q,
        i;

    if (node) quads.push(new Quad(node, x0, y0, x3, y3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x - radius, y0 = y - radius;
      x3 = x + radius, y3 = y + radius;
      radius *= radius;
    }

    while (q = quads.pop()) {

      // Stop searching if this quadrant can’t contain a closer node.
      if (!(node = q.node)
          || (x1 = q.x0) > x3
          || (y1 = q.y0) > y3
          || (x2 = q.x1) < x0
          || (y2 = q.y1) < y0) continue;

      // Bisect the current quadrant.
      if (node.length) {
        var xm = (x1 + x2) / 2,
            ym = (y1 + y2) / 2;

        quads.push(
          new Quad(node[3], xm, ym, x2, y2),
          new Quad(node[2], x1, ym, xm, y2),
          new Quad(node[1], xm, y1, x2, ym),
          new Quad(node[0], x1, y1, xm, ym)
        );

        // Visit the closest quadrant first.
        if (i = (y >= ym) << 1 | (x >= xm)) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      }

      // Visit this point. (Visiting coincident points isn’t necessary!)
      else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
    }

    return data;
  }

  function tree_remove(d) {
    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

    var parent,
        node = this._root,
        retainer,
        previous,
        next,
        x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1,
        x,
        y,
        xm,
        ym,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return this;

    // Find the leaf node for the point.
    // While descending, also retain the deepest parent with a non-removed sibling.
    if (node.length) while (true) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
    }

    // Find the point to remove.
    while (node.data !== d) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;

    // If there are multiple coincident points, remove just the point.
    if (previous) return (next ? previous.next = next : delete previous.next), this;

    // If this is the root point, remove it.
    if (!parent) return this._root = next, this;

    // Remove this leaf.
    next ? parent[i] = next : delete parent[i];

    // If the parent now contains exactly one leaf, collapse superfluous parents.
    if ((node = parent[0] || parent[1] || parent[2] || parent[3])
        && node === (parent[3] || parent[2] || parent[1] || parent[0])
        && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }

    return this;
  }

  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
    return this;
  }

  function tree_root() {
    return this._root;
  }

  function tree_size() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) do ++size; while (node = node.next)
    });
    return size;
  }

  function tree_visit(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      }
    }
    return this;
  }

  function tree_visitAfter(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  function defaultX$1(d) {
    return d[0];
  }

  function tree_x(_) {
    return arguments.length ? (this._x = _, this) : this._x;
  }

  function defaultY$1(d) {
    return d[1];
  }

  function tree_y(_) {
    return arguments.length ? (this._y = _, this) : this._y;
  }

  function quadtree(nodes, x, y) {
    var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }

  function Quadtree(x, y, x0, y0, x1, y1) {
    this._x = x;
    this._y = y;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = undefined;
  }

  function leaf_copy(leaf) {
    var copy = {data: leaf.data}, next = copy;
    while (leaf = leaf.next) next = next.next = {data: leaf.data};
    return copy;
  }

  var treeProto = quadtree.prototype = Quadtree.prototype;

  treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
        node = this._root,
        nodes,
        child;

    if (!node) return copy;

    if (!node.length) return copy._root = leaf_copy(node), copy;

    nodes = [{source: node, target: copy._root = new Array(4)}];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
          else node.target[i] = leaf_copy(child);
        }
      }
    }

    return copy;
  };

  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;

  function constant$7(x) {
    return function() {
      return x;
    };
  }

  function jiggle(random) {
    return (random() - 0.5) * 1e-6;
  }

  function x(d) {
    return d.x + d.vx;
  }

  function y(d) {
    return d.y + d.vy;
  }

  function collide(radius) {
    var nodes,
        radii,
        random,
        strength = 1,
        iterations = 1;

    if (typeof radius !== "function") radius = constant$7(radius == null ? 1 : +radius);

    function force() {
      var i, n = nodes.length,
          tree,
          node,
          xi,
          yi,
          ri,
          ri2;

      for (var k = 0; k < iterations; ++k) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply);
        }
      }

      function apply(quad, x0, y0, x1, y1) {
        var data = quad.data, rj = quad.r, r = ri + rj;
        if (data) {
          if (data.index > node.index) {
            var x = xi - data.x - data.vx,
                y = yi - data.y - data.vy,
                l = x * x + y * y;
            if (l < r * r) {
              if (x === 0) x = jiggle(random), l += x * x;
              if (y === 0) y = jiggle(random), l += y * y;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y *= l) * r;
              data.vx -= x * (r = 1 - r);
              data.vy -= y * r;
            }
          }
          return;
        }
        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
      }
    }

    function prepare(quad) {
      if (quad.data) return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node;
      radii = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }

    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };

    force.iterations = function(_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };

    force.strength = function(_) {
      return arguments.length ? (strength = +_, force) : strength;
    };

    force.radius = function(_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : radius;
    };

    return force;
  }

  function index$1(d) {
    return d.index;
  }

  function find$1(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }

  function link(links) {
    var id = index$1,
        strength = defaultStrength,
        strengths,
        distance = constant$7(30),
        distances,
        nodes,
        count,
        bias,
        random,
        iterations = 1;

    if (links == null) links = [];

    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }

    function force(alpha) {
      for (var k = 0, n = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
          link = links[i], source = link.source, target = link.target;
          x = target.x + target.vx - source.x - source.vx || jiggle(random);
          y = target.y + target.vy - source.y - source.vy || jiggle(random);
          l = Math.sqrt(x * x + y * y);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x *= l, y *= l;
          target.vx -= x * (b = bias[i]);
          target.vy -= y * b;
          source.vx += x * (b = 1 - b);
          source.vy += y * b;
        }
      }
    }

    function initialize() {
      if (!nodes) return;

      var i,
          n = nodes.length,
          m = links.length,
          nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
          link;

      for (i = 0, count = new Array(n); i < m; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object") link.source = find$1(nodeById, link.source);
        if (typeof link.target !== "object") link.target = find$1(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }

      for (i = 0, bias = new Array(m); i < m; ++i) {
        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }

      strengths = new Array(m), initializeStrength();
      distances = new Array(m), initializeDistance();
    }

    function initializeStrength() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }

    function initializeDistance() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }

    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };

    force.links = function(_) {
      return arguments.length ? (links = _, initialize(), force) : links;
    };

    force.id = function(_) {
      return arguments.length ? (id = _, force) : id;
    };

    force.iterations = function(_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initializeStrength(), force) : strength;
    };

    force.distance = function(_) {
      return arguments.length ? (distance = typeof _ === "function" ? _ : constant$7(+_), initializeDistance(), force) : distance;
    };

    return force;
  }

  // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
  const a = 1664525;
  const c = 1013904223;
  const m = 4294967296; // 2^32

  function lcg() {
    let s = 1;
    return () => (s = (a * s + c) % m) / m;
  }

  function x$1(d) {
    return d.x;
  }

  function y$1(d) {
    return d.y;
  }

  var initialRadius = 10,
      initialAngle = Math.PI * (3 - Math.sqrt(5));

  function simulation(nodes) {
    var simulation,
        alpha = 1,
        alphaMin = 0.001,
        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
        alphaTarget = 0,
        velocityDecay = 0.6,
        forces = new Map(),
        stepper = timer(step),
        event = dispatch("tick", "end"),
        random = lcg();

    if (nodes == null) nodes = [];

    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }

    function tick(iterations) {
      var i, n = nodes.length, node;

      if (iterations === undefined) iterations = 1;

      for (var k = 0; k < iterations; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;

        forces.forEach(function(force) {
          force(alpha);
        });

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }

      return simulation;
    }

    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
          node.x = radius * Math.cos(angle);
          node.y = radius * Math.sin(angle);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }

    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random);
      return force;
    }

    initializeNodes();

    return simulation = {
      tick: tick,

      restart: function() {
        return stepper.restart(step), simulation;
      },

      stop: function() {
        return stepper.stop(), simulation;
      },

      nodes: function(_) {
        return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },

      alpha: function(_) {
        return arguments.length ? (alpha = +_, simulation) : alpha;
      },

      alphaMin: function(_) {
        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
      },

      alphaDecay: function(_) {
        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
      },

      alphaTarget: function(_) {
        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
      },

      velocityDecay: function(_) {
        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
      },

      randomSource: function(_) {
        return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
      },

      force: function(name, _) {
        return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
      },

      find: function(x, y, radius) {
        var i = 0,
            n = nodes.length,
            dx,
            dy,
            d2,
            node,
            closest;

        if (radius == null) radius = Infinity;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x - node.x;
          dy = y - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest = node, radius = d2;
        }

        return closest;
      },

      on: function(name, _) {
        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
      }
    };
  }

  function manyBody() {
    var nodes,
        node,
        random,
        alpha,
        strength = constant$7(-30),
        strengths,
        distanceMin2 = 1,
        distanceMax2 = Infinity,
        theta2 = 0.81;

    function force(_) {
      var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node;
      strengths = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
    }

    function accumulate(quad) {
      var strength = 0, q, c, weight = 0, x, y, i;

      // For internal nodes, accumulate forces from child quadrants.
      if (quad.length) {
        for (x = y = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c = Math.abs(q.value))) {
            strength += q.value, weight += c, x += c * q.x, y += c * q.y;
          }
        }
        quad.x = x / weight;
        quad.y = y / weight;
      }

      // For leaf nodes, accumulate forces from coincident quadrants.
      else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do strength += strengths[q.data.index];
        while (q = q.next);
      }

      quad.value = strength;
    }

    function apply(quad, x1, _, x2) {
      if (!quad.value) return true;

      var x = quad.x - node.x,
          y = quad.y - node.y,
          w = x2 - x1,
          l = x * x + y * y;

      // Apply the Barnes-Hut approximation if possible.
      // Limit forces for very close nodes; randomize direction if coincident.
      if (w * w / theta2 < l) {
        if (l < distanceMax2) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
          node.vx += x * quad.value * alpha / l;
          node.vy += y * quad.value * alpha / l;
        }
        return true;
      }

      // Otherwise, process points directly.
      else if (quad.length || l >= distanceMax2) return;

      // Limit forces for very close nodes; randomize direction if coincident.
      if (quad.data !== node || quad.next) {
        if (x === 0) x = jiggle(random), l += x * x;
        if (y === 0) y = jiggle(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
      }

      do if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x * w;
        node.vy += y * w;
      } while (quad = quad.next);
    }

    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
    };

    force.distanceMin = function(_) {
      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
    };

    force.distanceMax = function(_) {
      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
    };

    force.theta = function(_) {
      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
    };

    return force;
  }

  function radial(radius, x, y) {
    var nodes,
        strength = constant$7(0.1),
        strengths,
        radiuses;

    if (typeof radius !== "function") radius = constant$7(+radius);
    if (x == null) x = 0;
    if (y == null) y = 0;

    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; ++i) {
        var node = nodes[i],
            dx = node.x - x || 1e-6,
            dy = node.y - y || 1e-6,
            r = Math.sqrt(dx * dx + dy * dy),
            k = (radiuses[i] - r) * strengths[i] * alpha / r;
        node.vx += dx * k;
        node.vy += dy * k;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      radiuses = new Array(n);
      for (i = 0; i < n; ++i) {
        radiuses[i] = +radius(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function(_) {
      nodes = _, initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
    };

    force.radius = function(_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : radius;
    };

    force.x = function(_) {
      return arguments.length ? (x = +_, force) : x;
    };

    force.y = function(_) {
      return arguments.length ? (y = +_, force) : y;
    };

    return force;
  }

  function x$2(x) {
    var strength = constant$7(0.1),
        nodes,
        strengths,
        xz;

    if (typeof x !== "function") x = constant$7(x == null ? 0 : +x);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
    };

    force.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : x;
    };

    return force;
  }

  function y$2(y) {
    var strength = constant$7(0.1),
        nodes,
        strengths,
        yz;

    if (typeof y !== "function") y = constant$7(y == null ? 0 : +y);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
    };

    force.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : y;
    };

    return force;
  }

  function formatDecimal(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent$1(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded(x * 100, p),
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  function identity$3(x) {
    return x;
  }

  var map$1 = Array.prototype.map,
      prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map$1.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map$1.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "−" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent$1(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
  }

  var epsilon$4 = 1e-6;
  var epsilon2$1 = 1e-12;
  var pi$3 = Math.PI;
  var halfPi$2 = pi$3 / 2;
  var quarterPi = pi$3 / 4;
  var tau$4 = pi$3 * 2;

  var degrees$2 = 180 / pi$3;
  var radians$1 = pi$3 / 180;

  var abs$2 = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos$1 = Math.cos;
  var ceil = Math.ceil;
  var exp = Math.exp;
  var hypot = Math.hypot;
  var log = Math.log;
  var pow$1 = Math.pow;
  var sin$1 = Math.sin;
  var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
  var sqrt = Math.sqrt;
  var tan = Math.tan;

  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);
  }

  function asin(x) {
    return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
  }

  function haversin(x) {
    return (x = sin$1(x / 2)) * x;
  }

  function noop$2() {}

  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }

  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };

  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };

  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }

  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }

  function geoStream(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  var areaRingSum = new Adder();

  // hello?

  var areaSum = new Adder(),
      lambda00,
      phi00,
      lambda0,
      cosPhi0,
      sinPhi0;

  var areaStream = {
    point: noop$2,
    lineStart: noop$2,
    lineEnd: noop$2,
    polygonStart: function() {
      areaRingSum = new Adder();
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      var areaRing = +areaRingSum;
      areaSum.add(areaRing < 0 ? tau$4 + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop$2;
    },
    sphere: function() {
      areaSum.add(tau$4);
    }
  };

  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }

  function areaRingEnd() {
    areaPoint(lambda00, phi00);
  }

  function areaPointFirst(lambda, phi) {
    areaStream.point = areaPoint;
    lambda00 = lambda, phi00 = phi;
    lambda *= radians$1, phi *= radians$1;
    lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
  }

  function areaPoint(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    phi = phi / 2 + quarterPi; // half the angular distance from south pole

    // Spherical excess E for a spherical triangle with vertices: south pole,
    // previous point, current point.  Uses a formula derived from Cagnoli’s
    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
    var dLambda = lambda - lambda0,
        sdLambda = dLambda >= 0 ? 1 : -1,
        adLambda = sdLambda * dLambda,
        cosPhi = cos$1(phi),
        sinPhi = sin$1(phi),
        k = sinPhi0 * sinPhi,
        u = cosPhi0 * cosPhi + k * cos$1(adLambda),
        v = k * sdLambda * sin$1(adLambda);
    areaRingSum.add(atan2(v, u));

    // Advance the previous points.
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
  }

  function area$1(object) {
    areaSum = new Adder();
    geoStream(object, areaStream);
    return areaSum * 2;
  }

  function spherical(cartesian) {
    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
  }

  function cartesian(spherical) {
    var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
    return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
  }

  function cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }

  // TODO return a
  function cartesianAddInPlace(a, b) {
    a[0] += b[0], a[1] += b[1], a[2] += b[2];
  }

  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }

  // TODO return d
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  var lambda0$1, phi0, lambda1, phi1, // bounds
      lambda2, // previous lambda-coordinate
      lambda00$1, phi00$1, // first point
      p0, // previous 3D point
      deltaSum,
      ranges,
      range$1;

  var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
      boundsStream.point = boundsRingPoint;
      boundsStream.lineStart = boundsRingStart;
      boundsStream.lineEnd = boundsRingEnd;
      deltaSum = new Adder();
      areaStream.polygonStart();
    },
    polygonEnd: function() {
      areaStream.polygonEnd();
      boundsStream.point = boundsPoint;
      boundsStream.lineStart = boundsLineStart;
      boundsStream.lineEnd = boundsLineEnd;
      if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      else if (deltaSum > epsilon$4) phi1 = 90;
      else if (deltaSum < -epsilon$4) phi0 = -90;
      range$1[0] = lambda0$1, range$1[1] = lambda1;
    },
    sphere: function() {
      lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    }
  };

  function boundsPoint(lambda, phi) {
    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
  }

  function linePoint(lambda, phi) {
    var p = cartesian([lambda * radians$1, phi * radians$1]);
    if (p0) {
      var normal = cartesianCross(p0, p),
          equatorial = [normal[1], -normal[0], 0],
          inflection = cartesianCross(equatorial, normal);
      cartesianNormalizeInPlace(inflection);
      inflection = spherical(inflection);
      var delta = lambda - lambda2,
          sign = delta > 0 ? 1 : -1,
          lambdai = inflection[0] * degrees$2 * sign,
          phii,
          antimeridian = abs$2(delta) > 180;
      if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
        phii = inflection[1] * degrees$2;
        if (phii > phi1) phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
        phii = -inflection[1] * degrees$2;
        if (phii < phi0) phi0 = phii;
      } else {
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      } else {
        if (lambda1 >= lambda0$1) {
          if (lambda < lambda0$1) lambda0$1 = lambda;
          if (lambda > lambda1) lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        }
      }
    } else {
      ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
    }
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
    p0 = p, lambda2 = lambda;
  }

  function boundsLineStart() {
    boundsStream.point = linePoint;
  }

  function boundsLineEnd() {
    range$1[0] = lambda0$1, range$1[1] = lambda1;
    boundsStream.point = boundsPoint;
    p0 = null;
  }

  function boundsRingPoint(lambda, phi) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum.add(abs$2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda00$1 = lambda, phi00$1 = phi;
    }
    areaStream.point(lambda, phi);
    linePoint(lambda, phi);
  }

  function boundsRingStart() {
    areaStream.lineStart();
  }

  function boundsRingEnd() {
    boundsRingPoint(lambda00$1, phi00$1);
    areaStream.lineEnd();
    if (abs$2(deltaSum) > epsilon$4) lambda0$1 = -(lambda1 = 180);
    range$1[0] = lambda0$1, range$1[1] = lambda1;
    p0 = null;
  }

  // Finds the left-right distance between two longitudes.
  // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
  // the distance between ±180° to be 360°.
  function angle(lambda0, lambda1) {
    return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
  }

  function rangeCompare(a, b) {
    return a[0] - b[0];
  }

  function rangeContains(range, x) {
    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
  }

  function bounds(feature) {
    var i, n, a, b, merged, deltaMax, delta;

    phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
    ranges = [];
    geoStream(feature, boundsStream);

    // First, sort ranges by their minimum longitudes.
    if (n = ranges.length) {
      ranges.sort(rangeCompare);

      // Then, merge any ranges that overlap.
      for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
        b = ranges[i];
        if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
          if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
          if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
        } else {
          merged.push(a = b);
        }
      }

      // Finally, find the largest gap between the merged ranges.
      // The final bounding box will be the inverse of this gap.
      for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
        b = merged[i];
        if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
      }
    }

    ranges = range$1 = null;

    return lambda0$1 === Infinity || phi0 === Infinity
        ? [[NaN, NaN], [NaN, NaN]]
        : [[lambda0$1, phi0], [lambda1, phi1]];
  }

  var W0, W1,
      X0, Y0, Z0,
      X1, Y1, Z1,
      X2, Y2, Z2,
      lambda00$2, phi00$2, // first point
      x0, y0, z0; // previous point

  var centroidStream = {
    sphere: noop$2,
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    }
  };

  // Arithmetic mean of Cartesian vectors.
  function centroidPoint(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    var cosPhi = cos$1(phi);
    centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
  }

  function centroidPointCartesian(x, y, z) {
    ++W0;
    X0 += (x - X0) / W0;
    Y0 += (y - Y0) / W0;
    Z0 += (z - Z0) / W0;
  }

  function centroidLineStart() {
    centroidStream.point = centroidLinePointFirst;
  }

  function centroidLinePointFirst(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    var cosPhi = cos$1(phi);
    x0 = cosPhi * cos$1(lambda);
    y0 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi);
    centroidStream.point = centroidLinePoint;
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidLinePoint(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    var cosPhi = cos$1(phi),
        x = cosPhi * cos$1(lambda),
        y = cosPhi * sin$1(lambda),
        z = sin$1(phi),
        w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }

  // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
  // J. Applied Mechanics 42, 239 (1975).
  function centroidRingStart() {
    centroidStream.point = centroidRingPointFirst;
  }

  function centroidRingEnd() {
    centroidRingPoint(lambda00$2, phi00$2);
    centroidStream.point = centroidPoint;
  }

  function centroidRingPointFirst(lambda, phi) {
    lambda00$2 = lambda, phi00$2 = phi;
    lambda *= radians$1, phi *= radians$1;
    centroidStream.point = centroidRingPoint;
    var cosPhi = cos$1(phi);
    x0 = cosPhi * cos$1(lambda);
    y0 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi);
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidRingPoint(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    var cosPhi = cos$1(phi),
        x = cosPhi * cos$1(lambda),
        y = cosPhi * sin$1(lambda),
        z = sin$1(phi),
        cx = y0 * z - z0 * y,
        cy = z0 * x - x0 * z,
        cz = x0 * y - y0 * x,
        m = hypot(cx, cy, cz),
        w = asin(m), // line weight = angle
        v = m && -w / m; // area weight multiplier
    X2.add(v * cx);
    Y2.add(v * cy);
    Z2.add(v * cz);
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
  }

  function centroid(object) {
    W0 = W1 =
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 = 0;
    X2 = new Adder();
    Y2 = new Adder();
    Z2 = new Adder();
    geoStream(object, centroidStream);

    var x = +X2,
        y = +Y2,
        z = +Z2,
        m = hypot(x, y, z);

    // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
    if (m < epsilon2$1) {
      x = X1, y = Y1, z = Z1;
      // If the feature has zero length, fall back to arithmetic mean of point vectors.
      if (W1 < epsilon$4) x = X0, y = Y0, z = Z0;
      m = hypot(x, y, z);
      // If the feature still has an undefined ccentroid, then return.
      if (m < epsilon2$1) return [NaN, NaN];
    }

    return [atan2(y, x) * degrees$2, asin(z / m) * degrees$2];
  }

  function constant$8(x) {
    return function() {
      return x;
    };
  }

  function compose(a, b) {

    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }

    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };

    return compose;
  }

  function rotationIdentity(lambda, phi) {
    return [abs$2(lambda) > pi$3 ? lambda + Math.round(-lambda / tau$4) * tau$4 : lambda, phi];
  }

  rotationIdentity.invert = rotationIdentity;

  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau$4) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
      : rotationLambda(deltaLambda))
      : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
      : rotationIdentity);
  }

  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$4 : lambda < -pi$3 ? lambda + tau$4 : lambda, phi];
    };
  }

  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }

  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos$1(deltaPhi),
        sinDeltaPhi = sin$1(deltaPhi),
        cosDeltaGamma = cos$1(deltaGamma),
        sinDeltaGamma = sin$1(deltaGamma);

    function rotation(lambda, phi) {
      var cosPhi = cos$1(phi),
          x = cos$1(lambda) * cosPhi,
          y = sin$1(lambda) * cosPhi,
          z = sin$1(phi),
          k = z * cosDeltaPhi + x * sinDeltaPhi;
      return [
        atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
        asin(k * cosDeltaGamma + y * sinDeltaGamma)
      ];
    }

    rotation.invert = function(lambda, phi) {
      var cosPhi = cos$1(phi),
          x = cos$1(lambda) * cosPhi,
          y = sin$1(lambda) * cosPhi,
          z = sin$1(phi),
          k = z * cosDeltaGamma - y * sinDeltaGamma;
      return [
        atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
        asin(k * cosDeltaPhi - x * sinDeltaPhi)
      ];
    };

    return rotation;
  }

  function rotation(rotate) {
    rotate = rotateRadians(rotate[0] * radians$1, rotate[1] * radians$1, rotate.length > 2 ? rotate[2] * radians$1 : 0);

    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * radians$1, coordinates[1] * radians$1);
      return coordinates[0] *= degrees$2, coordinates[1] *= degrees$2, coordinates;
    }

    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * radians$1, coordinates[1] * radians$1);
      return coordinates[0] *= degrees$2, coordinates[1] *= degrees$2, coordinates;
    };

    return forward;
  }

  // Generates a circle centered at [0°, 0°], with a given radius and precision.
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta) return;
    var cosRadius = cos$1(radius),
        sinRadius = sin$1(radius),
        step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau$4;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$4;
    }
    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
      point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
      stream.point(point[0], point[1]);
    }
  }

  // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
  function circleRadius(cosRadius, point) {
    point = cartesian(point), point[0] -= cosRadius;
    cartesianNormalizeInPlace(point);
    var radius = acos(-point[1]);
    return ((-point[2] < 0 ? -radius : radius) + tau$4 - epsilon$4) % tau$4;
  }

  function circle() {
    var center = constant$8([0, 0]),
        radius = constant$8(90),
        precision = constant$8(6),
        ring,
        rotate,
        stream = {point: point};

    function point(x, y) {
      ring.push(x = rotate(x, y));
      x[0] *= degrees$2, x[1] *= degrees$2;
    }

    function circle() {
      var c = center.apply(this, arguments),
          r = radius.apply(this, arguments) * radians$1,
          p = precision.apply(this, arguments) * radians$1;
      ring = [];
      rotate = rotateRadians(-c[0] * radians$1, -c[1] * radians$1, 0).invert;
      circleStream(stream, r, p, 1);
      c = {type: "Polygon", coordinates: [ring]};
      ring = rotate = null;
      return c;
    }

    circle.center = function(_) {
      return arguments.length ? (center = typeof _ === "function" ? _ : constant$8([+_[0], +_[1]]), circle) : center;
    };

    circle.radius = function(_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$8(+_), circle) : radius;
    };

    circle.precision = function(_) {
      return arguments.length ? (precision = typeof _ === "function" ? _ : constant$8(+_), circle) : precision;
    };

    return circle;
  }

  function clipBuffer() {
    var lines = [],
        line;
    return {
      point: function(x, y, m) {
        line.push([x, y, m]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop$2,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  function pointEqual(a, b) {
    return abs$2(a[0] - b[0]) < epsilon$4 && abs$2(a[1] - b[1]) < epsilon$4;
  }

  function Intersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other; // another intersection
    this.e = entry; // is an entry?
    this.v = false; // visited
    this.n = this.p = null; // next & previous
  }

  // A generalized polygon clipping algorithm: given a polygon that has been cut
  // into its visible line segments, and rejoins the segments by interpolating
  // along the clip edge.
  function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
    var subject = [],
        clip = [],
        i,
        n;

    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n], x;

      if (pointEqual(p0, p1)) {
        if (!p0[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }
        // handle degenerate cases by moving the point
        p1[0] += 2 * epsilon$4;
      }

      subject.push(x = new Intersection(p0, segment, null, true));
      clip.push(x.o = new Intersection(p0, null, x, false));
      subject.push(x = new Intersection(p1, segment, null, false));
      clip.push(x.o = new Intersection(p1, null, x, true));
    });

    if (!subject.length) return;

    clip.sort(compareIntersection);
    link$1(subject);
    link$1(clip);

    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }

    var start = subject[0],
        points,
        point;

    while (1) {
      // Find first unvisited intersection.
      var current = start,
          isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }

  function link$1(array) {
    if (!(n = array.length)) return;
    var n,
        i = 0,
        a = array[0],
        b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }

  function longitude(point) {
    if (abs$2(point[0]) <= pi$3)
      return point[0];
    else
      return sign(point[0]) * ((abs$2(point[0]) + pi$3) % tau$4 - pi$3);
  }

  function polygonContains(polygon, point) {
    var lambda = longitude(point),
        phi = point[1],
        sinPhi = sin$1(phi),
        normal = [sin$1(lambda), -cos$1(lambda), 0],
        angle = 0,
        winding = 0;

    var sum = new Adder();

    if (sinPhi === 1) phi = halfPi$2 + epsilon$4;
    else if (sinPhi === -1) phi = -halfPi$2 - epsilon$4;

    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m = (ring = polygon[i]).length)) continue;
      var ring,
          m,
          point0 = ring[m - 1],
          lambda0 = longitude(point0),
          phi0 = point0[1] / 2 + quarterPi,
          sinPhi0 = sin$1(phi0),
          cosPhi0 = cos$1(phi0);

      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j],
            lambda1 = longitude(point1),
            phi1 = point1[1] / 2 + quarterPi,
            sinPhi1 = sin$1(phi1),
            cosPhi1 = cos$1(phi1),
            delta = lambda1 - lambda0,
            sign = delta >= 0 ? 1 : -1,
            absDelta = sign * delta,
            antimeridian = absDelta > pi$3,
            k = sinPhi0 * sinPhi1;

        sum.add(atan2(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
        angle += antimeridian ? delta + sign * tau$4 : delta;

        // Are the longitudes either side of the point’s meridian (lambda),
        // and are the latitudes smaller than the parallel (phi)?
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }

    // First, determine whether the South pole is inside or outside:
    //
    // It is inside if:
    // * the polygon winds around it in a clockwise direction.
    // * the polygon does not (cumulatively) wind around it, but has a negative
    //   (counter-clockwise) area.
    //
    // Second, count the (signed) number of times a segment crosses a lambda
    // from the point to the South pole.  If it is zero, then the point is the
    // same side as the South pole.

    return (angle < -epsilon$4 || angle < epsilon$4 && sum < -epsilon2$1) ^ (winding & 1);
  }

  function clip(pointVisible, clipLine, interpolate, start) {
    return function(sink) {
      var line = clipLine(sink),
          ringBuffer = clipBuffer(),
          ringSink = clipLine(ringBuffer),
          polygonStarted = false,
          polygon,
          segments,
          ring;

      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains(polygon, start);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };

      function point(lambda, phi) {
        if (pointVisible(lambda, phi)) sink.point(lambda, phi);
      }

      function pointLine(lambda, phi) {
        line.point(lambda, phi);
      }

      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }

      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }

      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        ringSink.point(lambda, phi);
      }

      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }

      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();

        var clean = ringSink.clean(),
            ringSegments = ringBuffer.result(),
            i, n = ringSegments.length, m,
            segment,
            point;

        ring.pop();
        polygon.push(ring);
        ring = null;

        if (!n) return;

        // No intersections.
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
            sink.lineEnd();
          }
          return;
        }

        // Rejoin connected segments.
        // TODO reuse ringBuffer.rejoin()?
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

        segments.push(ringSegments.filter(validSegment));
      }

      return clip;
    };
  }

  function validSegment(segment) {
    return segment.length > 1;
  }

  // Intersections are sorted along the clip edge. For both antimeridian cutting
  // and circle clipping, the same comparison is used.
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$4 : halfPi$2 - a[1])
         - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$4 : halfPi$2 - b[1]);
  }

  var clipAntimeridian = clip(
    function() { return true; },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi$3, -halfPi$2]
  );

  // Takes a line and cuts into visible segments. Return values: 0 - there were
  // intersections or the line was empty; 1 - no intersections; 2 - there were
  // intersections, and the first and last segments should be rejoined.
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN,
        phi0 = NaN,
        sign0 = NaN,
        clean; // no intersections

    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi$3 : -pi$3,
            delta = abs$2(lambda1 - lambda0);
        if (abs$2(delta - pi$3) < epsilon$4) { // line crosses a pole
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi$3) { // line crosses antimeridian
          if (abs$2(lambda0 - sign0) < epsilon$4) lambda0 -= sign0 * epsilon$4; // handle degeneracies
          if (abs$2(lambda1 - sign1) < epsilon$4) lambda1 -= sign1 * epsilon$4;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean; // if intersections, rejoin first and last segments
      }
    };
  }

  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0,
        cosPhi1,
        sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
    return abs$2(sinLambda0Lambda1) > epsilon$4
        ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
            - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
            / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
        : (phi0 + phi1) / 2;
  }

  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi$2;
      stream.point(-pi$3, phi);
      stream.point(0, phi);
      stream.point(pi$3, phi);
      stream.point(pi$3, 0);
      stream.point(pi$3, -phi);
      stream.point(0, -phi);
      stream.point(-pi$3, -phi);
      stream.point(-pi$3, 0);
      stream.point(-pi$3, phi);
    } else if (abs$2(from[0] - to[0]) > epsilon$4) {
      var lambda = from[0] < to[0] ? pi$3 : -pi$3;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function clipCircle(radius) {
    var cr = cos$1(radius),
        delta = 6 * radians$1,
        smallRadius = cr > 0,
        notHemisphere = abs$2(cr) > epsilon$4; // TODO optimise for this common case

    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }

    function visible(lambda, phi) {
      return cos$1(lambda) * cos$1(phi) > cr;
    }

    // Takes a line and cuts into visible segments. Return values used for polygon
    // clipping: 0 - there were intersections or the line was empty; 1 - no
    // intersections 2 - there were intersections, and the first and last segments
    // should be rejoined.
    function clipLine(stream) {
      var point0, // previous point
          c0, // code for previous point
          v0, // visibility of previous point
          v00, // visibility of first point
          clean; // no intersections
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi],
              point2,
              v = visible(lambda, phi),
              c = smallRadius
                ? v ? 0 : code(lambda, phi)
                : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
              point1[2] = 1;
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              // outside going in
              stream.lineStart();
              point2 = intersect(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              // inside going out
              point2 = intersect(point0, point1);
              stream.point(point2[0], point2[1], 2);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            // If the codes for two points are different, or are both zero,
            // and there this segment intersects with the small circle.
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v && (!point0 || !pointEqual(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | ((v00 && v0) << 1);
        }
      };
    }

    // Intersects the great circle between a and b with the clip circle.
    function intersect(a, b, two) {
      var pa = cartesian(a),
          pb = cartesian(b);

      // We have two planes, n1.p = d1 and n2.p = d2.
      // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
      var n1 = [1, 0, 0], // normal
          n2 = cartesianCross(pa, pb),
          n2n2 = cartesianDot(n2, n2),
          n1n2 = n2[0], // cartesianDot(n1, n2),
          determinant = n2n2 - n1n2 * n1n2;

      // Two polar points.
      if (!determinant) return !two && a;

      var c1 =  cr * n2n2 / determinant,
          c2 = -cr * n1n2 / determinant,
          n1xn2 = cartesianCross(n1, n2),
          A = cartesianScale(n1, c1),
          B = cartesianScale(n2, c2);
      cartesianAddInPlace(A, B);

      // Solve |p(t)|^2 = 1.
      var u = n1xn2,
          w = cartesianDot(A, u),
          uu = cartesianDot(u, u),
          t2 = w * w - uu * (cartesianDot(A, A) - 1);

      if (t2 < 0) return;

      var t = sqrt(t2),
          q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A);
      q = spherical(q);

      if (!two) return q;

      // Two intersection points.
      var lambda0 = a[0],
          lambda1 = b[0],
          phi0 = a[1],
          phi1 = b[1],
          z;

      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

      var delta = lambda1 - lambda0,
          polar = abs$2(delta - pi$3) < epsilon$4,
          meridian = polar || delta < epsilon$4;

      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

      // Check that the first point is between a and b.
      if (meridian
          ? polar
            ? phi0 + phi1 > 0 ^ q[1] < (abs$2(q[0] - lambda0) < epsilon$4 ? phi0 : phi1)
            : phi0 <= q[1] && q[1] <= phi1
          : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q1, A);
        return [q, spherical(q1)];
      }
    }

    // Generates a 4-bit vector representing the location of a point relative to
    // the small circle's bounding box.
    function code(lambda, phi) {
      var r = smallRadius ? radius : pi$3 - radius,
          code = 0;
      if (lambda < -r) code |= 1; // left
      else if (lambda > r) code |= 2; // right
      if (phi < -r) code |= 4; // below
      else if (phi > r) code |= 8; // above
      return code;
    }

    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
  }

  function clipLine(a, b, x0, y0, x1, y1) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1],
        t0 = 0,
        t1 = 1,
        dx = bx - ax,
        dy = by - ay,
        r;

    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  var clipMax = 1e9, clipMin = -clipMax;

  // TODO Use d3-polygon’s polygonContains here for the ring check?
  // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

  function clipRectangle(x0, y0, x1, y1) {

    function visible(x, y) {
      return x0 <= x && x <= x1 && y0 <= y && y <= y1;
    }

    function interpolate(from, to, direction, stream) {
      var a = 0, a1 = 0;
      if (from == null
          || (a = corner(from, direction)) !== (a1 = corner(to, direction))
          || comparePoint(from, to) < 0 ^ direction > 0) {
        do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
        while ((a = (a + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function corner(p, direction) {
      return abs$2(p[0] - x0) < epsilon$4 ? direction > 0 ? 0 : 3
          : abs$2(p[0] - x1) < epsilon$4 ? direction > 0 ? 2 : 1
          : abs$2(p[1] - y0) < epsilon$4 ? direction > 0 ? 1 : 0
          : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
    }

    function compareIntersection(a, b) {
      return comparePoint(a.x, b.x);
    }

    function comparePoint(a, b) {
      var ca = corner(a, 1),
          cb = corner(b, 1);
      return ca !== cb ? ca - cb
          : ca === 0 ? b[1] - a[1]
          : ca === 1 ? a[0] - b[0]
          : ca === 2 ? a[1] - b[1]
          : b[0] - a[0];
    }

    return function(stream) {
      var activeStream = stream,
          bufferStream = clipBuffer(),
          segments,
          polygon,
          ring,
          x__, y__, v__, // first point
          x_, y_, v_, // previous point
          first,
          clean;

      var clipStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: polygonStart,
        polygonEnd: polygonEnd
      };

      function point(x, y) {
        if (visible(x, y)) activeStream.point(x, y);
      }

      function polygonInside() {
        var winding = 0;

        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
            if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
            else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
          }
        }

        return winding;
      }

      // Buffer geometry within a polygon and then clip it en masse.
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }

      function polygonEnd() {
        var startInside = polygonInside(),
            cleanInside = clean && startInside,
            visible = (segments = merge(segments)).length;
        if (cleanInside || visible) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible) {
            clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }

      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }

      // TODO rather than special-case polygons, simply handle them separately.
      // Ideally, coincident intersection points should be jittered to avoid
      // clipping issues.
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point;
        if (v_) activeStream.lineEnd();
      }

      function linePoint(x, y) {
        var v = visible(x, y);
        if (polygon) ring.push([x, y]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
          }
        } else {
          if (v && v_) activeStream.point(x, y);
          else {
            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
            if (clipLine(a, b, x0, y0, x1, y1)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a[0], a[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }

      return clipStream;
    };
  }

  function extent$1() {
    var x0 = 0,
        y0 = 0,
        x1 = 960,
        y1 = 500,
        cache,
        cacheStream,
        clip;

    return clip = {
      stream: function(stream) {
        return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
      },
      extent: function(_) {
        return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
      }
    };
  }

  var lengthSum,
      lambda0$2,
      sinPhi0$1,
      cosPhi0$1;

  var lengthStream = {
    sphere: noop$2,
    point: noop$2,
    lineStart: lengthLineStart,
    lineEnd: noop$2,
    polygonStart: noop$2,
    polygonEnd: noop$2
  };

  function lengthLineStart() {
    lengthStream.point = lengthPointFirst;
    lengthStream.lineEnd = lengthLineEnd;
  }

  function lengthLineEnd() {
    lengthStream.point = lengthStream.lineEnd = noop$2;
  }

  function lengthPointFirst(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
    lengthStream.point = lengthPoint;
  }

  function lengthPoint(lambda, phi) {
    lambda *= radians$1, phi *= radians$1;
    var sinPhi = sin$1(phi),
        cosPhi = cos$1(phi),
        delta = abs$2(lambda - lambda0$2),
        cosDelta = cos$1(delta),
        sinDelta = sin$1(delta),
        x = cosPhi * sinDelta,
        y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
        z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
    lengthSum.add(atan2(sqrt(x * x + y * y), z));
    lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
  }

  function length$2(object) {
    lengthSum = new Adder();
    geoStream(object, lengthStream);
    return +lengthSum;
  }

  var coordinates = [null, null],
      object$1 = {type: "LineString", coordinates: coordinates};

  function distance(a, b) {
    coordinates[0] = a;
    coordinates[1] = b;
    return length$2(object$1);
  }

  var containsObjectType = {
    Feature: function(object, point) {
      return containsGeometry(object.geometry, point);
    },
    FeatureCollection: function(object, point) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
      return false;
    }
  };

  var containsGeometryType = {
    Sphere: function() {
      return true;
    },
    Point: function(object, point) {
      return containsPoint(object.coordinates, point);
    },
    MultiPoint: function(object, point) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) if (containsPoint(coordinates[i], point)) return true;
      return false;
    },
    LineString: function(object, point) {
      return containsLine(object.coordinates, point);
    },
    MultiLineString: function(object, point) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) if (containsLine(coordinates[i], point)) return true;
      return false;
    },
    Polygon: function(object, point) {
      return containsPolygon(object.coordinates, point);
    },
    MultiPolygon: function(object, point) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
      return false;
    },
    GeometryCollection: function(object, point) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) if (containsGeometry(geometries[i], point)) return true;
      return false;
    }
  };

  function containsGeometry(geometry, point) {
    return geometry && containsGeometryType.hasOwnProperty(geometry.type)
        ? containsGeometryType[geometry.type](geometry, point)
        : false;
  }

  function containsPoint(coordinates, point) {
    return distance(coordinates, point) === 0;
  }

  function containsLine(coordinates, point) {
    var ao, bo, ab;
    for (var i = 0, n = coordinates.length; i < n; i++) {
      bo = distance(coordinates[i], point);
      if (bo === 0) return true;
      if (i > 0) {
        ab = distance(coordinates[i], coordinates[i - 1]);
        if (
          ab > 0 &&
          ao <= ab &&
          bo <= ab &&
          (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab
        )
          return true;
      }
      ao = bo;
    }
    return false;
  }

  function containsPolygon(coordinates, point) {
    return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
  }

  function ringRadians(ring) {
    return ring = ring.map(pointRadians), ring.pop(), ring;
  }

  function pointRadians(point) {
    return [point[0] * radians$1, point[1] * radians$1];
  }

  function contains$1(object, point) {
    return (object && containsObjectType.hasOwnProperty(object.type)
        ? containsObjectType[object.type]
        : containsGeometry)(object, point);
  }

  function graticuleX(y0, y1, dy) {
    var y = sequence(y0, y1 - epsilon$4, dy).concat(y1);
    return function(x) { return y.map(function(y) { return [x, y]; }); };
  }

  function graticuleY(x0, x1, dx) {
    var x = sequence(x0, x1 - epsilon$4, dx).concat(x1);
    return function(y) { return x.map(function(x) { return [x, y]; }); };
  }

  function graticule() {
    var x1, x0, X1, X0,
        y1, y0, Y1, Y0,
        dx = 10, dy = dx, DX = 90, DY = 360,
        x, y, X, Y,
        precision = 2.5;

    function graticule() {
      return {type: "MultiLineString", coordinates: lines()};
    }

    function lines() {
      return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)
          .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
          .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$2(x % DX) > epsilon$4; }).map(x))
          .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$2(y % DY) > epsilon$4; }).map(y));
    }

    graticule.lines = function() {
      return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
    };

    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X(X0).concat(
          Y(Y1).slice(1),
          X(X1).reverse().slice(1),
          Y(Y0).reverse().slice(1))
        ]
      };
    };

    graticule.extent = function(_) {
      if (!arguments.length) return graticule.extentMinor();
      return graticule.extentMajor(_).extentMinor(_);
    };

    graticule.extentMajor = function(_) {
      if (!arguments.length) return [[X0, Y0], [X1, Y1]];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };

    graticule.extentMinor = function(_) {
      if (!arguments.length) return [[x0, y0], [x1, y1]];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };

    graticule.step = function(_) {
      if (!arguments.length) return graticule.stepMinor();
      return graticule.stepMajor(_).stepMinor(_);
    };

    graticule.stepMajor = function(_) {
      if (!arguments.length) return [DX, DY];
      DX = +_[0], DY = +_[1];
      return graticule;
    };

    graticule.stepMinor = function(_) {
      if (!arguments.length) return [dx, dy];
      dx = +_[0], dy = +_[1];
      return graticule;
    };

    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = graticuleX(y0, y1, 90);
      y = graticuleY(x0, x1, precision);
      X = graticuleX(Y0, Y1, 90);
      Y = graticuleY(X0, X1, precision);
      return graticule;
    };

    return graticule
        .extentMajor([[-180, -90 + epsilon$4], [180, 90 - epsilon$4]])
        .extentMinor([[-180, -80 - epsilon$4], [180, 80 + epsilon$4]]);
  }

  function graticule10() {
    return graticule()();
  }

  function interpolate$2(a, b) {
    var x0 = a[0] * radians$1,
        y0 = a[1] * radians$1,
        x1 = b[0] * radians$1,
        y1 = b[1] * radians$1,
        cy0 = cos$1(y0),
        sy0 = sin$1(y0),
        cy1 = cos$1(y1),
        sy1 = sin$1(y1),
        kx0 = cy0 * cos$1(x0),
        ky0 = cy0 * sin$1(x0),
        kx1 = cy1 * cos$1(x1),
        ky1 = cy1 * sin$1(x1),
        d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
        k = sin$1(d);

    var interpolate = d ? function(t) {
      var B = sin$1(t *= d) / k,
          A = sin$1(d - t) / k,
          x = A * kx0 + B * kx1,
          y = A * ky0 + B * ky1,
          z = A * sy0 + B * sy1;
      return [
        atan2(y, x) * degrees$2,
        atan2(z, sqrt(x * x + y * y)) * degrees$2
      ];
    } : function() {
      return [x0 * degrees$2, y0 * degrees$2];
    };

    interpolate.distance = d;

    return interpolate;
  }

  var identity$4 = x => x;

  var areaSum$1 = new Adder(),
      areaRingSum$1 = new Adder(),
      x00,
      y00,
      x0$1,
      y0$1;

  var areaStream$1 = {
    point: noop$2,
    lineStart: noop$2,
    lineEnd: noop$2,
    polygonStart: function() {
      areaStream$1.lineStart = areaRingStart$1;
      areaStream$1.lineEnd = areaRingEnd$1;
    },
    polygonEnd: function() {
      areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;
      areaSum$1.add(abs$2(areaRingSum$1));
      areaRingSum$1 = new Adder();
    },
    result: function() {
      var area = areaSum$1 / 2;
      areaSum$1 = new Adder();
      return area;
    }
  };

  function areaRingStart$1() {
    areaStream$1.point = areaPointFirst$1;
  }

  function areaPointFirst$1(x, y) {
    areaStream$1.point = areaPoint$1;
    x00 = x0$1 = x, y00 = y0$1 = y;
  }

  function areaPoint$1(x, y) {
    areaRingSum$1.add(y0$1 * x - x0$1 * y);
    x0$1 = x, y0$1 = y;
  }

  function areaRingEnd$1() {
    areaPoint$1(x00, y00);
  }

  var x0$2 = Infinity,
      y0$2 = x0$2,
      x1 = -x0$2,
      y1 = x1;

  var boundsStream$1 = {
    point: boundsPoint$1,
    lineStart: noop$2,
    lineEnd: noop$2,
    polygonStart: noop$2,
    polygonEnd: noop$2,
    result: function() {
      var bounds = [[x0$2, y0$2], [x1, y1]];
      x1 = y1 = -(y0$2 = x0$2 = Infinity);
      return bounds;
    }
  };

  function boundsPoint$1(x, y) {
    if (x < x0$2) x0$2 = x;
    if (x > x1) x1 = x;
    if (y < y0$2) y0$2 = y;
    if (y > y1) y1 = y;
  }

  // TODO Enforce positive area for exterior, negative area for interior?

  var X0$1 = 0,
      Y0$1 = 0,
      Z0$1 = 0,
      X1$1 = 0,
      Y1$1 = 0,
      Z1$1 = 0,
      X2$1 = 0,
      Y2$1 = 0,
      Z2$1 = 0,
      x00$1,
      y00$1,
      x0$3,
      y0$3;

  var centroidStream$1 = {
    point: centroidPoint$1,
    lineStart: centroidLineStart$1,
    lineEnd: centroidLineEnd$1,
    polygonStart: function() {
      centroidStream$1.lineStart = centroidRingStart$1;
      centroidStream$1.lineEnd = centroidRingEnd$1;
    },
    polygonEnd: function() {
      centroidStream$1.point = centroidPoint$1;
      centroidStream$1.lineStart = centroidLineStart$1;
      centroidStream$1.lineEnd = centroidLineEnd$1;
    },
    result: function() {
      var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
          : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
          : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
          : [NaN, NaN];
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 =
      X2$1 = Y2$1 = Z2$1 = 0;
      return centroid;
    }
  };

  function centroidPoint$1(x, y) {
    X0$1 += x;
    Y0$1 += y;
    ++Z0$1;
  }

  function centroidLineStart$1() {
    centroidStream$1.point = centroidPointFirstLine;
  }

  function centroidPointFirstLine(x, y) {
    centroidStream$1.point = centroidPointLine;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function centroidPointLine(x, y) {
    var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
    X1$1 += z * (x0$3 + x) / 2;
    Y1$1 += z * (y0$3 + y) / 2;
    Z1$1 += z;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function centroidLineEnd$1() {
    centroidStream$1.point = centroidPoint$1;
  }

  function centroidRingStart$1() {
    centroidStream$1.point = centroidPointFirstRing;
  }

  function centroidRingEnd$1() {
    centroidPointRing(x00$1, y00$1);
  }

  function centroidPointFirstRing(x, y) {
    centroidStream$1.point = centroidPointRing;
    centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
  }

  function centroidPointRing(x, y) {
    var dx = x - x0$3,
        dy = y - y0$3,
        z = sqrt(dx * dx + dy * dy);

    X1$1 += z * (x0$3 + x) / 2;
    Y1$1 += z * (y0$3 + y) / 2;
    Z1$1 += z;

    z = y0$3 * x - x0$3 * y;
    X2$1 += z * (x0$3 + x);
    Y2$1 += z * (y0$3 + y);
    Z2$1 += z * 3;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function PathContext(context) {
    this._context = context;
  }

  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x, y);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x, y);
          break;
        }
        default: {
          this._context.moveTo(x + this._radius, y);
          this._context.arc(x, y, this._radius, 0, tau$4);
          break;
        }
      }
    },
    result: noop$2
  };

  var lengthSum$1 = new Adder(),
      lengthRing,
      x00$2,
      y00$2,
      x0$4,
      y0$4;

  var lengthStream$1 = {
    point: noop$2,
    lineStart: function() {
      lengthStream$1.point = lengthPointFirst$1;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint$1(x00$2, y00$2);
      lengthStream$1.point = noop$2;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length = +lengthSum$1;
      lengthSum$1 = new Adder();
      return length;
    }
  };

  function lengthPointFirst$1(x, y) {
    lengthStream$1.point = lengthPoint$1;
    x00$2 = x0$4 = x, y00$2 = y0$4 = y;
  }

  function lengthPoint$1(x, y) {
    x0$4 -= x, y0$4 -= y;
    lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
    x0$4 = x, y0$4 = y;
  }

  function PathString() {
    this._string = [];
  }

  PathString.prototype = {
    _radius: 4.5,
    _circle: circle$1(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._string.push("Z");
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x, ",", y);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x, ",", y);
          break;
        }
        default: {
          if (this._circle == null) this._circle = circle$1(this._radius);
          this._string.push("M", x, ",", y, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };

  function circle$1(radius) {
    return "m0," + radius
        + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
        + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
        + "z";
  }

  function index$2(projection, context) {
    var pointRadius = 4.5,
        projectionStream,
        contextStream;

    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }

    path.area = function(object) {
      geoStream(object, projectionStream(areaStream$1));
      return areaStream$1.result();
    };

    path.measure = function(object) {
      geoStream(object, projectionStream(lengthStream$1));
      return lengthStream$1.result();
    };

    path.bounds = function(object) {
      geoStream(object, projectionStream(boundsStream$1));
      return boundsStream$1.result();
    };

    path.centroid = function(object) {
      geoStream(object, projectionStream(centroidStream$1));
      return centroidStream$1.result();
    };

    path.projection = function(_) {
      return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
    };

    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path;
    };

    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };

    return path.projection(projection).context(context);
  }

  function transform(methods) {
    return {
      stream: transformer(methods)
    };
  }

  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream;
      for (var key in methods) s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }

  function TransformStream() {}

  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x, y) { this.stream.point(x, y); },
    sphere: function() { this.stream.sphere(); },
    lineStart: function() { this.stream.lineStart(); },
    lineEnd: function() { this.stream.lineEnd(); },
    polygonStart: function() { this.stream.polygonStart(); },
    polygonEnd: function() { this.stream.polygonEnd(); }
  };

  function fit(projection, fitBounds, object) {
    var clip = projection.clipExtent && projection.clipExtent();
    projection.scale(150).translate([0, 0]);
    if (clip != null) projection.clipExtent(null);
    geoStream(object, projection.stream(boundsStream$1));
    fitBounds(boundsStream$1.result());
    if (clip != null) projection.clipExtent(clip);
    return projection;
  }

  function fitExtent(projection, extent, object) {
    return fit(projection, function(b) {
      var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitSize(projection, size, object) {
    return fitExtent(projection, [[0, 0], size], object);
  }

  function fitWidth(projection, width, object) {
    return fit(projection, function(b) {
      var w = +width,
          k = w / (b[1][0] - b[0][0]),
          x = (w - k * (b[1][0] + b[0][0])) / 2,
          y = -k * b[0][1];
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitHeight(projection, height, object) {
    return fit(projection, function(b) {
      var h = +height,
          k = h / (b[1][1] - b[0][1]),
          x = -k * b[0][0],
          y = (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  var maxDepth = 16, // maximum depth of subdivision
      cosMinDistance = cos$1(30 * radians$1); // cos(minimum angular distance)

  function resample(project, delta2) {
    return +delta2 ? resample$1(project, delta2) : resampleNone(project);
  }

  function resampleNone(project) {
    return transformer({
      point: function(x, y) {
        x = project(x, y);
        this.stream.point(x[0], x[1]);
      }
    });
  }

  function resample$1(project, delta2) {

    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0,
          dy = y1 - y0,
          d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a = a0 + a1,
            b = b0 + b1,
            c = c0 + c1,
            m = sqrt(a * a + b * b + c * c),
            phi2 = asin(c /= m),
            lambda2 = abs$2(abs$2(c) - 1) < epsilon$4 || abs$2(lambda0 - lambda1) < epsilon$4 ? (lambda0 + lambda1) / 2 : atan2(b, a),
            p = project(lambda2, phi2),
            x2 = p[0],
            y2 = p[1],
            dx2 = x2 - x0,
            dy2 = y2 - y0,
            dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 // perpendicular projected distance
            || abs$2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
            || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x00, y00, a00, b00, c00, // first point
          lambda0, x0, y0, a0, b0, c0; // previous point

      var resampleStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
        polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
      };

      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }

      function lineStart() {
        x0 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }

      function linePoint(lambda, phi) {
        var c = cartesian([lambda, phi]), p = project(lambda, phi);
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }

      function lineEnd() {
        resampleStream.point = point;
        stream.lineEnd();
      }

      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }

      function ringPoint(lambda, phi) {
        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }

      function ringEnd() {
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }

      return resampleStream;
    };
  }

  var transformRadians = transformer({
    point: function(x, y) {
      this.stream.point(x * radians$1, y * radians$1);
    }
  });

  function transformRotate(rotate) {
    return transformer({
      point: function(x, y) {
        var r = rotate(x, y);
        return this.stream.point(r[0], r[1]);
      }
    });
  }

  function scaleTranslate(k, dx, dy, sx, sy) {
    function transform(x, y) {
      x *= sx; y *= sy;
      return [dx + k * x, dy - k * y];
    }
    transform.invert = function(x, y) {
      return [(x - dx) / k * sx, (dy - y) / k * sy];
    };
    return transform;
  }

  function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
    if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
    var cosAlpha = cos$1(alpha),
        sinAlpha = sin$1(alpha),
        a = cosAlpha * k,
        b = sinAlpha * k,
        ai = cosAlpha / k,
        bi = sinAlpha / k,
        ci = (sinAlpha * dy - cosAlpha * dx) / k,
        fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x, y) {
      x *= sx; y *= sy;
      return [a * x - b * y + dx, dy - b * x - a * y];
    }
    transform.invert = function(x, y) {
      return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
    };
    return transform;
  }

  function projection(project) {
    return projectionMutator(function() { return project; })();
  }

  function projectionMutator(projectAt) {
    var project,
        k = 150, // scale
        x = 480, y = 250, // translate
        lambda = 0, phi = 0, // center
        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
        alpha = 0, // post-rotate angle
        sx = 1, // reflectX
        sy = 1, // reflectX
        theta = null, preclip = clipAntimeridian, // pre-clip angle
        x0 = null, y0, x1, y1, postclip = identity$4, // post-clip extent
        delta2 = 0.5, // precision
        projectResample,
        projectTransform,
        projectRotateTransform,
        cache,
        cacheStream;

    function projection(point) {
      return projectRotateTransform(point[0] * radians$1, point[1] * radians$1);
    }

    function invert(point) {
      point = projectRotateTransform.invert(point[0], point[1]);
      return point && [point[0] * degrees$2, point[1] * degrees$2];
    }

    projection.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };

    projection.preclip = function(_) {
      return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
    };

    projection.postclip = function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };

    projection.clipAngle = function(_) {
      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians$1) : (theta = null, clipAntimeridian), reset()) : theta * degrees$2;
    };

    projection.clipExtent = function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    projection.scale = function(_) {
      return arguments.length ? (k = +_, recenter()) : k;
    };

    projection.translate = function(_) {
      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
    };

    projection.center = function(_) {
      return arguments.length ? (lambda = _[0] % 360 * radians$1, phi = _[1] % 360 * radians$1, recenter()) : [lambda * degrees$2, phi * degrees$2];
    };

    projection.rotate = function(_) {
      return arguments.length ? (deltaLambda = _[0] % 360 * radians$1, deltaPhi = _[1] % 360 * radians$1, deltaGamma = _.length > 2 ? _[2] % 360 * radians$1 : 0, recenter()) : [deltaLambda * degrees$2, deltaPhi * degrees$2, deltaGamma * degrees$2];
    };

    projection.angle = function(_) {
      return arguments.length ? (alpha = _ % 360 * radians$1, recenter()) : alpha * degrees$2;
    };

    projection.reflectX = function(_) {
      return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
    };

    projection.reflectY = function(_) {
      return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
    };

    projection.precision = function(_) {
      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
    };

    projection.fitExtent = function(extent, object) {
      return fitExtent(projection, extent, object);
    };

    projection.fitSize = function(size, object) {
      return fitSize(projection, size, object);
    };

    projection.fitWidth = function(width, object) {
      return fitWidth(projection, width, object);
    };

    projection.fitHeight = function(height, object) {
      return fitHeight(projection, height, object);
    };

    function recenter() {
      var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
          transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose(project, transform);
      projectRotateTransform = compose(rotate, projectTransform);
      projectResample = resample(projectTransform, delta2);
      return reset();
    }

    function reset() {
      cache = cacheStream = null;
      return projection;
    }

    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return recenter();
    };
  }

  function conicProjection(projectAt) {
    var phi0 = 0,
        phi1 = pi$3 / 3,
        m = projectionMutator(projectAt),
        p = m(phi0, phi1);

    p.parallels = function(_) {
      return arguments.length ? m(phi0 = _[0] * radians$1, phi1 = _[1] * radians$1) : [phi0 * degrees$2, phi1 * degrees$2];
    };

    return p;
  }

  function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = cos$1(phi0);

    function forward(lambda, phi) {
      return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
    }

    forward.invert = function(x, y) {
      return [x / cosPhi0, asin(y * cosPhi0)];
    };

    return forward;
  }

  function conicEqualAreaRaw(y0, y1) {
    var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

    // Are the parallels symmetrical around the Equator?
    if (abs$2(n) < epsilon$4) return cylindricalEqualAreaRaw(y0);

    var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

    function project(x, y) {
      var r = sqrt(c - 2 * n * sin$1(y)) / n;
      return [r * sin$1(x *= n), r0 - r * cos$1(x)];
    }

    project.invert = function(x, y) {
      var r0y = r0 - y,
          l = atan2(x, abs$2(r0y)) * sign(r0y);
      if (r0y * n < 0)
        l -= pi$3 * sign(x) * sign(r0y);
      return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
    };

    return project;
  }

  function conicEqualArea() {
    return conicProjection(conicEqualAreaRaw)
        .scale(155.424)
        .center([0, 33.6442]);
  }

  function albers() {
    return conicEqualArea()
        .parallels([29.5, 45.5])
        .scale(1070)
        .translate([480, 250])
        .rotate([96, 0])
        .center([-0.6, 38.7]);
  }

  // The projections must have mutually exclusive clip regions on the sphere,
  // as this will avoid emitting interleaving lines and polygons.
  function multiplex(streams) {
    var n = streams.length;
    return {
      point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
      sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
      lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
      lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
      polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
      polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
    };
  }

  // A composite projection for the United States, configured by default for
  // 960×500. The projection also works quite well at 960×600 if you change the
  // scale to 1285 and adjust the translate accordingly. The set of standard
  // parallels for each region comes from USGS, which is published here:
  // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
  function albersUsa() {
    var cache,
        cacheStream,
        lower48 = albers(), lower48Point,
        alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
        point, pointStream = {point: function(x, y) { point = [x, y]; }};

    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      return point = null,
          (lower48Point.point(x, y), point)
          || (alaskaPoint.point(x, y), point)
          || (hawaiiPoint.point(x, y), point);
    }

    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(),
          t = lower48.translate(),
          x = (coordinates[0] - t[0]) / k,
          y = (coordinates[1] - t[1]) / k;
      return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
          : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
          : lower48).invert(coordinates);
    };

    albersUsa.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };

    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_), alaska.precision(_), hawaii.precision(_);
      return reset();
    };

    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };

    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];

      lower48Point = lower48
          .translate(_)
          .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
          .stream(pointStream);

      alaskaPoint = alaska
          .translate([x - 0.307 * k, y + 0.201 * k])
          .clipExtent([[x - 0.425 * k + epsilon$4, y + 0.120 * k + epsilon$4], [x - 0.214 * k - epsilon$4, y + 0.234 * k - epsilon$4]])
          .stream(pointStream);

      hawaiiPoint = hawaii
          .translate([x - 0.205 * k, y + 0.212 * k])
          .clipExtent([[x - 0.214 * k + epsilon$4, y + 0.166 * k + epsilon$4], [x - 0.115 * k - epsilon$4, y + 0.234 * k - epsilon$4]])
          .stream(pointStream);

      return reset();
    };

    albersUsa.fitExtent = function(extent, object) {
      return fitExtent(albersUsa, extent, object);
    };

    albersUsa.fitSize = function(size, object) {
      return fitSize(albersUsa, size, object);
    };

    albersUsa.fitWidth = function(width, object) {
      return fitWidth(albersUsa, width, object);
    };

    albersUsa.fitHeight = function(height, object) {
      return fitHeight(albersUsa, height, object);
    };

    function reset() {
      cache = cacheStream = null;
      return albersUsa;
    }

    return albersUsa.scale(1070);
  }

  function azimuthalRaw(scale) {
    return function(x, y) {
      var cx = cos$1(x),
          cy = cos$1(y),
          k = scale(cx * cy);
          if (k === Infinity) return [2, 0];
      return [
        k * cy * sin$1(x),
        k * sin$1(y)
      ];
    }
  }

  function azimuthalInvert(angle) {
    return function(x, y) {
      var z = sqrt(x * x + y * y),
          c = angle(z),
          sc = sin$1(c),
          cc = cos$1(c);
      return [
        atan2(x * sc, z * cc),
        asin(z && y * sc / z)
      ];
    }
  }

  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });

  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin(z / 2);
  });

  function azimuthalEqualArea() {
    return projection(azimuthalEqualAreaRaw)
        .scale(124.75)
        .clipAngle(180 - 1e-3);
  }

  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin$1(c);
  });

  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });

  function azimuthalEquidistant() {
    return projection(azimuthalEquidistantRaw)
        .scale(79.4188)
        .clipAngle(180 - 1e-3);
  }

  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi$2 + phi) / 2))];
  }

  mercatorRaw.invert = function(x, y) {
    return [x, 2 * atan(exp(y)) - halfPi$2];
  };

  function mercator() {
    return mercatorProjection(mercatorRaw)
        .scale(961 / tau$4);
  }

  function mercatorProjection(project) {
    var m = projection(project),
        center = m.center,
        scale = m.scale,
        translate = m.translate,
        clipExtent = m.clipExtent,
        x0 = null, y0, x1, y1; // clip extent

    m.scale = function(_) {
      return arguments.length ? (scale(_), reclip()) : scale();
    };

    m.translate = function(_) {
      return arguments.length ? (translate(_), reclip()) : translate();
    };

    m.center = function(_) {
      return arguments.length ? (center(_), reclip()) : center();
    };

    m.clipExtent = function(_) {
      return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    function reclip() {
      var k = pi$3 * scale(),
          t = m(rotation(m.rotate()).invert([0, 0]));
      return clipExtent(x0 == null
          ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
          ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
          : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
    }

    return reclip();
  }

  function tany(y) {
    return tan((halfPi$2 + y) / 2);
  }

  function conicConformalRaw(y0, y1) {
    var cy0 = cos$1(y0),
        n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
        f = cy0 * pow$1(tany(y0), n) / n;

    if (!n) return mercatorRaw;

    function project(x, y) {
      if (f > 0) { if (y < -halfPi$2 + epsilon$4) y = -halfPi$2 + epsilon$4; }
      else { if (y > halfPi$2 - epsilon$4) y = halfPi$2 - epsilon$4; }
      var r = f / pow$1(tany(y), n);
      return [r * sin$1(n * x), f - r * cos$1(n * x)];
    }

    project.invert = function(x, y) {
      var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy),
        l = atan2(x, abs$2(fy)) * sign(fy);
      if (fy * n < 0)
        l -= pi$3 * sign(x) * sign(fy);
      return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$2];
    };

    return project;
  }

  function conicConformal() {
    return conicProjection(conicConformalRaw)
        .scale(109.5)
        .parallels([30, 30]);
  }

  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }

  equirectangularRaw.invert = equirectangularRaw;

  function equirectangular() {
    return projection(equirectangularRaw)
        .scale(152.63);
  }

  function conicEquidistantRaw(y0, y1) {
    var cy0 = cos$1(y0),
        n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
        g = cy0 / n + y0;

    if (abs$2(n) < epsilon$4) return equirectangularRaw;

    function project(x, y) {
      var gy = g - y, nx = n * x;
      return [gy * sin$1(nx), g - gy * cos$1(nx)];
    }

    project.invert = function(x, y) {
      var gy = g - y,
          l = atan2(x, abs$2(gy)) * sign(gy);
      if (gy * n < 0)
        l -= pi$3 * sign(x) * sign(gy);
      return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
    };

    return project;
  }

  function conicEquidistant() {
    return conicProjection(conicEquidistantRaw)
        .scale(131.154)
        .center([0, 13.9389]);
  }

  var A1 = 1.340264,
      A2 = -0.081106,
      A3 = 0.000893,
      A4 = 0.003796,
      M = sqrt(3) / 2,
      iterations = 12;

  function equalEarthRaw(lambda, phi) {
    var l = asin(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
    return [
      lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
      l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
    ];
  }

  equalEarthRaw.invert = function(x, y) {
    var l = y, l2 = l * l, l6 = l2 * l2 * l2;
    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
      fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
      fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
      l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
      if (abs$2(delta) < epsilon2$1) break;
    }
    return [
      M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
      asin(sin$1(l) / M)
    ];
  };

  function equalEarth() {
    return projection(equalEarthRaw)
        .scale(177.158);
  }

  function gnomonicRaw(x, y) {
    var cy = cos$1(y), k = cos$1(x) * cy;
    return [cy * sin$1(x) / k, sin$1(y) / k];
  }

  gnomonicRaw.invert = azimuthalInvert(atan);

  function gnomonic() {
    return projection(gnomonicRaw)
        .scale(144.049)
        .clipAngle(60);
  }

  function identity$5() {
    var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
        alpha = 0, ca, sa, // angle
        x0 = null, y0, x1, y1, // clip extent
        kx = 1, ky = 1,
        transform = transformer({
          point: function(x, y) {
            var p = projection([x, y]);
            this.stream.point(p[0], p[1]);
          }
        }),
        postclip = identity$4,
        cache,
        cacheStream;

    function reset() {
      kx = k * sx;
      ky = k * sy;
      cache = cacheStream = null;
      return projection;
    }

    function projection (p) {
      var x = p[0] * kx, y = p[1] * ky;
      if (alpha) {
        var t = y * ca - x * sa;
        x = x * ca + y * sa;
        y = t;
      }    
      return [x + tx, y + ty];
    }
    projection.invert = function(p) {
      var x = p[0] - tx, y = p[1] - ty;
      if (alpha) {
        var t = y * ca + x * sa;
        x = x * ca - y * sa;
        y = t;
      }
      return [x / kx, y / ky];
    };
    projection.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    };
    projection.postclip = function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };
    projection.clipExtent = function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };
    projection.scale = function(_) {
      return arguments.length ? (k = +_, reset()) : k;
    };
    projection.translate = function(_) {
      return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
    };
    projection.angle = function(_) {
      return arguments.length ? (alpha = _ % 360 * radians$1, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees$2;
    };
    projection.reflectX = function(_) {
      return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
    };
    projection.reflectY = function(_) {
      return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
    };
    projection.fitExtent = function(extent, object) {
      return fitExtent(projection, extent, object);
    };
    projection.fitSize = function(size, object) {
      return fitSize(projection, size, object);
    };
    projection.fitWidth = function(width, object) {
      return fitWidth(projection, width, object);
    };
    projection.fitHeight = function(height, object) {
      return fitHeight(projection, height, object);
    };

    return projection;
  }

  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
    ];
  }

  naturalEarth1Raw.invert = function(x, y) {
    var phi = y, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
          (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
    } while (abs$2(delta) > epsilon$4 && --i > 0);
    return [
      x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
      phi
    ];
  };

  function naturalEarth1() {
    return projection(naturalEarth1Raw)
        .scale(175.295);
  }

  function orthographicRaw(x, y) {
    return [cos$1(y) * sin$1(x), sin$1(y)];
  }

  orthographicRaw.invert = azimuthalInvert(asin);

  function orthographic() {
    return projection(orthographicRaw)
        .scale(249.5)
        .clipAngle(90 + epsilon$4);
  }

  function stereographicRaw(x, y) {
    var cy = cos$1(y), k = 1 + cos$1(x) * cy;
    return [cy * sin$1(x) / k, sin$1(y) / k];
  }

  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });

  function stereographic() {
    return projection(stereographicRaw)
        .scale(250)
        .clipAngle(142);
  }

  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi$2 + phi) / 2)), -lambda];
  }

  transverseMercatorRaw.invert = function(x, y) {
    return [-y, 2 * atan(exp(x)) - halfPi$2];
  };

  function transverseMercator() {
    var m = mercatorProjection(transverseMercatorRaw),
        center = m.center,
        rotate = m.rotate;

    m.center = function(_) {
      return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
    };

    m.rotate = function(_) {
      return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
    };

    return rotate([0, 0, 90])
        .scale(159.155);
  }

  function defaultSeparation(a, b) {
    return a.parent === b.parent ? 1 : 2;
  }

  function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
  }

  function meanXReduce(x, c) {
    return x + c.x;
  }

  function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
  }

  function maxYReduce(y, c) {
    return Math.max(y, c.y);
  }

  function leafLeft(node) {
    var children;
    while (children = node.children) node = children[0];
    return node;
  }

  function leafRight(node) {
    var children;
    while (children = node.children) node = children[children.length - 1];
    return node;
  }

  function cluster() {
    var separation = defaultSeparation,
        dx = 1,
        dy = 1,
        nodeSize = false;

    function cluster(root) {
      var previousNode,
          x = 0;

      // First walk, computing the initial x & y values.
      root.eachAfter(function(node) {
        var children = node.children;
        if (children) {
          node.x = meanX(children);
          node.y = maxY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });

      var left = leafLeft(root),
          right = leafRight(root),
          x0 = left.x - separation(left, right) / 2,
          x1 = right.x + separation(right, left) / 2;

      // Second walk, normalizing x & y to the desired size.
      return root.eachAfter(nodeSize ? function(node) {
        node.x = (node.x - root.x) * dx;
        node.y = (root.y - node.y) * dy;
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * dx;
        node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
      });
    }

    cluster.separation = function(x) {
      return arguments.length ? (separation = x, cluster) : separation;
    };

    cluster.size = function(x) {
      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
    };

    cluster.nodeSize = function(x) {
      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
    };

    return cluster;
  }

  function count$1(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;
    else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  function node_count() {
    return this.eachAfter(count$1);
  }

  function node_each(callback, that) {
    let index = -1;
    for (const node of this) {
      callback.call(that, node, ++index, this);
    }
    return this;
  }

  function node_eachBefore(callback, that) {
    var node = this, nodes = [node], children, i, index = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index, this);
      if (children = node.children) {
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
    }
    return this;
  }

  function node_eachAfter(callback, that) {
    var node = this, nodes = [node], next = [], children, i, n, index = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index, this);
    }
    return this;
  }

  function node_find(callback, that) {
    let index = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index, this)) {
        return node;
      }
    }
  }

  function node_sum(value) {
    return this.eachAfter(function(node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path(end) {
    var start = this,
        ancestor = leastCommonAncestor(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }

  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants() {
    return Array.from(this);
  }

  function node_leaves() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links() {
    var root = this, links = [];
    root.each(function(node) {
      if (node !== root) { // Don’t include the root’s parent, if any.
        links.push({source: node.parent, target: node});
      }
    });
    return links;
  }

  function* node_iterator() {
    var node = this, current, next = [node], children, i, n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        yield node;
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
        }
      }
    } while (next.length);
  }

  function hierarchy(data, children) {
    if (data instanceof Map) {
      data = [undefined, data];
      if (children === undefined) children = mapChildren;
    } else if (children === undefined) {
      children = objectChildren;
    }

    var root = new Node(data),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    while (node = nodes.pop()) {
      if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight);
  }

  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }

  function objectChildren(d) {
    return d.children;
  }

  function mapChildren(d) {
    return Array.isArray(d) ? d[1] : null;
  }

  function copyData(node) {
    if (node.data.value !== undefined) node.value = node.data.value;
    node.data = node.data.data;
  }

  function computeHeight(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && (node.height < ++height));
  }

  function Node(data) {
    this.data = data;
    this.depth =
    this.height = 0;
    this.parent = null;
  }

  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    find: node_find,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy,
    [Symbol.iterator]: node_iterator
  };

  function array$4(x) {
    return typeof x === "object" && "length" in x
      ? x // Array, TypedArray, NodeList, array-like
      : Array.from(x); // Map, Set, iterable, string, or anything else
  }

  function shuffle$1(array) {
    var m = array.length,
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }

    return array;
  }

  function enclose(circles) {
    var i = 0, n = (circles = shuffle$1(Array.from(circles))).length, B = [], p, e;

    while (i < n) {
      p = circles[i];
      if (e && enclosesWeak(e, p)) ++i;
      else e = encloseBasis(B = extendBasis(B, p)), i = 0;
    }

    return e;
  }

  function extendBasis(B, p) {
    var i, j;

    if (enclosesWeakAll(p, B)) return [p];

    // If we get here then B must have at least one element.
    for (i = 0; i < B.length; ++i) {
      if (enclosesNot(p, B[i])
          && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
        return [B[i], p];
      }
    }

    // If we get here then B must have at least two elements.
    for (i = 0; i < B.length - 1; ++i) {
      for (j = i + 1; j < B.length; ++j) {
        if (enclosesNot(encloseBasis2(B[i], B[j]), p)
            && enclosesNot(encloseBasis2(B[i], p), B[j])
            && enclosesNot(encloseBasis2(B[j], p), B[i])
            && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
          return [B[i], B[j], p];
        }
      }
    }

    // If we get here then something is very wrong.
    throw new Error;
  }

  function enclosesNot(a, b) {
    var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }

  function enclosesWeak(a, b) {
    var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function enclosesWeakAll(a, B) {
    for (var i = 0; i < B.length; ++i) {
      if (!enclosesWeak(a, B[i])) {
        return false;
      }
    }
    return true;
  }

  function encloseBasis(B) {
    switch (B.length) {
      case 1: return encloseBasis1(B[0]);
      case 2: return encloseBasis2(B[0], B[1]);
      case 3: return encloseBasis3(B[0], B[1], B[2]);
    }
  }

  function encloseBasis1(a) {
    return {
      x: a.x,
      y: a.y,
      r: a.r
    };
  }

  function encloseBasis2(a, b) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
        l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x1 + x2 + x21 / l * r21) / 2,
      y: (y1 + y2 + y21 / l * r21) / 2,
      r: (l + r1 + r2) / 2
    };
  }

  function encloseBasis3(a, b, c) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x3 = c.x, y3 = c.y, r3 = c.r,
        a2 = x1 - x2,
        a3 = x1 - x3,
        b2 = y1 - y2,
        b3 = y1 - y3,
        c2 = r2 - r1,
        c3 = r3 - r1,
        d1 = x1 * x1 + y1 * y1 - r1 * r1,
        d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
        d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
        ab = a3 * b2 - a2 * b3,
        xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
        xb = (b3 * c2 - b2 * c3) / ab,
        ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
        yb = (a2 * c3 - a3 * c2) / ab,
        A = xb * xb + yb * yb - 1,
        B = 2 * (r1 + xa * xb + ya * yb),
        C = xa * xa + ya * ya - r1 * r1,
        r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
    return {
      x: x1 + xa + xb * r,
      y: y1 + ya + yb * r,
      r: r
    };
  }

  function place(b, a, c) {
    var dx = b.x - a.x, x, a2,
        dy = b.y - a.y, y, b2,
        d2 = dx * dx + dy * dy;
    if (d2) {
      a2 = a.r + c.r, a2 *= a2;
      b2 = b.r + c.r, b2 *= b2;
      if (a2 > b2) {
        x = (d2 + b2 - a2) / (2 * d2);
        y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
        c.x = b.x - x * dx - y * dy;
        c.y = b.y - x * dy + y * dx;
      } else {
        x = (d2 + a2 - b2) / (2 * d2);
        y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
        c.x = a.x + x * dx - y * dy;
        c.y = a.y + x * dy + y * dx;
      }
    } else {
      c.x = a.x + c.r;
      c.y = a.y;
    }
  }

  function intersects(a, b) {
    var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function score(node) {
    var a = node._,
        b = node.next._,
        ab = a.r + b.r,
        dx = (a.x * b.r + b.x * a.r) / ab,
        dy = (a.y * b.r + b.y * a.r) / ab;
    return dx * dx + dy * dy;
  }

  function Node$1(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
  }

  function packEnclose(circles) {
    if (!(n = (circles = array$4(circles)).length)) return 0;

    var a, b, c, n, aa, ca, i, j, k, sj, sk;

    // Place the first circle.
    a = circles[0], a.x = 0, a.y = 0;
    if (!(n > 1)) return a.r;

    // Place the second circle.
    b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
    if (!(n > 2)) return a.r + b.r;

    // Place the third circle.
    place(b, a, c = circles[2]);

    // Initialize the front-chain using the first three circles a, b and c.
    a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
    a.next = c.previous = b;
    b.next = a.previous = c;
    c.next = b.previous = a;

    // Attempt to place each remaining circle…
    pack: for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node$1(c);

      // Find the closest intersecting circle on the front-chain, if any.
      // “Closeness” is determined by linear distance along the front-chain.
      // “Ahead” or “behind” is likewise determined by linear distance.
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);

      // Success! Insert the new circle c between a and b.
      c.previous = a, c.next = b, a.next = b.previous = b = c;

      // Compute the new closest circle pair to the centroid.
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }

    // Compute the enclosing circle of the front chain.
    a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

    // Translate the circles to put the enclosing circle around the origin.
    for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

    return c.r;
  }

  function siblings(circles) {
    packEnclose(circles);
    return circles;
  }

  function optional(f) {
    return f == null ? null : required(f);
  }

  function required(f) {
    if (typeof f !== "function") throw new Error;
    return f;
  }

  function constantZero() {
    return 0;
  }

  function constant$9(x) {
    return function() {
      return x;
    };
  }

  function defaultRadius$1(d) {
    return Math.sqrt(d.value);
  }

  function index$3() {
    var radius = null,
        dx = 1,
        dy = 1,
        padding = constantZero;

    function pack(root) {
      root.x = dx / 2, root.y = dy / 2;
      if (radius) {
        root.eachBefore(radiusLeaf(radius))
            .eachAfter(packChildren(padding, 0.5))
            .eachBefore(translateChild(1));
      } else {
        root.eachBefore(radiusLeaf(defaultRadius$1))
            .eachAfter(packChildren(constantZero, 1))
            .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
            .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
      }
      return root;
    }

    pack.radius = function(x) {
      return arguments.length ? (radius = optional(x), pack) : radius;
    };

    pack.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
    };

    pack.padding = function(x) {
      return arguments.length ? (padding = typeof x === "function" ? x : constant$9(+x), pack) : padding;
    };

    return pack;
  }

  function radiusLeaf(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }

  function packChildren(padding, k) {
    return function(node) {
      if (children = node.children) {
        var children,
            i,
            n = children.length,
            r = padding(node) * k || 0,
            e;

        if (r) for (i = 0; i < n; ++i) children[i].r += r;
        e = packEnclose(children);
        if (r) for (i = 0; i < n; ++i) children[i].r -= r;
        node.r = e + r;
      }
    };
  }

  function translateChild(k) {
    return function(node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  function roundNode(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  function treemapDice(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (x1 - x0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  }

  function partition() {
    var dx = 1,
        dy = 1,
        padding = 0,
        round = false;

    function partition(root) {
      var n = root.height + 1;
      root.x0 =
      root.y0 = padding;
      root.x1 = dx;
      root.y1 = dy / n;
      root.eachBefore(positionNode(dy, n));
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(dy, n) {
      return function(node) {
        if (node.children) {
          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
        }
        var x0 = node.x0,
            y0 = node.y0,
            x1 = node.x1 - padding,
            y1 = node.y1 - padding;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
      };
    }

    partition.round = function(x) {
      return arguments.length ? (round = !!x, partition) : round;
    };

    partition.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
    };

    partition.padding = function(x) {
      return arguments.length ? (padding = +x, partition) : padding;
    };

    return partition;
  }

  var preroot = {depth: -1},
      ambiguous = {};

  function defaultId(d) {
    return d.id;
  }

  function defaultParentId(d) {
    return d.parentId;
  }

  function stratify() {
    var id = defaultId,
        parentId = defaultParentId;

    function stratify(data) {
      var nodes = Array.from(data),
          n = nodes.length,
          d,
          i,
          root,
          parent,
          node,
          nodeId,
          nodeKey,
          nodeByKey = new Map;

      for (i = 0; i < n; ++i) {
        d = nodes[i], node = nodes[i] = new Node(d);
        if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        } else {
          if (root) throw new Error("multiple roots");
          root = node;
        }
      }

      if (!root) throw new Error("no root");
      root.parent = preroot;
      root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
      root.parent = null;
      if (n > 0) throw new Error("cycle");

      return root;
    }

    stratify.id = function(x) {
      return arguments.length ? (id = required(x), stratify) : id;
    };

    stratify.parentId = function(x) {
      return arguments.length ? (parentId = required(x), stratify) : parentId;
    };

    return stratify;
  }

  function defaultSeparation$1(a, b) {
    return a.parent === b.parent ? 1 : 2;
  }

  // function radialSeparation(a, b) {
  //   return (a.parent === b.parent ? 1 : 2) / a.depth;
  // }

  // This function is used to traverse the left contour of a subtree (or
  // subforest). It returns the successor of v on this contour. This successor is
  // either given by the leftmost child of v or by the thread of v. The function
  // returns null if and only if v is on the highest level of its subtree.
  function nextLeft(v) {
    var children = v.children;
    return children ? children[0] : v.t;
  }

  // This function works analogously to nextLeft.
  function nextRight(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
  }

  // Shifts the current subtree rooted at w+. This is done by increasing
  // prelim(w+) and mod(w+) by shift.
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }

  // All other shifts, applied to the smaller subtrees between w- and w+, are
  // performed by this function. To prepare the shifts, we have to adjust
  // change(w+), shift(w+), and change(w-).
  function executeShifts(v) {
    var shift = 0,
        change = 0,
        children = v.children,
        i = children.length,
        w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }

  // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
  // returns the specified (default) ancestor.
  function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }

  function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null; // default ancestor
    this.a = this; // ancestor
    this.z = 0; // prelim
    this.m = 0; // mod
    this.c = 0; // change
    this.s = 0; // shift
    this.t = null; // thread
    this.i = i; // number
  }

  TreeNode.prototype = Object.create(Node.prototype);

  function treeRoot(root) {
    var tree = new TreeNode(root, 0),
        node,
        nodes = [tree],
        child,
        children,
        i,
        n;

    while (node = nodes.pop()) {
      if (children = node._.children) {
        node.children = new Array(n = children.length);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new TreeNode(children[i], i));
          child.parent = node;
        }
      }
    }

    (tree.parent = new TreeNode(null, 0)).children = [tree];
    return tree;
  }

  // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
  function tree() {
    var separation = defaultSeparation$1,
        dx = 1,
        dy = 1,
        nodeSize = null;

    function tree(root) {
      var t = treeRoot(root);

      // Compute the layout using Buchheim et al.’s algorithm.
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);

      // If a fixed node size is specified, scale x and y.
      if (nodeSize) root.eachBefore(sizeNode);

      // If a fixed tree size is specified, scale x and y based on the extent.
      // Compute the left-most, right-most, and depth-most nodes for extents.
      else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }

      return root;
    }

    // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
    // applied recursively to the children of v, as well as the function
    // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
    // node v is placed to the midpoint of its outermost children.
    function firstWalk(v) {
      var children = v.children,
          siblings = v.parent.children,
          w = v.i ? siblings[v.i - 1] : null;
      if (children) {
        executeShifts(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }

    // Computes all real x-coordinates by summing up the modifiers recursively.
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }

    // The core of the algorithm. Here, a new subtree is combined with the
    // previous subtrees. Threads are used to traverse the inside and outside
    // contours of the left and right subtree up to the highest common level. The
    // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
    // superscript o means outside and i means inside, the subscript - means left
    // subtree and + means right subtree. For summing up the modifiers along the
    // contour, we use respective variables si+, si-, so-, and so+. Whenever two
    // nodes of the inside contours conflict, we compute the left one of the
    // greatest uncommon ancestors using the function ANCESTOR and call MOVE
    // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
    // Finally, we add a new thread (if necessary).
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v,
            vop = v,
            vim = w,
            vom = vip.parent.children[0],
            sip = vip.m,
            sop = vop.m,
            sim = vim.m,
            som = vom.m,
            shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }

    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }

    tree.separation = function(x) {
      return arguments.length ? (separation = x, tree) : separation;
    };

    tree.size = function(x) {
      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
    };

    tree.nodeSize = function(x) {
      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
    };

    return tree;
  }

  function treemapSlice(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (y1 - y0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.x0 = x0, node.x1 = x1;
      node.y0 = y0, node.y1 = y0 += node.value * k;
    }
  }

  var phi = (1 + Math.sqrt(5)) / 2;

  function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
    var rows = [],
        nodes = parent.children,
        row,
        nodeValue,
        i0 = 0,
        i1 = 0,
        n = nodes.length,
        dx, dy,
        value = parent.value,
        sumValue,
        minValue,
        maxValue,
        newRatio,
        minRatio,
        alpha,
        beta;

    while (i0 < n) {
      dx = x1 - x0, dy = y1 - y0;

      // Find the next non-empty node.
      do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);

      // Keep adding nodes while the aspect ratio maintains or improves.
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) { sumValue -= nodeValue; break; }
        minRatio = newRatio;
      }

      // Position and record the row orientation.
      rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
      else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
      value -= sumValue, i0 = i1;
    }

    return rows;
  }

  var squarify = (function custom(ratio) {

    function squarify(parent, x0, y0, x1, y1) {
      squarifyRatio(ratio, parent, x0, y0, x1, y1);
    }

    squarify.ratio = function(x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return squarify;
  })(phi);

  function index$4() {
    var tile = squarify,
        round = false,
        dx = 1,
        dy = 1,
        paddingStack = [0],
        paddingInner = constantZero,
        paddingTop = constantZero,
        paddingRight = constantZero,
        paddingBottom = constantZero,
        paddingLeft = constantZero;

    function treemap(root) {
      root.x0 =
      root.y0 = 0;
      root.x1 = dx;
      root.y1 = dy;
      root.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(node) {
      var p = paddingStack[node.depth],
          x0 = node.x0 + p,
          y0 = node.y0 + p,
          x1 = node.x1 - p,
          y1 = node.y1 - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x0 += paddingLeft(node) - p;
        y0 += paddingTop(node) - p;
        x1 -= paddingRight(node) - p;
        y1 -= paddingBottom(node) - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        tile(node, x0, y0, x1, y1);
      }
    }

    treemap.round = function(x) {
      return arguments.length ? (round = !!x, treemap) : round;
    };

    treemap.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
    };

    treemap.tile = function(x) {
      return arguments.length ? (tile = required(x), treemap) : tile;
    };

    treemap.padding = function(x) {
      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };

    treemap.paddingInner = function(x) {
      return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$9(+x), treemap) : paddingInner;
    };

    treemap.paddingOuter = function(x) {
      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };

    treemap.paddingTop = function(x) {
      return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$9(+x), treemap) : paddingTop;
    };

    treemap.paddingRight = function(x) {
      return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$9(+x), treemap) : paddingRight;
    };

    treemap.paddingBottom = function(x) {
      return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$9(+x), treemap) : paddingBottom;
    };

    treemap.paddingLeft = function(x) {
      return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$9(+x), treemap) : paddingLeft;
    };

    return treemap;
  }

  function binary(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        i, n = nodes.length,
        sum, sums = new Array(n + 1);

    for (sums[0] = sum = i = 0; i < n; ++i) {
      sums[i + 1] = sum += nodes[i].value;
    }

    partition(0, n, parent.value, x0, y0, x1, y1);

    function partition(i, j, value, x0, y0, x1, y1) {
      if (i >= j - 1) {
        var node = nodes[i];
        node.x0 = x0, node.y0 = y0;
        node.x1 = x1, node.y1 = y1;
        return;
      }

      var valueOffset = sums[i],
          valueTarget = (value / 2) + valueOffset,
          k = i + 1,
          hi = j - 1;

      while (k < hi) {
        var mid = k + hi >>> 1;
        if (sums[mid] < valueTarget) k = mid + 1;
        else hi = mid;
      }

      if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

      var valueLeft = sums[k] - valueOffset,
          valueRight = value - valueLeft;

      if ((x1 - x0) > (y1 - y0)) {
        var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
        partition(i, k, valueLeft, x0, y0, xk, y1);
        partition(k, j, valueRight, xk, y0, x1, y1);
      } else {
        var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
        partition(i, k, valueLeft, x0, y0, x1, yk);
        partition(k, j, valueRight, x0, yk, x1, y1);
      }
    }
  }

  function sliceDice(parent, x0, y0, x1, y1) {
    (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
  }

  var resquarify = (function custom(ratio) {

    function resquarify(parent, x0, y0, x1, y1) {
      if ((rows = parent._squarify) && (rows.ratio === ratio)) {
        var rows,
            row,
            nodes,
            i,
            j = -1,
            n,
            m = rows.length,
            value = parent.value;

        while (++j < m) {
          row = rows[j], nodes = row.children;
          for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
          if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
          else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
          value -= row.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
        rows.ratio = ratio;
      }
    }

    resquarify.ratio = function(x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return resquarify;
  })(phi);

  function area$2(polygon) {
    var i = -1,
        n = polygon.length,
        a,
        b = polygon[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = polygon[i];
      area += a[1] * b[0] - a[0] * b[1];
    }

    return area / 2;
  }

  function centroid$1(polygon) {
    var i = -1,
        n = polygon.length,
        x = 0,
        y = 0,
        a,
        b = polygon[n - 1],
        c,
        k = 0;

    while (++i < n) {
      a = b;
      b = polygon[i];
      k += c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }

    return k *= 3, [x / k, y / k];
  }

  // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
  // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
  // right, +y is up). Returns a positive value if ABC is counter-clockwise,
  // negative if clockwise, and zero if the points are collinear.
  function cross$1(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }

  function lexicographicOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }

  // Computes the upper convex hull per the monotone chain algorithm.
  // Assumes points.length >= 3, is sorted by x, unique in y.
  // Returns an array of indices into points in left-to-right order.
  function computeUpperHullIndexes(points) {
    const n = points.length,
        indexes = [0, 1];
    let size = 2, i;

    for (i = 2; i < n; ++i) {
      while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
      indexes[size++] = i;
    }

    return indexes.slice(0, size); // remove popped points
  }

  function hull(points) {
    if ((n = points.length) < 3) return null;

    var i,
        n,
        sortedPoints = new Array(n),
        flippedPoints = new Array(n);

    for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

    var upperIndexes = computeUpperHullIndexes(sortedPoints),
        lowerIndexes = computeUpperHullIndexes(flippedPoints);

    // Construct the hull polygon, removing possible duplicate endpoints.
    var skipLeft = lowerIndexes[0] === upperIndexes[0],
        skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
        hull = [];

    // Add upper hull in right-to-l order.
    // Then add lower hull in left-to-right order.
    for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

    return hull;
  }

  function contains$2(polygon, point) {
    var n = polygon.length,
        p = polygon[n - 1],
        x = point[0], y = point[1],
        x0 = p[0], y0 = p[1],
        x1, y1,
        inside = false;

    for (var i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1];
      if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
      x0 = x1, y0 = y1;
    }

    return inside;
  }

  function length$3(polygon) {
    var i = -1,
        n = polygon.length,
        b = polygon[n - 1],
        xa,
        ya,
        xb = b[0],
        yb = b[1],
        perimeter = 0;

    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }

    return perimeter;
  }

  var defaultSource$1 = Math.random;

  var uniform = (function sourceRandomUniform(source) {
    function randomUniform(min, max) {
      min = min == null ? 0 : +min;
      max = max == null ? 1 : +max;
      if (arguments.length === 1) max = min, min = 0;
      else max -= min;
      return function() {
        return source() * max + min;
      };
    }

    randomUniform.source = sourceRandomUniform;

    return randomUniform;
  })(defaultSource$1);

  var int = (function sourceRandomInt(source) {
    function randomInt(min, max) {
      if (arguments.length < 2) max = min, min = 0;
      min = Math.floor(min);
      max = Math.floor(max) - min;
      return function() {
        return Math.floor(source() * max + min);
      };
    }

    randomInt.source = sourceRandomInt;

    return randomInt;
  })(defaultSource$1);

  var normal = (function sourceRandomNormal(source) {
    function randomNormal(mu, sigma) {
      var x, r;
      mu = mu == null ? 0 : +mu;
      sigma = sigma == null ? 1 : +sigma;
      return function() {
        var y;

        // If available, use the second previously-generated uniform random.
        if (x != null) y = x, x = null;

        // Otherwise, generate a new x and y.
        else do {
          x = source() * 2 - 1;
          y = source() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);

        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
      };
    }

    randomNormal.source = sourceRandomNormal;

    return randomNormal;
  })(defaultSource$1);

  var logNormal = (function sourceRandomLogNormal(source) {
    var N = normal.source(source);

    function randomLogNormal() {
      var randomNormal = N.apply(this, arguments);
      return function() {
        return Math.exp(randomNormal());
      };
    }

    randomLogNormal.source = sourceRandomLogNormal;

    return randomLogNormal;
  })(defaultSource$1);

  var irwinHall = (function sourceRandomIrwinHall(source) {
    function randomIrwinHall(n) {
      if ((n = +n) <= 0) return () => 0;
      return function() {
        for (var sum = 0, i = n; i > 1; --i) sum += source();
        return sum + i * source();
      };
    }

    randomIrwinHall.source = sourceRandomIrwinHall;

    return randomIrwinHall;
  })(defaultSource$1);

  var bates = (function sourceRandomBates(source) {
    var I = irwinHall.source(source);

    function randomBates(n) {
      // use limiting distribution at n === 0
      if ((n = +n) === 0) return source;
      var randomIrwinHall = I(n);
      return function() {
        return randomIrwinHall() / n;
      };
    }

    randomBates.source = sourceRandomBates;

    return randomBates;
  })(defaultSource$1);

  var exponential$1 = (function sourceRandomExponential(source) {
    function randomExponential(lambda) {
      return function() {
        return -Math.log1p(-source()) / lambda;
      };
    }

    randomExponential.source = sourceRandomExponential;

    return randomExponential;
  })(defaultSource$1);

  var pareto = (function sourceRandomPareto(source) {
    function randomPareto(alpha) {
      if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
      alpha = 1 / -alpha;
      return function() {
        return Math.pow(1 - source(), alpha);
      };
    }

    randomPareto.source = sourceRandomPareto;

    return randomPareto;
  })(defaultSource$1);

  var bernoulli = (function sourceRandomBernoulli(source) {
    function randomBernoulli(p) {
      if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
      return function() {
        return Math.floor(source() + p);
      };
    }

    randomBernoulli.source = sourceRandomBernoulli;

    return randomBernoulli;
  })(defaultSource$1);

  var geometric = (function sourceRandomGeometric(source) {
    function randomGeometric(p) {
      if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
      if (p === 0) return () => Infinity;
      if (p === 1) return () => 1;
      p = Math.log1p(-p);
      return function() {
        return 1 + Math.floor(Math.log1p(-source()) / p);
      };
    }

    randomGeometric.source = sourceRandomGeometric;

    return randomGeometric;
  })(defaultSource$1);

  var gamma$1 = (function sourceRandomGamma(source) {
    var randomNormal = normal.source(source)();

    function randomGamma(k, theta) {
      if ((k = +k) < 0) throw new RangeError("invalid k");
      // degenerate distribution if k === 0
      if (k === 0) return () => 0;
      theta = theta == null ? 1 : +theta;
      // exponential distribution if k === 1
      if (k === 1) return () => -Math.log1p(-source()) * theta;

      var d = (k < 1 ? k + 1 : k) - 1 / 3,
          c = 1 / (3 * Math.sqrt(d)),
          multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
      return function() {
        do {
          do {
            var x = randomNormal(),
                v = 1 + c * x;
          } while (v <= 0);
          v *= v * v;
          var u = 1 - source();
        } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
        return d * v * multiplier() * theta;
      };
    }

    randomGamma.source = sourceRandomGamma;

    return randomGamma;
  })(defaultSource$1);

  var beta = (function sourceRandomBeta(source) {
    var G = gamma$1.source(source);

    function randomBeta(alpha, beta) {
      var X = G(alpha),
          Y = G(beta);
      return function() {
        var x = X();
        return x === 0 ? 0 : x / (x + Y());
      };
    }

    randomBeta.source = sourceRandomBeta;

    return randomBeta;
  })(defaultSource$1);

  var binomial = (function sourceRandomBinomial(source) {
    var G = geometric.source(source),
        B = beta.source(source);

    function randomBinomial(n, p) {
      n = +n;
      if ((p = +p) >= 1) return () => n;
      if (p <= 0) return () => 0;
      return function() {
        var acc = 0, nn = n, pp = p;
        while (nn * pp > 16 && nn * (1 - pp) > 16) {
          var i = Math.floor((nn + 1) * pp),
              y = B(i, nn - i + 1)();
          if (y <= pp) {
            acc += i;
            nn -= i;
            pp = (pp - y) / (1 - y);
          } else {
            nn = i - 1;
            pp /= y;
          }
        }
        var sign = pp < 0.5,
            pFinal = sign ? pp : 1 - pp,
            g = G(pFinal);
        for (var s = g(), k = 0; s <= nn; ++k) s += g();
        return acc + (sign ? k : nn - k);
      };
    }

    randomBinomial.source = sourceRandomBinomial;

    return randomBinomial;
  })(defaultSource$1);

  var weibull = (function sourceRandomWeibull(source) {
    function randomWeibull(k, a, b) {
      var outerFunc;
      if ((k = +k) === 0) {
        outerFunc = x => -Math.log(x);
      } else {
        k = 1 / k;
        outerFunc = x => Math.pow(x, k);
      }
      a = a == null ? 0 : +a;
      b = b == null ? 1 : +b;
      return function() {
        return a + b * outerFunc(-Math.log1p(-source()));
      };
    }

    randomWeibull.source = sourceRandomWeibull;

    return randomWeibull;
  })(defaultSource$1);

  var cauchy = (function sourceRandomCauchy(source) {
    function randomCauchy(a, b) {
      a = a == null ? 0 : +a;
      b = b == null ? 1 : +b;
      return function() {
        return a + b * Math.tan(Math.PI * source());
      };
    }

    randomCauchy.source = sourceRandomCauchy;

    return randomCauchy;
  })(defaultSource$1);

  var logistic = (function sourceRandomLogistic(source) {
    function randomLogistic(a, b) {
      a = a == null ? 0 : +a;
      b = b == null ? 1 : +b;
      return function() {
        var u = source();
        return a + b * Math.log(u / (1 - u));
      };
    }

    randomLogistic.source = sourceRandomLogistic;

    return randomLogistic;
  })(defaultSource$1);

  var poisson = (function sourceRandomPoisson(source) {
    var G = gamma$1.source(source),
        B = binomial.source(source);

    function randomPoisson(lambda) {
      return function() {
        var acc = 0, l = lambda;
        while (l > 16) {
          var n = Math.floor(0.875 * l),
              t = G(n)();
          if (t > l) return acc + B(n - 1, l / t)();
          acc += n;
          l -= t;
        }
        for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
        return acc + k;
      };
    }

    randomPoisson.source = sourceRandomPoisson;

    return randomPoisson;
  })(defaultSource$1);

  // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
  const mul = 0x19660D;
  const inc = 0x3C6EF35F;
  const eps = 1 / 0x100000000;

  function lcg$1(seed = Math.random()) {
    let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
    return () => (state = mul * state + inc | 0, eps * (state >>> 0));
  }

  function initRange(domain, range) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.range(domain); break;
      default: this.range(range).domain(domain); break;
    }
    return this;
  }

  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0: break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }

  const implicit = Symbol("implicit");

  function ordinal() {
    var index = new Map(),
        domain = [],
        range = [],
        unknown = implicit;

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = new Map();
      for (const value of _) {
        const key = value + "";
        if (index.has(key)) continue;
        index.set(key, domain.push(value));
      }
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal(domain, range).unknown(unknown);
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        r0 = 0,
        r1 = 1,
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = r1 < r0,
          start = reverse ? r1 : r0,
          stop = reverse ? r0 : r1;
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = sequence(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };

    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band(domain(), [r0, r1])
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return initRange.apply(rescale(), arguments);
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  function constants(x) {
    return function() {
      return x;
    };
  }

  function number$2(x) {
    return +x;
  }

  var unit = [0, 1];

  function identity$6(x) {
    return x;
  }

  function normalize(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constants(isNaN(b) ? NaN : 0.5);
  }

  function clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) { return Math.max(a, Math.min(b, x)); };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function transformer$1() {
    var domain = unit,
        range = unit,
        interpolate$1 = interpolate,
        transform,
        untransform,
        unknown,
        clamp = identity$6,
        piecewise,
        output,
        input;

    function rescale() {
      var n = Math.min(domain.length, range.length);
      if (clamp !== identity$6) clamp = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
    }

    scale.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number$2), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? true : identity$6, rescale()) : clamp !== identity$6;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }

  function continuous() {
    return transformer$1()(identity$6, identity$6);
  }

  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      
      while (maxIter-- > 0) {
        step = tickIncrement(start, stop, count);
        if (step === prestep) {
          d[i0] = start;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }

      return scale;
    };

    return scale;
  }

  function linear$2() {
    var scale = continuous();

    scale.copy = function() {
      return copy(scale, linear$2());
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  function identity$7(domain) {
    var unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function(_) {
      return arguments.length ? (domain = Array.from(_, number$2), scale) : domain.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return identity$7(domain).unknown(unknown);
    };

    domain = arguments.length ? Array.from(domain, number$2) : [0, 1];

    return linearish(scale);
  }

  function nice$1(domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function transformLog(x) {
    return Math.log(x);
  }

  function transformExp(x) {
    return Math.exp(x);
  }

  function transformLogn(x) {
    return -Math.log(-x);
  }

  function transformExpn(x) {
    return -Math.exp(-x);
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10
        : base === Math.E ? Math.exp
        : function(x) { return Math.pow(base, x); };
  }

  function logp(base) {
    return base === Math.E ? Math.log
        : base === 10 && Math.log10
        || base === 2 && Math.log2
        || (base = Math.log(base), function(x) { return Math.log(x) / base; });
  }

  function reflect(f) {
    return function(x) {
      return -f(-x);
    };
  }

  function loggish(transform) {
    var scale = transform(transformLog, transformExp),
        domain = scale.domain,
        base = 10,
        logs,
        pows;

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }

    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function(count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u > 0) for (; i <= j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i <= j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
        if (z.length * 2 < n) z = ticks(u, v, n);
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function(count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function(d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function() {
      return domain(nice$1(domain(), {
        floor: function(x) { return pows(Math.floor(logs(x))); },
        ceil: function(x) { return pows(Math.ceil(logs(x))); }
      }));
    };

    return scale;
  }

  function log$1() {
    var scale = loggish(transformer$1()).domain([1, 10]);

    scale.copy = function() {
      return copy(scale, log$1()).base(scale.base());
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function transformSymlog(c) {
    return function(x) {
      return Math.sign(x) * Math.log1p(Math.abs(x / c));
    };
  }

  function transformSymexp(c) {
    return function(x) {
      return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
    };
  }

  function symlogish(transform) {
    var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

    scale.constant = function(_) {
      return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
    };

    return linearish(scale);
  }

  function symlog() {
    var scale = symlogish(transformer$1());

    scale.copy = function() {
      return copy(scale, symlog()).constant(scale.constant());
    };

    return initRange.apply(scale, arguments);
  }

  function transformPow(exponent) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
  }

  function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  }

  function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
  }

  function powish(transform) {
    var scale = transform(identity$6, identity$6),
        exponent = 1;

    function rescale() {
      return exponent === 1 ? transform(identity$6, identity$6)
          : exponent === 0.5 ? transform(transformSqrt, transformSquare)
          : transform(transformPow(exponent), transformPow(1 / exponent));
    }

    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, rescale()) : exponent;
    };

    return linearish(scale);
  }

  function pow$2() {
    var scale = powish(transformer$1());

    scale.copy = function() {
      return copy(scale, pow$2()).exponent(scale.exponent());
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function sqrt$1() {
    return pow$2.apply(null, arguments).exponent(0.5);
  }

  function square(x) {
    return Math.sign(x) * x * x;
  }

  function unsquare(x) {
    return Math.sign(x) * Math.sqrt(Math.abs(x));
  }

  function radial$1() {
    var squared = continuous(),
        range = [0, 1],
        round = false,
        unknown;

    function scale(x) {
      var y = unsquare(squared(x));
      return isNaN(y) ? unknown : round ? Math.round(y) : y;
    }

    scale.invert = function(y) {
      return squared.invert(square(y));
    };

    scale.domain = function(_) {
      return arguments.length ? (squared.domain(_), scale) : squared.domain();
    };

    scale.range = function(_) {
      return arguments.length ? (squared.range((range = Array.from(_, number$2)).map(square)), scale) : range.slice();
    };

    scale.rangeRound = function(_) {
      return scale.range(_).round(true);
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, scale) : round;
    };

    scale.clamp = function(_) {
      return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return radial$1(squared.domain(), range)
          .round(round)
          .clamp(squared.clamp())
          .unknown(unknown);
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  function quantile$1() {
    var domain = [],
        range = [],
        thresholds = [],
        unknown;

    function rescale() {
      var i = 0, n = Math.max(1, range.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
    }

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return rescale();
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.quantiles = function() {
      return thresholds.slice();
    };

    scale.copy = function() {
      return quantile$1()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(scale, arguments);
  }

  function quantize$1() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range = [0, 1],
        unknown;

    function scale(x) {
      return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
    };

    scale.range = function(_) {
      return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return i < 0 ? [NaN, NaN]
          : i < 1 ? [x0, domain[0]]
          : i >= n ? [domain[n - 1], x1]
          : [domain[i - 1], domain[i]];
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : scale;
    };

    scale.thresholds = function() {
      return domain.slice();
    };

    scale.copy = function() {
      return quantize$1()
          .domain([x0, x1])
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(linearish(scale), arguments);
  }

  function threshold() {
    var domain = [0.5],
        range = [0, 1],
        unknown,
        n = 1;

    function scale(x) {
      return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
    }

    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
    };

    scale.invertExtent = function(y) {
      var i = range.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return threshold()
          .domain(domain)
          .range(range)
          .unknown(unknown);
    };

    return initRange.apply(scale, arguments);
  }

  var t0$1 = new Date,
      t1$1 = new Date;

  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
    }

    interval.floor = function(date) {
      return floori(date = new Date(+date)), date;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };

    interval.round = function(date) {
      var d0 = interval(date),
          d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [], previous;
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
      while (previous < start && start < stop);
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        if (date >= date) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } else while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          }
        }
      });
    };

    if (count) {
      interval.count = function(start, end) {
        t0$1.setTime(+start), t1$1.setTime(+end);
        floori(t0$1), floori(t1$1);
        return Math.floor(count(t0$1, t1$1));
      };

      interval.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null
            : !(step > 1) ? interval
            : interval.filter(field
                ? function(d) { return field(d) % step === 0; }
                : function(d) { return interval.count(0, d) % step === 0; });
      };
    }

    return interval;
  }

  var millisecond = newInterval(function() {
    // noop
  }, function(date, step) {
    date.setTime(+date + step);
  }, function(start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function(date) {
      date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
      date.setTime(+date + step * k);
    }, function(start, end) {
      return (end - start) / k;
    });
  };
  var milliseconds = millisecond.range;

  var durationSecond = 1e3;
  var durationMinute = 6e4;
  var durationHour = 36e5;
  var durationDay = 864e5;
  var durationWeek = 6048e5;

  var second = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds());
  }, function(date, step) {
    date.setTime(+date + step * durationSecond);
  }, function(start, end) {
    return (end - start) / durationSecond;
  }, function(date) {
    return date.getUTCSeconds();
  });
  var seconds = second.range;

  var minute = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getMinutes();
  });
  var minutes = minute.range;

  var hour = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getHours();
  });
  var hours = hour.range;

  var day = newInterval(
    date => date.setHours(0, 0, 0, 0),
    (date, step) => date.setDate(date.getDate() + step),
    (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
    date => date.getDate() - 1
  );
  var days = day.range;

  function weekday(i) {
    return newInterval(function(date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);

  var sundays = sunday.range;
  var mondays = monday.range;
  var tuesdays = tuesday.range;
  var wednesdays = wednesday.range;
  var thursdays = thursday.range;
  var fridays = friday.range;
  var saturdays = saturday.range;

  var month = newInterval(function(date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function(date) {
    return date.getMonth();
  });
  var months = month.range;

  var year = newInterval(function(date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function(date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };
  var years = year.range;

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getUTCMinutes();
  });
  var utcMinutes = utcMinute.range;

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getUTCHours();
  });
  var utcHours = utcHour.range;

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / durationDay;
  }, function(date) {
    return date.getUTCDate() - 1;
  });
  var utcDays = utcDay.range;

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / durationWeek;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);

  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  var utcMonth = newInterval(function(date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function(date) {
    return date.getUTCMonth();
  });
  var utcMonths = utcMonth.range;

  var utcYear = newInterval(function(date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function(date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };
  var utcYears = utcYear.range;

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newDate(y, m, d) {
    return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
  }

  function formatLocale$1(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear$1,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) date = new Date(+date);

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, Z) {
      return function(string) {
        var d = newDate(1900, undefined, 1),
            i = parseSpecifier(d, specifier, string += "", 0),
            week, day$1;
        if (i != string.length) return null;

        // If a UNIX timestamp is specified, return it.
        if ("Q" in d) return new Date(d.Q);
        if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

        // If this is utcParse, never use the local timezone.
        if (Z && !("Z" in d)) d.Z = 0;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // If the month was not specified, inherit from the quarter.
        if (d.m === undefined) d.m = "q" in d ? d.q : 0;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
            week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
            week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
            week = day.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return localDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() { return specifier; };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() { return specifier; };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() { return specifier; };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() { return specifier; };
        return p;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"},
      numberRe = /^\s*\d+/, // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;

  function pad$1(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }

  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }

  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad$1(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad$1(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad$1(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad$1(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad$1(d.getMilliseconds(), p, 3);
  }

  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }

  function formatMonthNumber(d, p) {
    return pad$1(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad$1(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad$1(d.getSeconds(), p, 2);
  }

  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }

  function formatWeekNumberSunday(d, p) {
    return pad$1(sunday.count(year(d) - 1, d), p, 2);
  }

  function dISO(d) {
    var day = d.getDay();
    return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  }

  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad$1(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
  }

  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad$1(monday.count(year(d) - 1, d), p, 2);
  }

  function formatYear$1(d, p) {
    return pad$1(d.getFullYear() % 100, p, 2);
  }

  function formatYearISO(d, p) {
    d = dISO(d);
    return pad$1(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad$1(d.getFullYear() % 10000, p, 4);
  }

  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    return pad$1(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad$1(z / 60 | 0, "0", 2)
        + pad$1(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad$1(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad$1(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad$1(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad$1(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }

  function formatUTCMonthNumber(d, p) {
    return pad$1(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad$1(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad$1(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }

  function UTCdISO(d) {
    var day = d.getUTCDay();
    return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  }

  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }

  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad$1(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad$1(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad$1(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    return pad$1(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  function formatUnixTimestamp(d) {
    return +d;
  }

  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
  }

  var locale$1;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;

  defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    timeFormat = locale$1.format;
    timeParse = locale$1.parse;
    utcFormat = locale$1.utcFormat;
    utcParse = locale$1.utcParse;
    return locale$1;
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  var formatIso = Date.prototype.toISOString
      ? formatIsoNative
      : utcFormat(isoSpecifier);

  function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  }

  var parseIso = +new Date("2000-01-01T00:00:00.000Z")
      ? parseIsoNative
      : utcParse(isoSpecifier);

  var durationSecond$1 = 1000,
      durationMinute$1 = durationSecond$1 * 60,
      durationHour$1 = durationMinute$1 * 60,
      durationDay$1 = durationHour$1 * 24,
      durationWeek$1 = durationDay$1 * 7,
      durationMonth = durationDay$1 * 30,
      durationYear = durationDay$1 * 365;

  function date$1(t) {
    return new Date(t);
  }

  function number$3(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous(),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [
      [second,  1,      durationSecond$1],
      [second,  5,  5 * durationSecond$1],
      [second, 15, 15 * durationSecond$1],
      [second, 30, 30 * durationSecond$1],
      [minute,  1,      durationMinute$1],
      [minute,  5,  5 * durationMinute$1],
      [minute, 15, 15 * durationMinute$1],
      [minute, 30, 30 * durationMinute$1],
      [  hour,  1,      durationHour$1  ],
      [  hour,  3,  3 * durationHour$1  ],
      [  hour,  6,  6 * durationHour$1  ],
      [  hour, 12, 12 * durationHour$1  ],
      [   day,  1,      durationDay$1   ],
      [   day,  2,  2 * durationDay$1   ],
      [  week,  1,      durationWeek$1  ],
      [ month,  1,      durationMonth ],
      [ month,  3,  3 * durationMonth ],
      [  year,  1,      durationYear  ]
    ];

    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond
          : minute(date) < date ? formatSecond
          : hour(date) < date ? formatMinute
          : day(date) < date ? formatHour
          : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
          : year(date) < date ? formatMonth
          : formatYear)(date);
    }

    function tickInterval(interval, start, stop) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = bisector(function(i) { return i[2]; }).right(tickIntervals, target),
            step;
        if (i === tickIntervals.length) {
          step = tickStep(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = Math.max(tickStep(start, stop, interval), 1);
          interval = millisecond;
        }
        return interval.every(step);
      }

      return interval;
    }

    scale.invert = function(y) {
      return new Date(invert(y));
    };

    scale.domain = function(_) {
      return arguments.length ? domain(Array.from(_, number$3)) : domain().map(date$1);
    };

    scale.ticks = function(interval) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function(interval) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1]))
          ? domain(nice$1(d, interval))
          : scale;
    };

    scale.copy = function() {
      return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };

    return scale;
  }

  function time() {
    return initRange.apply(calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
  }

  function utcTime() {
    return initRange.apply(calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
  }

  function transformer$2() {
    var x0 = 0,
        x1 = 1,
        t0,
        t1,
        k10,
        transform,
        interpolator = identity$6,
        clamp = false,
        unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
    }

    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    function range(interpolate) {
      return function(_) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
      };
    }

    scale.range = range(interpolate);

    scale.rangeRound = range(interpolateRound);

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t) {
      transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
      return scale;
    };
  }

  function copy$1(source, target) {
    return target
        .domain(source.domain())
        .interpolator(source.interpolator())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function sequential() {
    var scale = linearish(transformer$2()(identity$6));

    scale.copy = function() {
      return copy$1(scale, sequential());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialLog() {
    var scale = loggish(transformer$2()).domain([1, 10]);

    scale.copy = function() {
      return copy$1(scale, sequentialLog()).base(scale.base());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialSymlog() {
    var scale = symlogish(transformer$2());

    scale.copy = function() {
      return copy$1(scale, sequentialSymlog()).constant(scale.constant());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialPow() {
    var scale = powish(transformer$2());

    scale.copy = function() {
      return copy$1(scale, sequentialPow()).exponent(scale.exponent());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
  }

  function sequentialQuantile() {
    var domain = [],
        interpolator = identity$6;

    function scale(x) {
      if (!isNaN(x = +x)) return interpolator((bisectRight(domain, x, 1) - 1) / (domain.length - 1));
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return scale;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.range = function() {
      return domain.map((d, i) => interpolator(i / (domain.length - 1)));
    };

    scale.quantiles = function(n) {
      return Array.from({length: n + 1}, (_, i) => quantile(domain, i / n));
    };

    scale.copy = function() {
      return sequentialQuantile(interpolator).domain(domain);
    };

    return initInterpolator.apply(scale, arguments);
  }

  function transformer$3() {
    var x0 = 0,
        x1 = 0.5,
        x2 = 1,
        s = 1,
        t0,
        t1,
        t2,
        k10,
        k21,
        interpolator = identity$6,
        transform,
        clamp = false,
        unknown;

    function scale(x) {
      return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
    }

    scale.domain = function(_) {
      return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    function range(interpolate) {
      return function(_) {
        var r0, r1, r2;
        return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
      };
    }

    scale.range = range(interpolate);

    scale.rangeRound = range(interpolateRound);

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t) {
      transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
      return scale;
    };
  }

  function diverging() {
    var scale = linearish(transformer$3()(identity$6));

    scale.copy = function() {
      return copy$1(scale, diverging());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingLog() {
    var scale = loggish(transformer$3()).domain([0.1, 1, 10]);

    scale.copy = function() {
      return copy$1(scale, divergingLog()).base(scale.base());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingSymlog() {
    var scale = symlogish(transformer$3());

    scale.copy = function() {
      return copy$1(scale, divergingSymlog()).constant(scale.constant());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingPow() {
    var scale = powish(transformer$3());

    scale.copy = function() {
      return copy$1(scale, divergingPow()).exponent(scale.exponent());
    };

    return initInterpolator.apply(scale, arguments);
  }

  function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
  }

  function colors(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

  var ramp = scheme => rgbBasis(scheme[scheme.length - 1]);

  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors);

  var BrBG = ramp(scheme);

  var scheme$1 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors);

  var PRGn = ramp(scheme$1);

  var scheme$2 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors);

  var PiYG = ramp(scheme$2);

  var scheme$3 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors);

  var PuOr = ramp(scheme$3);

  var scheme$4 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors);

  var RdBu = ramp(scheme$4);

  var scheme$5 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors);

  var RdGy = ramp(scheme$5);

  var scheme$6 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors);

  var RdYlBu = ramp(scheme$6);

  var scheme$7 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors);

  var RdYlGn = ramp(scheme$7);

  var scheme$8 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors);

  var Spectral = ramp(scheme$8);

  var scheme$9 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors);

  var BuGn = ramp(scheme$9);

  var scheme$a = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors);

  var BuPu = ramp(scheme$a);

  var scheme$b = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors);

  var GnBu = ramp(scheme$b);

  var scheme$c = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors);

  var OrRd = ramp(scheme$c);

  var scheme$d = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors);

  var PuBuGn = ramp(scheme$d);

  var scheme$e = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors);

  var PuBu = ramp(scheme$e);

  var scheme$f = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors);

  var PuRd = ramp(scheme$f);

  var scheme$g = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors);

  var RdPu = ramp(scheme$g);

  var scheme$h = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors);

  var YlGnBu = ramp(scheme$h);

  var scheme$i = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors);

  var YlGn = ramp(scheme$i);

  var scheme$j = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors);

  var YlOrBr = ramp(scheme$j);

  var scheme$k = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors);

  var YlOrRd = ramp(scheme$k);

  var scheme$l = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors);

  var Blues = ramp(scheme$l);

  var scheme$m = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors);

  var Greens = ramp(scheme$m);

  var scheme$n = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors);

  var Greys = ramp(scheme$n);

  var scheme$o = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors);

  var Purples = ramp(scheme$o);

  var scheme$p = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors);

  var Reds = ramp(scheme$p);

  var scheme$q = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors);

  var Oranges = ramp(scheme$q);

  function cividis(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb("
        + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
        + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
        + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
        + ")";
  }

  var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var c$1 = cubehelix();

  function rainbow(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c$1.h = 360 * t - 100;
    c$1.s = 1.5 - 1.5 * ts;
    c$1.l = 0.8 - 0.9 * ts;
    return c$1 + "";
  }

  var c$2 = rgb(),
      pi_1_3 = Math.PI / 3,
      pi_2_3 = Math.PI * 2 / 3;

  function sinebow(t) {
    var x;
    t = (0.5 - t) * Math.PI;
    c$2.r = 255 * (x = Math.sin(t)) * x;
    c$2.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
    c$2.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
    return c$2 + "";
  }

  function turbo(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb("
        + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
        + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
        + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
        + ")";
  }

  function ramp$1(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  function constant$a(x) {
    return function constant() {
      return x;
    };
  }

  var abs$3 = Math.abs;
  var atan2$1 = Math.atan2;
  var cos$2 = Math.cos;
  var max$3 = Math.max;
  var min$2 = Math.min;
  var sin$2 = Math.sin;
  var sqrt$2 = Math.sqrt;

  var epsilon$5 = 1e-12;
  var pi$4 = Math.PI;
  var halfPi$3 = pi$4 / 2;
  var tau$5 = 2 * pi$4;

  function acos$1(x) {
    return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
  }

  function asin$1(x) {
    return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
  }

  function arcInnerRadius(d) {
    return d.innerRadius;
  }

  function arcOuterRadius(d) {
    return d.outerRadius;
  }

  function arcStartAngle(d) {
    return d.startAngle;
  }

  function arcEndAngle(d) {
    return d.endAngle;
  }

  function arcPadAngle(d) {
    return d && d.padAngle; // Note: optional!
  }

  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0,
        x32 = x3 - x2, y32 = y3 - y2,
        t = y32 * x10 - x32 * y10;
    if (t * t < epsilon$5) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
  }

  // Compute perpendicular offset line of length rc.
  // http://mathworld.wolfram.com/Circle-LineIntersection.html
  function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1,
        y01 = y0 - y1,
        lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
        ox = lo * y01,
        oy = -lo * x01,
        x11 = x0 + ox,
        y11 = y0 + oy,
        x10 = x1 + ox,
        y10 = y1 + oy,
        x00 = (x11 + x10) / 2,
        y00 = (y11 + y10) / 2,
        dx = x10 - x11,
        dy = y10 - y11,
        d2 = dx * dx + dy * dy,
        r = r1 - rc,
        D = x11 * y10 - x10 * y11,
        d = (dy < 0 ? -1 : 1) * sqrt$2(max$3(0, r * r * d2 - D * D)),
        cx0 = (D * dy - dx * d) / d2,
        cy0 = (-D * dx - dy * d) / d2,
        cx1 = (D * dy + dx * d) / d2,
        cy1 = (-D * dx + dy * d) / d2,
        dx0 = cx0 - x00,
        dy0 = cy0 - y00,
        dx1 = cx1 - x00,
        dy1 = cy1 - y00;

    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }

  function arc() {
    var innerRadius = arcInnerRadius,
        outerRadius = arcOuterRadius,
        cornerRadius = constant$a(0),
        padRadius = null,
        startAngle = arcStartAngle,
        endAngle = arcEndAngle,
        padAngle = arcPadAngle,
        context = null;

    function arc() {
      var buffer,
          r,
          r0 = +innerRadius.apply(this, arguments),
          r1 = +outerRadius.apply(this, arguments),
          a0 = startAngle.apply(this, arguments) - halfPi$3,
          a1 = endAngle.apply(this, arguments) - halfPi$3,
          da = abs$3(a1 - a0),
          cw = a1 > a0;

      if (!context) context = buffer = path();

      // Ensure that the outer radius is always larger than the inner radius.
      if (r1 < r0) r = r1, r1 = r0, r0 = r;

      // Is it a point?
      if (!(r1 > epsilon$5)) context.moveTo(0, 0);

      // Or is it a circle or annulus?
      else if (da > tau$5 - epsilon$5) {
        context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$5) {
          context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
        var a01 = a0,
            a11 = a1,
            a00 = a0,
            a10 = a1,
            da0 = da,
            da1 = da,
            ap = padAngle.apply(this, arguments) / 2,
            rp = (ap > epsilon$5) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
            rc = min$2(abs$3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
            rc0 = rc,
            rc1 = rc,
            t0,
            t1;

        // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
        if (rp > epsilon$5) {
          var p0 = asin$1(rp / r0 * sin$2(ap)),
              p1 = asin$1(rp / r1 * sin$2(ap));
          if ((da0 -= p0 * 2) > epsilon$5) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon$5) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }

        var x01 = r1 * cos$2(a01),
            y01 = r1 * sin$2(a01),
            x10 = r0 * cos$2(a10),
            y10 = r0 * sin$2(a10);

        // Apply rounded corners?
        if (rc > epsilon$5) {
          var x11 = r1 * cos$2(a11),
              y11 = r1 * sin$2(a11),
              x00 = r0 * cos$2(a00),
              y00 = r0 * sin$2(a00),
              oc;

          // Restrict the corner radius according to the sector angle.
          if (da < pi$4 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
                lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min$2(rc, (r0 - lc) / (kc - 1));
            rc1 = min$2(rc, (r1 - lc) / (kc + 1));
          }
        }

        // Is the sector collapsed to a line?
        if (!(da1 > epsilon$5)) context.moveTo(x01, y01);

        // Does the sector’s outer ring have rounded corners?
        else if (rc1 > epsilon$5) {
          t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
            context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the outer ring just a circular arc?
        else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

        // Is there no inner ring, and it’s a circular sector?
        // Or perhaps it’s an annular sector collapsed due to padding?
        if (!(r0 > epsilon$5) || !(da0 > epsilon$5)) context.lineTo(x10, y10);

        // Does the sector’s inner ring (or point) have rounded corners?
        else if (rc0 > epsilon$5) {
          t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
            context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the inner ring just a circular arc?
        else context.arc(0, 0, r0, a10, a00, cw);
      }

      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
          a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
      return [cos$2(a) * r, sin$2(a) * r];
    };

    arc.innerRadius = function(_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : innerRadius;
    };

    arc.outerRadius = function(_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : outerRadius;
    };

    arc.cornerRadius = function(_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$a(+_), arc) : cornerRadius;
    };

    arc.padRadius = function(_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), arc) : padRadius;
    };

    arc.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : startAngle;
    };

    arc.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : endAngle;
    };

    arc.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$a(+_), arc) : padAngle;
    };

    arc.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), arc) : context;
    };

    return arc;
  }

  var slice$4 = Array.prototype.slice;

  function array$5(x) {
    return typeof x === "object" && "length" in x
      ? x // Array, TypedArray, NodeList, array-like
      : Array.from(x); // Map, Set, iterable, string, or anything else
  }

  function Linear(context) {
    this._context = context;
  }

  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; // proceed
        default: this._context.lineTo(x, y); break;
      }
    }
  };

  function curveLinear(context) {
    return new Linear(context);
  }

  function x$3(p) {
    return p[0];
  }

  function y$3(p) {
    return p[1];
  }

  function line(x, y) {
    var defined = constant$a(true),
        context = null,
        curve = curveLinear,
        output = null;

    x = typeof x === "function" ? x : (x === undefined) ? x$3 : constant$a(x);
    y = typeof y === "function" ? y : (y === undefined) ? y$3 : constant$a(y);

    function line(data) {
      var i,
          n = (data = array$5(data)).length,
          d,
          defined0 = false,
          buffer;

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x(d, i, data), +y(d, i, data));
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    line.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$a(+_), line) : x;
    };

    line.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$a(+_), line) : y;
    };

    line.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$a(!!_), line) : defined;
    };

    line.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };

    line.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };

    return line;
  }

  function area$3(x0, y0, y1) {
    var x1 = null,
        defined = constant$a(true),
        context = null,
        curve = curveLinear,
        output = null;

    x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x$3 : constant$a(+x0);
    y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$a(0) : constant$a(+y0);
    y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y$3 : constant$a(+y1);

    function area(data) {
      var i,
          j,
          k,
          n = (data = array$5(data)).length,
          d,
          defined0 = false,
          buffer,
          x0z = new Array(n),
          y0z = new Array(n);

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k = i - 1; k >= j; --k) {
              output.point(x0z[k], y0z[k]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
        }
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    function arealine() {
      return line().defined(defined).curve(curve).context(context);
    }

    area.x = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$a(+_), x1 = null, area) : x0;
    };

    area.x0 = function(_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$a(+_), area) : x0;
    };

    area.x1 = function(_) {
      return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), area) : x1;
    };

    area.y = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$a(+_), y1 = null, area) : y0;
    };

    area.y0 = function(_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$a(+_), area) : y0;
    };

    area.y1 = function(_) {
      return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$a(+_), area) : y1;
    };

    area.lineX0 =
    area.lineY0 = function() {
      return arealine().x(x0).y(y0);
    };

    area.lineY1 = function() {
      return arealine().x(x0).y(y1);
    };

    area.lineX1 = function() {
      return arealine().x(x1).y(y0);
    };

    area.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$a(!!_), area) : defined;
    };

    area.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };

    area.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };

    return area;
  }

  function descending$1(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function identity$8(d) {
    return d;
  }

  function pie() {
    var value = identity$8,
        sortValues = descending$1,
        sort = null,
        startAngle = constant$a(0),
        endAngle = constant$a(tau$5),
        padAngle = constant$a(0);

    function pie(data) {
      var i,
          n = (data = array$5(data)).length,
          j,
          k,
          sum = 0,
          index = new Array(n),
          arcs = new Array(n),
          a0 = +startAngle.apply(this, arguments),
          da = Math.min(tau$5, Math.max(-tau$5, endAngle.apply(this, arguments) - a0)),
          a1,
          p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
          pa = p * (da < 0 ? -1 : 1),
          v;

      for (i = 0; i < n; ++i) {
        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
          sum += v;
        }
      }

      // Optionally sort the arcs by previously-computed values or by data.
      if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
      else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

      // Compute the arcs! They are stored in the original data's order.
      for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
        j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }

      return arcs;
    }

    pie.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$a(+_), pie) : value;
    };

    pie.sortValues = function(_) {
      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };

    pie.sort = function(_) {
      return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };

    pie.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : startAngle;
    };

    pie.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : endAngle;
    };

    pie.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$a(+_), pie) : padAngle;
    };

    return pie;
  }

  var curveRadialLinear = curveRadial(curveLinear);

  function Radial(curve) {
    this._curve = curve;
  }

  Radial.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a, r) {
      this._curve.point(r * Math.sin(a), r * -Math.cos(a));
    }
  };

  function curveRadial(curve) {

    function radial(context) {
      return new Radial(curve(context));
    }

    radial._curve = curve;

    return radial;
  }

  function lineRadial(l) {
    var c = l.curve;

    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;

    l.curve = function(_) {
      return arguments.length ? c(curveRadial(_)) : c()._curve;
    };

    return l;
  }

  function lineRadial$1() {
    return lineRadial(line().curve(curveRadialLinear));
  }

  function areaRadial() {
    var a = area$3().curve(curveRadialLinear),
        c = a.curve,
        x0 = a.lineX0,
        x1 = a.lineX1,
        y0 = a.lineY0,
        y1 = a.lineY1;

    a.angle = a.x, delete a.x;
    a.startAngle = a.x0, delete a.x0;
    a.endAngle = a.x1, delete a.x1;
    a.radius = a.y, delete a.y;
    a.innerRadius = a.y0, delete a.y0;
    a.outerRadius = a.y1, delete a.y1;
    a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
    a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
    a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
    a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

    a.curve = function(_) {
      return arguments.length ? c(curveRadial(_)) : c()._curve;
    };

    return a;
  }

  function pointRadial(x, y) {
    return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
  }

  function linkSource(d) {
    return d.source;
  }

  function linkTarget(d) {
    return d.target;
  }

  function link$2(curve) {
    var source = linkSource,
        target = linkTarget,
        x = x$3,
        y = y$3,
        context = null;

    function link() {
      var buffer, argv = slice$4.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
      if (!context) context = buffer = path();
      curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
      if (buffer) return context = null, buffer + "" || null;
    }

    link.source = function(_) {
      return arguments.length ? (source = _, link) : source;
    };

    link.target = function(_) {
      return arguments.length ? (target = _, link) : target;
    };

    link.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$a(+_), link) : x;
    };

    link.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$a(+_), link) : y;
    };

    link.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), link) : context;
    };

    return link;
  }

  function curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
  }

  function curveVertical(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
  }

  function curveRadial$1(context, x0, y0, x1, y1) {
    var p0 = pointRadial(x0, y0),
        p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
        p2 = pointRadial(x1, y0),
        p3 = pointRadial(x1, y1);
    context.moveTo(p0[0], p0[1]);
    context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
  }

  function linkHorizontal() {
    return link$2(curveHorizontal);
  }

  function linkVertical() {
    return link$2(curveVertical);
  }

  function linkRadial() {
    var l = link$2(curveRadial$1);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
  }

  var circle$2 = {
    draw: function(context, size) {
      var r = Math.sqrt(size / pi$4);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau$5);
    }
  };

  var cross$2 = {
    draw: function(context, size) {
      var r = Math.sqrt(size / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };

  var tan30 = Math.sqrt(1 / 3),
      tan30_2 = tan30 * 2;

  var diamond = {
    draw: function(context, size) {
      var y = Math.sqrt(size / tan30_2),
          x = y * tan30;
      context.moveTo(0, -y);
      context.lineTo(x, 0);
      context.lineTo(0, y);
      context.lineTo(-x, 0);
      context.closePath();
    }
  };

  var ka = 0.89081309152928522810,
      kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10),
      kx = Math.sin(tau$5 / 10) * kr,
      ky = -Math.cos(tau$5 / 10) * kr;

  var star = {
    draw: function(context, size) {
      var r = Math.sqrt(size * ka),
          x = kx * r,
          y = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x, y);
      for (var i = 1; i < 5; ++i) {
        var a = tau$5 * i / 5,
            c = Math.cos(a),
            s = Math.sin(a);
        context.lineTo(s * r, -c * r);
        context.lineTo(c * x - s * y, s * x + c * y);
      }
      context.closePath();
    }
  };

  var square$1 = {
    draw: function(context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  };

  var sqrt3 = Math.sqrt(3);

  var triangle = {
    draw: function(context, size) {
      var y = -Math.sqrt(size / (sqrt3 * 3));
      context.moveTo(0, y * 2);
      context.lineTo(-sqrt3 * y, -y);
      context.lineTo(sqrt3 * y, -y);
      context.closePath();
    }
  };

  var c$3 = -0.5,
      s = Math.sqrt(3) / 2,
      k = 1 / Math.sqrt(12),
      a$1 = (k / 2 + 1) * 3;

  var wye = {
    draw: function(context, size) {
      var r = Math.sqrt(size / a$1),
          x0 = r / 2,
          y0 = r * k,
          x1 = x0,
          y1 = r * k + r,
          x2 = -x1,
          y2 = y1;
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineTo(c$3 * x0 - s * y0, s * x0 + c$3 * y0);
      context.lineTo(c$3 * x1 - s * y1, s * x1 + c$3 * y1);
      context.lineTo(c$3 * x2 - s * y2, s * x2 + c$3 * y2);
      context.lineTo(c$3 * x0 + s * y0, c$3 * y0 - s * x0);
      context.lineTo(c$3 * x1 + s * y1, c$3 * y1 - s * x1);
      context.lineTo(c$3 * x2 + s * y2, c$3 * y2 - s * x2);
      context.closePath();
    }
  };

  var symbols = [
    circle$2,
    cross$2,
    diamond,
    square$1,
    star,
    triangle,
    wye
  ];

  function symbol(type, size) {
    var context = null;
    type = typeof type === "function" ? type : constant$a(type || circle$2);
    size = typeof size === "function" ? size : constant$a(size === undefined ? 64 : +size);

    function symbol() {
      var buffer;
      if (!context) context = buffer = path();
      type.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer) return context = null, buffer + "" || null;
    }

    symbol.type = function(_) {
      return arguments.length ? (type = typeof _ === "function" ? _ : constant$a(_), symbol) : type;
    };

    symbol.size = function(_) {
      return arguments.length ? (size = typeof _ === "function" ? _ : constant$a(+_), symbol) : size;
    };

    symbol.context = function(_) {
      return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };

    return symbol;
  }

  function noop$3() {}

  function point$1(that, x, y) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x) / 6,
      (that._y0 + 4 * that._y1 + y) / 6
    );
  }

  function Basis(context) {
    this._context = context;
  }

  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3: point$1(this, this._x1, this._y1); // proceed
        case 2: this._context.lineTo(this._x1, this._y1); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
        default: point$1(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function basis$2(context) {
    return new Basis(context);
  }

  function BasisClosed(context) {
    this._context = context;
  }

  BasisClosed.prototype = {
    areaStart: noop$3,
    areaEnd: noop$3,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
        case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
        case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
        default: point$1(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function basisClosed$1(context) {
    return new BasisClosed(context);
  }

  function BasisOpen(context) {
    this._context = context;
  }

  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
        case 3: this._point = 4; // proceed
        default: point$1(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function basisOpen(context) {
    return new BasisOpen(context);
  }

  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }

  Bundle.prototype = {
    lineStart: function() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function() {
      var x = this._x,
          y = this._y,
          j = x.length - 1;

      if (j > 0) {
        var x0 = x[0],
            y0 = y[0],
            dx = x[j] - x0,
            dy = y[j] - y0,
            i = -1,
            t;

        while (++i <= j) {
          t = i / j;
          this._basis.point(
            this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
            this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
          );
        }
      }

      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function(x, y) {
      this._x.push(+x);
      this._y.push(+y);
    }
  };

  var bundle = (function custom(beta) {

    function bundle(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }

    bundle.beta = function(beta) {
      return custom(+beta);
    };

    return bundle;
  })(0.85);

  function point$2(that, x, y) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x),
      that._y2 + that._k * (that._y1 - y),
      that._x2,
      that._y2
    );
  }

  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 =
      this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x2, this._y2); break;
        case 3: point$2(this, this._x1, this._y1); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
        case 2: this._point = 3; // proceed
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinal = (function custom(tension) {

    function cardinal(context) {
      return new Cardinal(context, tension);
    }

    cardinal.tension = function(tension) {
      return custom(+tension);
    };

    return cardinal;
  })(0);

  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  CardinalClosed.prototype = {
    areaStart: noop$3,
    areaEnd: noop$3,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
        case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
        case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinalClosed = (function custom(tension) {

    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }

    cardinal.tension = function(tension) {
      return custom(+tension);
    };

    return cardinal;
  })(0);

  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  CardinalOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 =
      this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
        case 3: this._point = 4; // proceed
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinalOpen = (function custom(tension) {

    function cardinal(context) {
      return new CardinalOpen(context, tension);
    }

    cardinal.tension = function(tension) {
      return custom(+tension);
    };

    return cardinal;
  })(0);

  function point$3(that, x, y) {
    var x1 = that._x1,
        y1 = that._y1,
        x2 = that._x2,
        y2 = that._y2;

    if (that._l01_a > epsilon$5) {
      var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
          n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }

    if (that._l23_a > epsilon$5) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
          m = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
      y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
    }

    that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
  }

  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 =
      this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a =
      this._l01_2a = this._l12_2a = this._l23_2a =
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x2, this._y2); break;
        case 3: this.point(this._x2, this._y2); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; // proceed
        default: point$3(this, x, y); break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRom = (function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }

    catmullRom.alpha = function(alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  })(0.5);

  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRomClosed.prototype = {
    areaStart: noop$3,
    areaEnd: noop$3,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a =
      this._l01_2a = this._l12_2a = this._l23_2a =
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
        case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
        case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
        default: point$3(this, x, y); break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRomClosed = (function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }

    catmullRom.alpha = function(alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  })(0.5);

  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRomOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 =
      this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a =
      this._l01_2a = this._l12_2a = this._l23_2a =
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0: this._point = 1; break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
        case 3: this._point = 4; // proceed
        default: point$3(this, x, y); break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRomOpen = (function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }

    catmullRom.alpha = function(alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  })(0.5);

  function LinearClosed(context) {
    this._context = context;
  }

  LinearClosed.prototype = {
    areaStart: noop$3,
    areaEnd: noop$3,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x, y) {
      x = +x, y = +y;
      if (this._point) this._context.lineTo(x, y);
      else this._point = 1, this._context.moveTo(x, y);
    }
  };

  function linearClosed(context) {
    return new LinearClosed(context);
  }

  function sign$1(x) {
    return x < 0 ? -1 : 1;
  }

  // Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0,
        h1 = x2 - that._x1,
        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
        s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }

  // Calculate a one-sided slope.
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }

  // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point$4(that, t0, t1) {
    var x0 = that._x0,
        y0 = that._y0,
        x1 = that._x1,
        y1 = that._y1,
        dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }

  function MonotoneX(context) {
    this._context = context;
  }

  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 =
      this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x1, this._y1); break;
        case 3: point$4(this, this._t0, slope2(this, this._t0)); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      var t1 = NaN;

      x = +x, y = +y;
      if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; point$4(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
        default: point$4(this, this._t0, t1 = slope3(this, x, y)); break;
      }

      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
      this._t0 = t1;
    }
  };

  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }

  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
    MonotoneX.prototype.point.call(this, y, x);
  };

  function ReflectContext(context) {
    this._context = context;
  }

  ReflectContext.prototype = {
    moveTo: function(x, y) { this._context.moveTo(y, x); },
    closePath: function() { this._context.closePath(); },
    lineTo: function(x, y) { this._context.lineTo(y, x); },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
  };

  function monotoneX(context) {
    return new MonotoneX(context);
  }

  function monotoneY(context) {
    return new MonotoneY(context);
  }

  function Natural(context) {
    this._context = context;
  }

  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x = this._x,
          y = this._y,
          n = x.length;

      if (n) {
        this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
        if (n === 2) {
          this._context.lineTo(x[1], y[1]);
        } else {
          var px = controlPoints(x),
              py = controlPoints(y);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
          }
        }
      }

      if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x, y) {
      this._x.push(+x);
      this._y.push(+y);
    }
  };

  // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
  function controlPoints(x) {
    var i,
        n = x.length - 1,
        m,
        a = new Array(n),
        b = new Array(n),
        r = new Array(n);
    a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
    for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
    a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
    for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
    a[n - 1] = r[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
    b[n - 1] = (x[n] + a[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
    return [a, b];
  }

  function natural(context) {
    return new Natural(context);
  }

  function Step(context, t) {
    this._context = context;
    this._t = t;
  }

  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; // proceed
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
      }
      this._x = x, this._y = y;
    }
  };

  function step(context) {
    return new Step(context, 0.5);
  }

  function stepBefore(context) {
    return new Step(context, 0);
  }

  function stepAfter(context) {
    return new Step(context, 1);
  }

  function none$1(series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }

  function none$2(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }

  function stackValue(d, key) {
    return d[key];
  }

  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }

  function stack() {
    var keys = constant$a([]),
        order = none$2,
        offset = none$1,
        value = stackValue;

    function stack(data) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries),
          i, n = sz.length, j = -1,
          oz;

      for (const d of data) {
        for (i = 0, ++j; i < n; ++i) {
          (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
        }
      }

      for (i = 0, oz = array$5(order(sz)); i < n; ++i) {
        sz[oz[i]].index = i;
      }

      offset(sz, oz);
      return sz;
    }

    stack.keys = function(_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$a(Array.from(_)), stack) : keys;
    };

    stack.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$a(+_), stack) : value;
    };

    stack.order = function(_) {
      return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$a(Array.from(_)), stack) : order;
    };

    stack.offset = function(_) {
      return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
    };

    return stack;
  }

  function expand(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
      for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
      if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
    }
    none$1(series, order);
  }

  function diverging$1(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }

  function silhouette(series, order) {
    if (!((n = series.length) > 0)) return;
    for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y / 2;
    }
    none$1(series, order);
  }

  function wiggle(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]],
            sij0 = si[j][1] || 0,
            sij1 = si[j - 1][1] || 0,
            s3 = (sij0 - sij1) / 2;
        for (var k = 0; k < i; ++k) {
          var sk = series[order[k]],
              skj0 = sk[j][1] || 0,
              skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    none$1(series, order);
  }

  function appearance(series) {
    var peaks = series.map(peak);
    return none$2(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
  }

  function peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
    return j;
  }

  function ascending$3(series) {
    var sums = series.map(sum$1);
    return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });
  }

  function sum$1(series) {
    var s = 0, i = -1, n = series.length, v;
    while (++i < n) if (v = +series[i][1]) s += v;
    return s;
  }

  function descending$2(series) {
    return ascending$3(series).reverse();
  }

  function insideOut(series) {
    var n = series.length,
        i,
        j,
        sums = series.map(sum$1),
        order = appearance(series),
        top = 0,
        bottom = 0,
        tops = [],
        bottoms = [];

    for (i = 0; i < n; ++i) {
      j = order[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }

    return bottoms.reverse().concat(tops);
  }

  function reverse$1(series) {
    return none$2(series).reverse();
  }

  var constant$b = x => () => x;

  function ZoomEvent(type, {
    sourceEvent,
    target,
    transform,
    dispatch
  }) {
    Object.defineProperties(this, {
      type: {value: type, enumerable: true, configurable: true},
      sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
      target: {value: target, enumerable: true, configurable: true},
      transform: {value: transform, enumerable: true, configurable: true},
      _: {value: dispatch}
    });
  }

  function Transform(k, x, y) {
    this.k = k;
    this.x = x;
    this.y = y;
  }

  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x, y) {
      return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x) {
      return x * this.k + this.x;
    },
    applyY: function(y) {
      return y * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x) {
      return (x - this.x) / this.k;
    },
    invertY: function(y) {
      return (y - this.y) / this.k;
    },
    rescaleX: function(x) {
      return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
    },
    rescaleY: function(y) {
      return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };

  var identity$9 = new Transform(1, 0, 0);

  transform$1.prototype = Transform.prototype;

  function transform$1(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity$9;
    return node.__zoom;
  }

  function nopropagation$2(event) {
    event.stopImmediatePropagation();
  }

  function noevent$2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // Ignore right-click, since that should open the context menu.
  // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
  function defaultFilter$2(event) {
    return (!event.ctrlKey || event.type === 'wheel') && !event.button;
  }

  function defaultExtent$1() {
    var e = this;
    if (e instanceof SVGElement) {
      e = e.ownerSVGElement || e;
      if (e.hasAttribute("viewBox")) {
        e = e.viewBox.baseVal;
        return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
      }
      return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
    }
    return [[0, 0], [e.clientWidth, e.clientHeight]];
  }

  function defaultTransform() {
    return this.__zoom || identity$9;
  }

  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
  }

  function defaultTouchable$2() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
  }

  function defaultConstrain(transform, extent, translateExtent) {
    var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
        dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
        dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
        dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
    return transform.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }

  function zoom() {
    var filter = defaultFilter$2,
        extent = defaultExtent$1,
        constrain = defaultConstrain,
        wheelDelta = defaultWheelDelta,
        touchable = defaultTouchable$2,
        scaleExtent = [0, Infinity],
        translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
        duration = 250,
        interpolate = interpolateZoom,
        listeners = dispatch("start", "zoom", "end"),
        touchstarting,
        touchfirst,
        touchending,
        touchDelay = 500,
        wheelDelay = 150,
        clickDistance2 = 0,
        tapDistance = 10;

    function zoom(selection) {
      selection
          .property("__zoom", defaultTransform)
          .on("wheel.zoom", wheeled)
          .on("mousedown.zoom", mousedowned)
          .on("dblclick.zoom", dblclicked)
        .filter(touchable)
          .on("touchstart.zoom", touchstarted)
          .on("touchmove.zoom", touchmoved)
          .on("touchend.zoom touchcancel.zoom", touchended)
          .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }

    zoom.transform = function(collection, transform, point, event) {
      var selection = collection.selection ? collection.selection() : collection;
      selection.property("__zoom", defaultTransform);
      if (collection !== selection) {
        schedule(collection, transform, point, event);
      } else {
        selection.interrupt().each(function() {
          gesture(this, arguments)
            .event(event)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
        });
      }
    };

    zoom.scaleBy = function(selection, k, p, event) {
      zoom.scaleTo(selection, function() {
        var k0 = this.__zoom.k,
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return k0 * k1;
      }, p, event);
    };

    zoom.scaleTo = function(selection, k, p, event) {
      zoom.transform(selection, function() {
        var e = extent.apply(this, arguments),
            t0 = this.__zoom,
            p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
            p1 = t0.invert(p0),
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
      }, p, event);
    };

    zoom.translateBy = function(selection, x, y, event) {
      zoom.transform(selection, function() {
        return constrain(this.__zoom.translate(
          typeof x === "function" ? x.apply(this, arguments) : x,
          typeof y === "function" ? y.apply(this, arguments) : y
        ), extent.apply(this, arguments), translateExtent);
      }, null, event);
    };

    zoom.translateTo = function(selection, x, y, p, event) {
      zoom.transform(selection, function() {
        var e = extent.apply(this, arguments),
            t = this.__zoom,
            p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
        return constrain(identity$9.translate(p0[0], p0[1]).scale(t.k).translate(
          typeof x === "function" ? -x.apply(this, arguments) : -x,
          typeof y === "function" ? -y.apply(this, arguments) : -y
        ), e, translateExtent);
      }, p, event);
    };

    function scale(transform, k) {
      k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
      return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
    }

    function translate(transform, p0, p1) {
      var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
      return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
    }

    function centroid(extent) {
      return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
    }

    function schedule(transition, transform, point, event) {
      transition
          .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
          .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
          .tween("zoom", function() {
            var that = this,
                args = arguments,
                g = gesture(that, args).event(event),
                e = extent.apply(that, args),
                p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                a = that.__zoom,
                b = typeof transform === "function" ? transform.apply(that, args) : transform,
                i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
            return function(t) {
              if (t === 1) t = b; // Avoid rounding error on end.
              else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
              g.zoom(null, t);
            };
          });
    }

    function gesture(that, args, clean) {
      return (!clean && that.__zooming) || new Gesture(that, args);
    }

    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent.apply(that, args);
      this.taps = 0;
    }

    Gesture.prototype = {
      event: function(event) {
        if (event) this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
        this.that.__zoom = transform;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type) {
        var d = select(this.that).datum();
        listeners.call(
          type,
          this.that,
          new ZoomEvent(type, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d
        );
      }
    };

    function wheeled(event, ...args) {
      if (!filter.apply(this, arguments)) return;
      var g = gesture(this, args).event(event),
          t = this.__zoom,
          k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
          p = pointer(event);

      // If the mouse is in the same location as before, reuse it.
      // If there were recent wheel events, reset the wheel idle timeout.
      if (g.wheel) {
        if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
          g.mouse[1] = t.invert(g.mouse[0] = p);
        }
        clearTimeout(g.wheel);
      }

      // If this wheel event won’t trigger a transform change, ignore it.
      else if (t.k === k) return;

      // Otherwise, capture the mouse point and location at the start.
      else {
        g.mouse = [p, t.invert(p)];
        interrupt(this);
        g.start();
      }

      noevent$2(event);
      g.wheel = setTimeout(wheelidled, wheelDelay);
      g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

      function wheelidled() {
        g.wheel = null;
        g.end();
      }
    }

    function mousedowned(event, ...args) {
      if (touchending || !filter.apply(this, arguments)) return;
      var g = gesture(this, args, true).event(event),
          v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
          p = pointer(event, currentTarget),
          currentTarget = event.currentTarget,
          x0 = event.clientX,
          y0 = event.clientY;

      dragDisable(event.view);
      nopropagation$2(event);
      g.mouse = [p, this.__zoom.invert(p)];
      interrupt(this);
      g.start();

      function mousemoved(event) {
        noevent$2(event);
        if (!g.moved) {
          var dx = event.clientX - x0, dy = event.clientY - y0;
          g.moved = dx * dx + dy * dy > clickDistance2;
        }
        g.event(event)
         .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
      }

      function mouseupped(event) {
        v.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event.view, g.moved);
        noevent$2(event);
        g.event(event).end();
      }
    }

    function dblclicked(event, ...args) {
      if (!filter.apply(this, arguments)) return;
      var t0 = this.__zoom,
          p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
          p1 = t0.invert(p0),
          k1 = t0.k * (event.shiftKey ? 0.5 : 2),
          t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

      noevent$2(event);
      if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
      else select(this).call(zoom.transform, t1, p0, event);
    }

    function touchstarted(event, ...args) {
      if (!filter.apply(this, arguments)) return;
      var touches = event.touches,
          n = touches.length,
          g = gesture(this, args, event.changedTouches.length === n).event(event),
          started, i, t, p;

      nopropagation$2(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer(t, this);
        p = [p, this.__zoom.invert(p), t.identifier];
        if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
        else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
      }

      if (touchstarting) touchstarting = clearTimeout(touchstarting);

      if (started) {
        if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
        interrupt(this);
        g.start();
      }
    }

    function touchmoved(event, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event),
          touches = event.changedTouches,
          n = touches.length, i, t, p, l;

      noevent$2(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer(t, this);
        if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
        else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
      }
      t = g.that.__zoom;
      if (g.touch1) {
        var p0 = g.touch0[0], l0 = g.touch0[1],
            p1 = g.touch1[0], l1 = g.touch1[1],
            dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
            dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t = scale(t, Math.sqrt(dp / dl));
        p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      }
      else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
      else return;

      g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
    }

    function touchended(event, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event),
          touches = event.changedTouches,
          n = touches.length, i, t;

      nopropagation$2(event);
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() { touchending = null; }, touchDelay);
      for (i = 0; i < n; ++i) {
        t = touches[i];
        if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
        else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
      }
      if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
      if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else {
        g.end();
        // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
        if (g.taps === 2) {
          t = pointer(t, this);
          if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
            var p = select(this).on("dblclick.zoom");
            if (p) p.apply(this, arguments);
          }
        }
      }
    }

    zoom.wheelDelta = function(_) {
      return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$b(+_), zoom) : wheelDelta;
    };

    zoom.filter = function(_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$b(!!_), zoom) : filter;
    };

    zoom.touchable = function(_) {
      return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$b(!!_), zoom) : touchable;
    };

    zoom.extent = function(_) {
      return arguments.length ? (extent = typeof _ === "function" ? _ : constant$b([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
    };

    zoom.scaleExtent = function(_) {
      return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };

    zoom.translateExtent = function(_) {
      return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };

    zoom.constrain = function(_) {
      return arguments.length ? (constrain = _, zoom) : constrain;
    };

    zoom.duration = function(_) {
      return arguments.length ? (duration = +_, zoom) : duration;
    };

    zoom.interpolate = function(_) {
      return arguments.length ? (interpolate = _, zoom) : interpolate;
    };

    zoom.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };

    zoom.clickDistance = function(_) {
      return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
    };

    zoom.tapDistance = function(_) {
      return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
    };

    return zoom;
  }

  var d3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    version: version,
    bisect: bisectRight,
    bisectRight: bisectRight,
    bisectLeft: bisectLeft,
    bisectCenter: bisectCenter,
    ascending: ascending,
    bisector: bisector,
    count: count,
    cross: cross,
    cumsum: cumsum,
    descending: descending,
    deviation: deviation,
    extent: extent,
    fsum: fsum,
    Adder: Adder,
    group: group,
    groups: groups,
    index: index,
    indexes: indexes,
    rollup: rollup,
    rollups: rollups,
    groupSort: groupSort,
    bin: bin,
    histogram: bin,
    thresholdFreedmanDiaconis: freedmanDiaconis,
    thresholdScott: scott,
    thresholdSturges: thresholdSturges,
    max: max,
    maxIndex: maxIndex,
    mean: mean,
    median: median,
    merge: merge,
    min: min,
    minIndex: minIndex,
    nice: nice,
    pairs: pairs,
    permute: permute,
    quantile: quantile,
    quantileSorted: quantileSorted,
    quickselect: quickselect,
    range: sequence,
    least: least,
    leastIndex: leastIndex,
    greatest: greatest,
    greatestIndex: greatestIndex,
    scan: scan,
    shuffle: shuffle,
    shuffler: shuffler,
    sum: sum,
    ticks: ticks,
    tickIncrement: tickIncrement,
    tickStep: tickStep,
    transpose: transpose,
    variance: variance,
    zip: zip,
    every: every,
    some: some,
    filter: filter,
    map: map,
    reduce: reduce,
    reverse: reverse,
    sort: sort,
    difference: difference,
    disjoint: disjoint,
    intersection: intersection,
    subset: subset,
    superset: superset,
    union: union,
    InternMap: InternMap,
    InternSet: InternSet,
    axisTop: axisTop,
    axisRight: axisRight,
    axisBottom: axisBottom,
    axisLeft: axisLeft,
    brush: brush,
    brushX: brushX,
    brushY: brushY,
    brushSelection: brushSelection,
    chord: chord,
    chordTranspose: chordTranspose,
    chordDirected: chordDirected,
    ribbon: ribbon$1,
    ribbonArrow: ribbonArrow,
    color: color,
    rgb: rgb,
    hsl: hsl,
    lab: lab,
    hcl: hcl,
    lch: lch,
    gray: gray,
    cubehelix: cubehelix,
    contours: contours,
    contourDensity: density,
    Delaunay: Delaunay,
    Voronoi: Voronoi,
    dispatch: dispatch,
    drag: drag,
    dragDisable: dragDisable,
    dragEnable: yesdrag,
    dsvFormat: dsvFormat,
    csvParse: csvParse,
    csvParseRows: csvParseRows,
    csvFormat: csvFormat,
    csvFormatBody: csvFormatBody,
    csvFormatRows: csvFormatRows,
    csvFormatRow: csvFormatRow,
    csvFormatValue: csvFormatValue,
    tsvParse: tsvParse,
    tsvParseRows: tsvParseRows,
    tsvFormat: tsvFormat,
    tsvFormatBody: tsvFormatBody,
    tsvFormatRows: tsvFormatRows,
    tsvFormatRow: tsvFormatRow,
    tsvFormatValue: tsvFormatValue,
    autoType: autoType,
    easeLinear: linear$1,
    easeQuad: quadInOut,
    easeQuadIn: quadIn,
    easeQuadOut: quadOut,
    easeQuadInOut: quadInOut,
    easeCubic: cubicInOut,
    easeCubicIn: cubicIn,
    easeCubicOut: cubicOut,
    easeCubicInOut: cubicInOut,
    easePoly: polyInOut,
    easePolyIn: polyIn,
    easePolyOut: polyOut,
    easePolyInOut: polyInOut,
    easeSin: sinInOut,
    easeSinIn: sinIn,
    easeSinOut: sinOut,
    easeSinInOut: sinInOut,
    easeExp: expInOut,
    easeExpIn: expIn,
    easeExpOut: expOut,
    easeExpInOut: expInOut,
    easeCircle: circleInOut,
    easeCircleIn: circleIn,
    easeCircleOut: circleOut,
    easeCircleInOut: circleInOut,
    easeBounce: bounceOut,
    easeBounceIn: bounceIn,
    easeBounceOut: bounceOut,
    easeBounceInOut: bounceInOut,
    easeBack: backInOut,
    easeBackIn: backIn,
    easeBackOut: backOut,
    easeBackInOut: backInOut,
    easeElastic: elasticOut,
    easeElasticIn: elasticIn,
    easeElasticOut: elasticOut,
    easeElasticInOut: elasticInOut,
    blob: blob,
    buffer: buffer,
    dsv: dsv,
    csv: csv$1,
    tsv: tsv$1,
    image: image,
    json: json,
    text: text,
    xml: xml,
    html: html,
    svg: svg,
    forceCenter: center$1,
    forceCollide: collide,
    forceLink: link,
    forceManyBody: manyBody,
    forceRadial: radial,
    forceSimulation: simulation,
    forceX: x$2,
    forceY: y$2,
    formatDefaultLocale: defaultLocale,
    get format () { return format; },
    get formatPrefix () { return formatPrefix; },
    formatLocale: formatLocale,
    formatSpecifier: formatSpecifier,
    FormatSpecifier: FormatSpecifier,
    precisionFixed: precisionFixed,
    precisionPrefix: precisionPrefix,
    precisionRound: precisionRound,
    geoArea: area$1,
    geoBounds: bounds,
    geoCentroid: centroid,
    geoCircle: circle,
    geoClipAntimeridian: clipAntimeridian,
    geoClipCircle: clipCircle,
    geoClipExtent: extent$1,
    geoClipRectangle: clipRectangle,
    geoContains: contains$1,
    geoDistance: distance,
    geoGraticule: graticule,
    geoGraticule10: graticule10,
    geoInterpolate: interpolate$2,
    geoLength: length$2,
    geoPath: index$2,
    geoAlbers: albers,
    geoAlbersUsa: albersUsa,
    geoAzimuthalEqualArea: azimuthalEqualArea,
    geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: azimuthalEquidistant,
    geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
    geoConicConformal: conicConformal,
    geoConicConformalRaw: conicConformalRaw,
    geoConicEqualArea: conicEqualArea,
    geoConicEqualAreaRaw: conicEqualAreaRaw,
    geoConicEquidistant: conicEquidistant,
    geoConicEquidistantRaw: conicEquidistantRaw,
    geoEqualEarth: equalEarth,
    geoEqualEarthRaw: equalEarthRaw,
    geoEquirectangular: equirectangular,
    geoEquirectangularRaw: equirectangularRaw,
    geoGnomonic: gnomonic,
    geoGnomonicRaw: gnomonicRaw,
    geoIdentity: identity$5,
    geoProjection: projection,
    geoProjectionMutator: projectionMutator,
    geoMercator: mercator,
    geoMercatorRaw: mercatorRaw,
    geoNaturalEarth1: naturalEarth1,
    geoNaturalEarth1Raw: naturalEarth1Raw,
    geoOrthographic: orthographic,
    geoOrthographicRaw: orthographicRaw,
    geoStereographic: stereographic,
    geoStereographicRaw: stereographicRaw,
    geoTransverseMercator: transverseMercator,
    geoTransverseMercatorRaw: transverseMercatorRaw,
    geoRotation: rotation,
    geoStream: geoStream,
    geoTransform: transform,
    cluster: cluster,
    hierarchy: hierarchy,
    pack: index$3,
    packSiblings: siblings,
    packEnclose: enclose,
    partition: partition,
    stratify: stratify,
    tree: tree,
    treemap: index$4,
    treemapBinary: binary,
    treemapDice: treemapDice,
    treemapSlice: treemapSlice,
    treemapSliceDice: sliceDice,
    treemapSquarify: squarify,
    treemapResquarify: resquarify,
    interpolate: interpolate,
    interpolateArray: array$2,
    interpolateBasis: basis$1,
    interpolateBasisClosed: basisClosed,
    interpolateDate: date,
    interpolateDiscrete: discrete,
    interpolateHue: hue$1,
    interpolateNumber: interpolateNumber,
    interpolateNumberArray: numberArray,
    interpolateObject: object,
    interpolateRound: interpolateRound,
    interpolateString: interpolateString,
    interpolateTransformCss: interpolateTransformCss,
    interpolateTransformSvg: interpolateTransformSvg,
    interpolateZoom: interpolateZoom,
    interpolateRgb: interpolateRgb,
    interpolateRgbBasis: rgbBasis,
    interpolateRgbBasisClosed: rgbBasisClosed,
    interpolateHsl: hsl$2,
    interpolateHslLong: hslLong,
    interpolateLab: lab$1,
    interpolateHcl: hcl$2,
    interpolateHclLong: hclLong,
    interpolateCubehelix: cubehelix$2,
    interpolateCubehelixLong: cubehelixLong,
    piecewise: piecewise,
    quantize: quantize,
    path: path,
    polygonArea: area$2,
    polygonCentroid: centroid$1,
    polygonHull: hull,
    polygonContains: contains$2,
    polygonLength: length$3,
    quadtree: quadtree,
    randomUniform: uniform,
    randomInt: int,
    randomNormal: normal,
    randomLogNormal: logNormal,
    randomBates: bates,
    randomIrwinHall: irwinHall,
    randomExponential: exponential$1,
    randomPareto: pareto,
    randomBernoulli: bernoulli,
    randomGeometric: geometric,
    randomBinomial: binomial,
    randomGamma: gamma$1,
    randomBeta: beta,
    randomWeibull: weibull,
    randomCauchy: cauchy,
    randomLogistic: logistic,
    randomPoisson: poisson,
    randomLcg: lcg$1,
    scaleBand: band,
    scalePoint: point,
    scaleIdentity: identity$7,
    scaleLinear: linear$2,
    scaleLog: log$1,
    scaleSymlog: symlog,
    scaleOrdinal: ordinal,
    scaleImplicit: implicit,
    scalePow: pow$2,
    scaleSqrt: sqrt$1,
    scaleRadial: radial$1,
    scaleQuantile: quantile$1,
    scaleQuantize: quantize$1,
    scaleThreshold: threshold,
    scaleTime: time,
    scaleUtc: utcTime,
    scaleSequential: sequential,
    scaleSequentialLog: sequentialLog,
    scaleSequentialPow: sequentialPow,
    scaleSequentialSqrt: sequentialSqrt,
    scaleSequentialSymlog: sequentialSymlog,
    scaleSequentialQuantile: sequentialQuantile,
    scaleDiverging: diverging,
    scaleDivergingLog: divergingLog,
    scaleDivergingPow: divergingPow,
    scaleDivergingSqrt: divergingSqrt,
    scaleDivergingSymlog: divergingSymlog,
    tickFormat: tickFormat,
    schemeCategory10: category10,
    schemeAccent: Accent,
    schemeDark2: Dark2,
    schemePaired: Paired,
    schemePastel1: Pastel1,
    schemePastel2: Pastel2,
    schemeSet1: Set1,
    schemeSet2: Set2,
    schemeSet3: Set3,
    schemeTableau10: Tableau10,
    interpolateBrBG: BrBG,
    schemeBrBG: scheme,
    interpolatePRGn: PRGn,
    schemePRGn: scheme$1,
    interpolatePiYG: PiYG,
    schemePiYG: scheme$2,
    interpolatePuOr: PuOr,
    schemePuOr: scheme$3,
    interpolateRdBu: RdBu,
    schemeRdBu: scheme$4,
    interpolateRdGy: RdGy,
    schemeRdGy: scheme$5,
    interpolateRdYlBu: RdYlBu,
    schemeRdYlBu: scheme$6,
    interpolateRdYlGn: RdYlGn,
    schemeRdYlGn: scheme$7,
    interpolateSpectral: Spectral,
    schemeSpectral: scheme$8,
    interpolateBuGn: BuGn,
    schemeBuGn: scheme$9,
    interpolateBuPu: BuPu,
    schemeBuPu: scheme$a,
    interpolateGnBu: GnBu,
    schemeGnBu: scheme$b,
    interpolateOrRd: OrRd,
    schemeOrRd: scheme$c,
    interpolatePuBuGn: PuBuGn,
    schemePuBuGn: scheme$d,
    interpolatePuBu: PuBu,
    schemePuBu: scheme$e,
    interpolatePuRd: PuRd,
    schemePuRd: scheme$f,
    interpolateRdPu: RdPu,
    schemeRdPu: scheme$g,
    interpolateYlGnBu: YlGnBu,
    schemeYlGnBu: scheme$h,
    interpolateYlGn: YlGn,
    schemeYlGn: scheme$i,
    interpolateYlOrBr: YlOrBr,
    schemeYlOrBr: scheme$j,
    interpolateYlOrRd: YlOrRd,
    schemeYlOrRd: scheme$k,
    interpolateBlues: Blues,
    schemeBlues: scheme$l,
    interpolateGreens: Greens,
    schemeGreens: scheme$m,
    interpolateGreys: Greys,
    schemeGreys: scheme$n,
    interpolatePurples: Purples,
    schemePurples: scheme$o,
    interpolateReds: Reds,
    schemeReds: scheme$p,
    interpolateOranges: Oranges,
    schemeOranges: scheme$q,
    interpolateCividis: cividis,
    interpolateCubehelixDefault: cubehelix$3,
    interpolateRainbow: rainbow,
    interpolateWarm: warm,
    interpolateCool: cool,
    interpolateSinebow: sinebow,
    interpolateTurbo: turbo,
    interpolateViridis: viridis,
    interpolateMagma: magma,
    interpolateInferno: inferno,
    interpolatePlasma: plasma,
    create: create,
    creator: creator,
    local: local,
    matcher: matcher,
    namespace: namespace,
    namespaces: namespaces,
    pointer: pointer,
    pointers: pointers,
    select: select,
    selectAll: selectAll,
    selection: selection,
    selector: selector,
    selectorAll: selectorAll,
    style: styleValue,
    window: defaultView,
    arc: arc,
    area: area$3,
    line: line,
    pie: pie,
    areaRadial: areaRadial,
    radialArea: areaRadial,
    lineRadial: lineRadial$1,
    radialLine: lineRadial$1,
    pointRadial: pointRadial,
    linkHorizontal: linkHorizontal,
    linkVertical: linkVertical,
    linkRadial: linkRadial,
    symbol: symbol,
    symbols: symbols,
    symbolCircle: circle$2,
    symbolCross: cross$2,
    symbolDiamond: diamond,
    symbolSquare: square$1,
    symbolStar: star,
    symbolTriangle: triangle,
    symbolWye: wye,
    curveBasisClosed: basisClosed$1,
    curveBasisOpen: basisOpen,
    curveBasis: basis$2,
    curveBundle: bundle,
    curveCardinalClosed: cardinalClosed,
    curveCardinalOpen: cardinalOpen,
    curveCardinal: cardinal,
    curveCatmullRomClosed: catmullRomClosed,
    curveCatmullRomOpen: catmullRomOpen,
    curveCatmullRom: catmullRom,
    curveLinearClosed: linearClosed,
    curveLinear: curveLinear,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural: natural,
    curveStep: step,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore,
    stack: stack,
    stackOffsetExpand: expand,
    stackOffsetDiverging: diverging$1,
    stackOffsetNone: none$1,
    stackOffsetSilhouette: silhouette,
    stackOffsetWiggle: wiggle,
    stackOrderAppearance: appearance,
    stackOrderAscending: ascending$3,
    stackOrderDescending: descending$2,
    stackOrderInsideOut: insideOut,
    stackOrderNone: none$2,
    stackOrderReverse: reverse$1,
    timeInterval: newInterval,
    timeMillisecond: millisecond,
    timeMilliseconds: milliseconds,
    utcMillisecond: millisecond,
    utcMilliseconds: milliseconds,
    timeSecond: second,
    timeSeconds: seconds,
    utcSecond: second,
    utcSeconds: seconds,
    timeMinute: minute,
    timeMinutes: minutes,
    timeHour: hour,
    timeHours: hours,
    timeDay: day,
    timeDays: days,
    timeWeek: sunday,
    timeWeeks: sundays,
    timeSunday: sunday,
    timeSundays: sundays,
    timeMonday: monday,
    timeMondays: mondays,
    timeTuesday: tuesday,
    timeTuesdays: tuesdays,
    timeWednesday: wednesday,
    timeWednesdays: wednesdays,
    timeThursday: thursday,
    timeThursdays: thursdays,
    timeFriday: friday,
    timeFridays: fridays,
    timeSaturday: saturday,
    timeSaturdays: saturdays,
    timeMonth: month,
    timeMonths: months,
    timeYear: year,
    timeYears: years,
    utcMinute: utcMinute,
    utcMinutes: utcMinutes,
    utcHour: utcHour,
    utcHours: utcHours,
    utcDay: utcDay,
    utcDays: utcDays,
    utcWeek: utcSunday,
    utcWeeks: utcSundays,
    utcSunday: utcSunday,
    utcSundays: utcSundays,
    utcMonday: utcMonday,
    utcMondays: utcMondays,
    utcTuesday: utcTuesday,
    utcTuesdays: utcTuesdays,
    utcWednesday: utcWednesday,
    utcWednesdays: utcWednesdays,
    utcThursday: utcThursday,
    utcThursdays: utcThursdays,
    utcFriday: utcFriday,
    utcFridays: utcFridays,
    utcSaturday: utcSaturday,
    utcSaturdays: utcSaturdays,
    utcMonth: utcMonth,
    utcMonths: utcMonths,
    utcYear: utcYear,
    utcYears: utcYears,
    timeFormatDefaultLocale: defaultLocale$1,
    get timeFormat () { return timeFormat; },
    get timeParse () { return timeParse; },
    get utcFormat () { return utcFormat; },
    get utcParse () { return utcParse; },
    timeFormatLocale: formatLocale$1,
    isoFormat: formatIso,
    isoParse: parseIso,
    now: now,
    timer: timer,
    timerFlush: timerFlush,
    timeout: timeout$1,
    interval: interval$1,
    transition: transition,
    active: active,
    interrupt: interrupt,
    zoom: zoom,
    zoomTransform: transform$1,
    zoomIdentity: identity$9
  });

  function formatDecimal$1(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts$1(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent$2(x) {
    return x = formatDecimalParts$1(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup$1(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals$1(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier$1(specifier) {
    if (!(match = re$1.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier$1({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier$1.prototype = FormatSpecifier$1.prototype; // instanceof

  function FormatSpecifier$1(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier$1.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim$1(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent$1;

  function formatPrefixAuto$1(x, p) {
    var d = formatDecimalParts$1(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded$1(x, p) {
    var d = formatDecimalParts$1(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes$1 = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": formatDecimal$1,
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded$1(x * 100, p); },
    "r": formatRounded$1,
    "s": formatPrefixAuto$1,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$a(x) {
    return x;
  }

  var map$2 = Array.prototype.map,
      prefixes$1 = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale$2(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$a : formatGroup$1(map$2.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$a : formatNumerals$1(map$2.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "-" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier$1(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes$1[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes$1[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim$1(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes$1[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale$2;
  var format$1;

  defaultLocale$2({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    minus: "-"
  });

  function defaultLocale$2(definition) {
    locale$2 = formatLocale$2(definition);
    format$1 = locale$2.format;
    locale$2.formatPrefix;
    return locale$2;
  }

  var xhtml$1 = "http://www.w3.org/1999/xhtml";

  var namespaces$1 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml$1,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace$1(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces$1.hasOwnProperty(prefix) ? {space: namespaces$1[prefix], local: name} : name;
  }

  function creatorInherit$1(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml$1 && document.documentElement.namespaceURI === xhtml$1
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed$1(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator$1(name) {
    var fullname = namespace$1(name);
    return (fullname.local
        ? creatorFixed$1
        : creatorInherit$1)(fullname);
  }

  var matcher$1 = function(selector) {
    return function() {
      return this.matches(selector);
    };
  };

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!element.matches) {
      var vendorMatches = element.webkitMatchesSelector
          || element.msMatchesSelector
          || element.mozMatchesSelector
          || element.oMatchesSelector;
      matcher$1 = function(selector) {
        return function() {
          return vendorMatches.call(this, selector);
        };
      };
    }
  }

  var matcher$2 = matcher$1;

  var filterEvents = {};

  if (typeof document !== "undefined") {
    var element$1 = document.documentElement;
    if (!("onmouseenter" in element$1)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener$1(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener$1(listener, index, group) {
    return function(event1) {
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
      }
    };
  }

  function parseTypenames$2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove$1(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd$1(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener$1;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on$1(typename, value, capture) {
    var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd$1 : onRemove$1;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function none$3() {}

  function selector$1(selector) {
    return selector == null ? none$3 : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select$1(select) {
    if (typeof select !== "function") select = selector$1(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection$2(subgroups, this._parents);
  }

  function empty$3() {
    return [];
  }

  function selectorAll$1(selector) {
    return selector == null ? empty$3 : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll$1(select) {
    if (typeof select !== "function") select = selectorAll$1(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection$2(subgroups, parents);
  }

  function selection_filter$1(match) {
    if (typeof match !== "function") match = matcher$2(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection$2(subgroups, this._parents);
  }

  function sparse$1(update) {
    return new Array(update.length);
  }

  function selection_enter$1() {
    return new Selection$2(this._enter || this._groups.map(sparse$1), this._parents);
  }

  function EnterNode$1(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode$1.prototype = {
    constructor: EnterNode$1,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant$c(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex$1(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode$1(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey$1(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode$1(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data$1(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey$1 : bindIndex$1,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant$c(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection$2(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit$1() {
    return new Selection$2(this._exit || this._groups.map(sparse$1), this._parents);
  }

  function selection_merge$1(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection$2(merges, this._parents);
  }

  function selection_order$1() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort$1(compare) {
    if (!compare) compare = ascending$4;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection$2(sortgroups, this._parents).order();
  }

  function ascending$4(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call$1() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes$1() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node$1() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size$1() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty$1() {
    return !this.node();
  }

  function selection_each$1(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove$2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$2(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS$2(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction$2(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS$2(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr$1(name, value) {
    var fullname = namespace$1(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS$2 : attrRemove$2) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS$2 : attrFunction$2)
        : (fullname.local ? attrConstantNS$2 : attrConstant$2)))(fullname, value));
  }

  function defaultView$1(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove$2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$2(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction$2(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style$1(name, value, priority) {
    var node;
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove$2 : typeof value === "function"
              ? styleFunction$2
              : styleConstant$2)(name, value, priority == null ? "" : priority))
        : defaultView$1(node = this.node())
            .getComputedStyle(node, null)
            .getPropertyValue(name);
  }

  function propertyRemove$1(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant$1(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction$1(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property$1(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove$1 : typeof value === "function"
            ? propertyFunction$1
            : propertyConstant$1)(name, value))
        : this.node()[name];
  }

  function classArray$1(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList$1(node) {
    return node.classList || new ClassList$1(node);
  }

  function ClassList$1(node) {
    this._node = node;
    this._names = classArray$1(node.getAttribute("class") || "");
  }

  ClassList$1.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd$1(node, names) {
    var list = classList$1(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove$1(node, names) {
    var list = classList$1(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue$1(names) {
    return function() {
      classedAdd$1(this, names);
    };
  }

  function classedFalse$1(names) {
    return function() {
      classedRemove$1(this, names);
    };
  }

  function classedFunction$1(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names);
    };
  }

  function selection_classed$1(name, value) {
    var names = classArray$1(name + "");

    if (arguments.length < 2) {
      var list = classList$1(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction$1 : value
        ? classedTrue$1
        : classedFalse$1)(names, value));
  }

  function textRemove$1() {
    this.textContent = "";
  }

  function textConstant$2(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction$2(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text$1(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove$1 : (typeof value === "function"
            ? textFunction$2
            : textConstant$2)(value))
        : this.node().textContent;
  }

  function htmlRemove$1() {
    this.innerHTML = "";
  }

  function htmlConstant$1(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction$1(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html$1(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove$1 : (typeof value === "function"
            ? htmlFunction$1
            : htmlConstant$1)(value))
        : this.node().innerHTML;
  }

  function raise$1() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise$1() {
    return this.each(raise$1);
  }

  function lower$1() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower$1() {
    return this.each(lower$1);
  }

  function selection_append$1(name) {
    var create = typeof name === "function" ? name : creator$1(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull$1() {
    return null;
  }

  function selection_insert$1(name, before) {
    var create = typeof name === "function" ? name : creator$1(name),
        select = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove$1() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove$1() {
    return this.each(remove$1);
  }

  function selection_datum$1(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  function dispatchEvent$1(node, type, params) {
    var window = defaultView$1(node),
        event = window.CustomEvent;

    if (event) {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant$1(type, params) {
    return function() {
      return dispatchEvent$1(this, type, params);
    };
  }

  function dispatchFunction$1(type, params) {
    return function() {
      return dispatchEvent$1(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch$1(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction$1
        : dispatchConstant$1)(type, params));
  }

  var root$2 = [null];

  function Selection$2(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  Selection$2.prototype = {
    constructor: Selection$2,
    select: selection_select$1,
    selectAll: selection_selectAll$1,
    filter: selection_filter$1,
    data: selection_data$1,
    enter: selection_enter$1,
    exit: selection_exit$1,
    merge: selection_merge$1,
    order: selection_order$1,
    sort: selection_sort$1,
    call: selection_call$1,
    nodes: selection_nodes$1,
    node: selection_node$1,
    size: selection_size$1,
    empty: selection_empty$1,
    each: selection_each$1,
    attr: selection_attr$1,
    style: selection_style$1,
    property: selection_property$1,
    classed: selection_classed$1,
    text: selection_text$1,
    html: selection_html$1,
    raise: selection_raise$1,
    lower: selection_lower$1,
    append: selection_append$1,
    insert: selection_insert$1,
    remove: selection_remove$1,
    datum: selection_datum$1,
    on: selection_on$1,
    dispatch: selection_dispatch$1
  };

  function select$1(selector) {
    return typeof selector === "string"
        ? new Selection$2([[document.querySelector(selector)]], [document.documentElement])
        : new Selection$2([[selector]], root$2);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal$2(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent$3(x) {
    return x = formatDecimal$2(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup$2(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  }

  var prefixExponent$2;

  function formatPrefixAuto$2(x, p) {
    var d = formatDecimal$2(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent$2 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal$2(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded$2(x, p) {
    var d = formatDecimal$2(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes$2 = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded$2(x * 100, p); },
    "r": formatRounded$2,
    "s": formatPrefixAuto$2,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re$2 = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier$2(specifier) {
    return new FormatSpecifier$2(specifier);
  }

  function FormatSpecifier$2(specifier) {
    if (!(match = re$2.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes$2[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier$2.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  var prefixes$2 = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity$b(x) {
    return x;
  }

  function formatLocale$3(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup$2(locale.grouping, locale.thousands) : identity$b,
        currency = locale.currency,
        decimal = locale.decimal;

    function newFormat(specifier) {
      specifier = formatSpecifier$2(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes$2[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // If the original value was negative, it may be rounded to zero during
          // formatting; treat this as (positive) zero.
          if (valueNegative) {
            i = -1, n = value.length;
            valueNegative = false;
            while (++i < n) {
              if (c = value.charCodeAt(i), (48 < c && c < 58)
                  || (type === "x" && 96 < c && c < 103)
                  || (type === "X" && 64 < c && c < 71)) {
                valueNegative = true;
                break;
              }
            }
          }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes$2[8 + prefixExponent$2 / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier$2(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent$3(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes$2[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale$3;
  var format$2;
  var formatPrefix$1;

  defaultLocale$3({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale$3(definition) {
    locale$3 = formatLocale$3(definition);
    format$2 = locale$3.format;
    formatPrefix$1 = locale$3.formatPrefix;
    return locale$3;
  }

  function precisionFixed$1(step) {
    return Math.max(0, -exponent$3(Math.abs(step)));
  }

  function precisionPrefix$1(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$3(value) / 3))) * 3 - exponent$3(Math.abs(step)));
  }

  function precisionRound$1(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent$3(max) - exponent$3(step)) + 1;
  }

  var noop$4 = {value: function() {}};

  function dispatch$1() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch$1(_);
  }

  function Dispatch$1(_) {
    this._ = _;
  }

  function parseTypenames$3(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch$1.prototype = dispatch$1.prototype = {
    constructor: Dispatch$1,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames$3(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set$3(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set$3(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch$1(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get$2(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set$3(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  function ascending$5(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector$1(compare) {
    if (compare.length === 1) compare = ascendingComparator$1(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator$1(f) {
    return function(d, x) {
      return ascending$5(f(d), x);
    };
  }

  var ascendingBisect$1 = bisector$1(ascending$5);
  var bisectRight$1 = ascendingBisect$1.right;

  function sequence$1(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10$1 = Math.sqrt(50),
      e5$1 = Math.sqrt(10),
      e2$1 = Math.sqrt(2);

  function ticks$1(start, stop, count) {
    var step = tickStep$1(start, stop, count);
    return sequence$1(
      Math.ceil(start / step) * step,
      Math.floor(stop / step) * step + step / 2, // inclusive
      step
    );
  }

  function tickStep$1(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10$1) step1 *= 10;
    else if (error >= e5$1) step1 *= 5;
    else if (error >= e2$1) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function max$4(array, f) {
    var i = -1,
        n = array.length,
        a,
        b;

    if (f == null) {
      while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    }

    else {
      while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
      while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
    }

    return a;
  }

  function sum$2(array, f) {
    var s = 0,
        n = array.length,
        a,
        i = -1;

    if (f == null) {
      while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
    }

    else {
      while (++i < n) if (a = +f(array[i], i, array)) s += a;
    }

    return s;
  }

  var prefix = "$";

  function Map$1() {}

  Map$1.prototype = map$3.prototype = {
    constructor: Map$1,
    has: function(key) {
      return (prefix + key) in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function() {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function() {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function(f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map$3(object, f) {
    var map = new Map$1;

    // Copy constructor.
    if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) map.set(i, object[i]);
      else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  function Set$1() {}

  var proto = map$3.prototype;

  Set$1.prototype = {
    constructor: Set$1,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  var array$6 = Array.prototype;

  var map$4 = array$6.map;
  var slice$5 = array$6.slice;

  function define$1(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend$1(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color$1() {}

  var darker$1 = 0.7;
  var brighter$1 = 1 / darker$1;

  var reI$1 = "\\s*([+-]?\\d+)\\s*",
      reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex$1 = /^#([0-9a-f]{3,8})$/,
      reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"),
      reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"),
      reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"),
      reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"),
      reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"),
      reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");

  var named$1 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define$1(Color$1, color$1, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex$1, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex$1,
    formatHsl: color_formatHsl$1,
    formatRgb: color_formatRgb$1,
    toString: color_formatRgb$1
  });

  function color_formatHex$1() {
    return this.rgb().formatHex();
  }

  function color_formatHsl$1() {
    return hslConvert$1(this).formatHsl();
  }

  function color_formatRgb$1() {
    return this.rgb().formatRgb();
  }

  function color$1(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) // #ff0000
        : l === 3 ? new Rgb$1((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba$1(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba$1((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn$1(n) {
    return new Rgb$1(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba$1(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb$1(r, g, b, a);
  }

  function rgbConvert$1(o) {
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Rgb$1;
    o = o.rgb();
    return new Rgb$1(o.r, o.g, o.b, o.opacity);
  }

  function rgb$1(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb$1(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define$1(Rgb$1, rgb$1, extend$1(Color$1, {
    brighter: function(k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex$1, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex$1,
    formatRgb: rgb_formatRgb$1,
    toString: rgb_formatRgb$1
  }));

  function rgb_formatHex$1() {
    return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
  }

  function rgb_formatRgb$1() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex$1(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla$1(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl$1(h, s, l, a);
  }

  function hslConvert$1(o) {
    if (o instanceof Hsl$1) return new Hsl$1(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Hsl$1;
    if (o instanceof Hsl$1) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$1(h, s, l, o.opacity);
  }

  function hsl$3(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl$1(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define$1(Hsl$1, hsl$3, extend$1(Color$1, {
    brighter: function(k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb$1(
        hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb$1(h, m1, m2),
        hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb$1(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  var deg2rad = Math.PI / 180;
  var rad2deg = 180 / Math.PI;

  var A$1 = -0.14861,
      B$1 = +1.78277,
      C$1 = -0.29227,
      D$1 = -0.90649,
      E$1 = +1.97294,
      ED$1 = E$1 * D$1,
      EB$1 = E$1 * B$1,
      BC_DA$1 = B$1 * C$1 - D$1 * A$1;

  function cubehelixConvert$1(o) {
    if (o instanceof Cubehelix$1) return new Cubehelix$1(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb$1)) o = rgbConvert$1(o);
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        l = (BC_DA$1 * b + ED$1 * r - EB$1 * g) / (BC_DA$1 + ED$1 - EB$1),
        bl = b - l,
        k = (E$1 * (g - l) - C$1 * bl) / D$1,
        s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
    return new Cubehelix$1(h < 0 ? h + 360 : h, s, l, o.opacity);
  }

  function cubehelix$4(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert$1(h) : new Cubehelix$1(h, s, l, opacity == null ? 1 : opacity);
  }

  function Cubehelix$1(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define$1(Cubehelix$1, cubehelix$4, extend$1(Color$1, {
    brighter: function(k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
          l = +this.l,
          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
          cosh = Math.cos(h),
          sinh = Math.sin(h);
      return new Rgb$1(
        255 * (l + a * (A$1 * cosh + B$1 * sinh)),
        255 * (l + a * (C$1 * cosh + D$1 * sinh)),
        255 * (l + a * (E$1 * cosh)),
        this.opacity
      );
    }
  }));

  function constant$d(x) {
    return function() {
      return x;
    };
  }

  function linear$3(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential$2(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function hue$2(a, b) {
    var d = b - a;
    return d ? linear$3(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$d(isNaN(a) ? b : a);
  }

  function gamma$2(y) {
    return (y = +y) === 1 ? nogamma$1 : function(a, b) {
      return b - a ? exponential$2(a, b, y) : constant$d(isNaN(a) ? b : a);
    };
  }

  function nogamma$1(a, b) {
    var d = b - a;
    return d ? linear$3(a, d) : constant$d(isNaN(a) ? b : a);
  }

  var rgb$2 = (function rgbGamma(y) {
    var color = gamma$2(y);

    function rgb(start, end) {
      var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma$1(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb.gamma = rgbGamma;

    return rgb;
  })(1);

  function numberArray$1(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray$1(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function genericArray$1(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date$2(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function reinterpolate(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object$2(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB$1 = new RegExp(reA$1.source, "g");

  function zero$1(b) {
    return function() {
      return b;
    };
  }

  function one$1(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string(a, b) {
    var bi = reA$1.lastIndex = reB$1.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA$1.exec(a))
        && (bm = reB$1.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: reinterpolate(am, bm)});
      }
      bi = reB$1.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one$1(q[0].x)
        : zero$1(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolateValue(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$d(b)
        : (t === "number" ? reinterpolate
        : t === "string" ? ((c = color$1(b)) ? (b = c, rgb$2) : string)
        : b instanceof color$1 ? rgb$2
        : b instanceof Date ? date$2
        : isNumberArray$1(b) ? numberArray$1
        : Array.isArray(b) ? genericArray$1
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$2
        : reinterpolate)(a, b);
  }

  function interpolateRound$1(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  function cubehelix$5(hue) {
    return (function cubehelixGamma(y) {
      y = +y;

      function cubehelix(start, end) {
        var h = hue((start = cubehelix$4(start)).h, (end = cubehelix$4(end)).h),
            s = nogamma$1(start.s, end.s),
            l = nogamma$1(start.l, end.l),
            opacity = nogamma$1(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }

      cubehelix.gamma = cubehelixGamma;

      return cubehelix;
    })(1);
  }

  cubehelix$5(hue$2);
  var cubehelixLong$1 = cubehelix$5(nogamma$1);

  function constant$e(x) {
    return function() {
      return x;
    };
  }

  function number$4(x) {
    return +x;
  }

  var unit$1 = [0, 1];

  function deinterpolateLinear(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant$e(b);
  }

  function deinterpolateClamp(deinterpolate) {
    return function(a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
    };
  }

  function reinterpolateClamp(reinterpolate) {
    return function(a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
    };
  }

  function bimap$1(domain, range, deinterpolate, reinterpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap$1(domain, range, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight$1(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy$2(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous$1(deinterpolate, reinterpolate) {
    var domain = unit$1,
        range = unit$1,
        interpolate = interpolateValue,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap$1 : bimap$1;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
    }

    scale.invert = function(y) {
      return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$4.call(_, number$4), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice$5.call(_), interpolate = interpolateRound$1, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    return rescale();
  }

  function tickFormat$1(domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = tickStep$1(start, stop, count == null ? 10 : count),
        precision;
    specifier = formatSpecifier$2(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix$1(step, value))) specifier.precision = precision;
        return formatPrefix$1(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound$1(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed$1(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format$2(specifier);
  }

  function linearish$1(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks$1(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      return tickFormat$1(domain(), count, specifier);
    };

    scale.nice = function(count) {
      var d = domain(),
          i = d.length - 1,
          n = count == null ? 10 : count,
          start = d[0],
          stop = d[i],
          step = tickStep$1(start, stop, n);

      if (step) {
        step = tickStep$1(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
        d[0] = Math.floor(start / step) * step;
        d[i] = Math.ceil(stop / step) * step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear$4() {
    var scale = continuous$1(deinterpolateLinear, reinterpolate);

    scale.copy = function() {
      return copy$2(scale, linear$4());
    };

    return linearish$1(scale);
  }

  function colors$1(s) {
    return s.match(/.{6}/g).map(function(x) {
      return "#" + x;
    });
  }

  colors$1("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  colors$1("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

  colors$1("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

  colors$1("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

  cubehelixLong$1(cubehelix$4(300, 0.5, 0.0), cubehelix$4(-240, 0.5, 1.0));

  cubehelixLong$1(cubehelix$4(-100, 0.75, 0.35), cubehelix$4(80, 1.50, 0.8));

  cubehelixLong$1(cubehelix$4(260, 0.75, 0.35), cubehelix$4(80, 1.50, 0.8));

  cubehelix$4();

  function ramp$2(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  ramp$2(colors$1("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  ramp$2(colors$1("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  ramp$2(colors$1("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  ramp$2(colors$1("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var d3_identity = function d3_identity(d) {
    return d;
  };

  var d3_reverse = function d3_reverse(arr) {
    var mirror = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      mirror[i] = arr[l - i - 1];
    }
    return mirror;
  };

  //Text wrapping code adapted from Mike Bostock
  var d3_textWrapping = function d3_textWrapping(text, width) {
    text.each(function () {
      var text = select$1(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineHeight = 1.2;
          //ems
      text.attr("y");
          var dy = parseFloat(text.attr("dy")) || 0,
          tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");

      while (word = words.pop()) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width && line.length > 1) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
        }
      }
    });
  };

  var d3_mergeLabels = function d3_mergeLabels() {
    var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var labels = arguments[1];
    var domain = arguments[2];
    var range = arguments[3];
    var labelDelimiter = arguments[4];

    if ((typeof labels === "undefined" ? "undefined" : _typeof(labels)) === "object") {
      if (labels.length === 0) return gen;

      var i = labels.length;
      for (; i < gen.length; i++) {
        labels.push(gen[i]);
      }
      return labels;
    } else if (typeof labels === "function") {
      var customLabels = [];
      var genLength = gen.length;
      for (var _i = 0; _i < genLength; _i++) {
        customLabels.push(labels({
          i: _i,
          genLength: genLength,
          generatedLabels: gen,
          domain: domain,
          range: range,
          labelDelimiter: labelDelimiter
        }));
      }
      return customLabels;
    }

    return gen;
  };

  var d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {
    var data = [];

    if (cells.length > 1) {
      data = cells;
    } else {
      var domain = scale.domain(),
          increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
      var i = 0;

      for (; i < cells; i++) {
        data.push(domain[0] + i * increment);
      }
    }

    var labels = data.map(labelFormat);
    return {
      data: data,
      labels: labels,
      feature: function feature(d) {
        return scale(d);
      }
    };
  };

  var d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {
    var labels = scale.range().map(function (d) {
      var invert = scale.invertExtent(d);
      return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
    });

    return {
      data: scale.range(),
      labels: labels,
      feature: d3_identity
    };
  };

  var d3_ordinalLegend = function d3_ordinalLegend(scale) {
    return {
      data: scale.domain(),
      labels: scale.domain(),
      feature: function feature(d) {
        return scale(d);
      }
    };
  };

  var d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {
    cellDispatcher.call("cellover", obj, d);
  };

  var d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {
    cellDispatcher.call("cellout", obj, d);
  };

  var d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {
    cellDispatcher.call("cellclick", obj, d);
  };

  var helper = {
    d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
      if (shape === "rect") {
        shapes.attr("height", shapeHeight).attr("width", shapeWidth);
      } else if (shape === "circle") {
        shapes.attr("r", shapeRadius);
      } else if (shape === "line") {
        shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
      } else if (shape === "path") {
        shapes.attr("d", path);
      }
    },

    d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
      enter.append("text").attr("class", classPrefix + "label");
      var text = svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").data(labels).text(d3_identity);

      if (labelWidth) {
        svg.selectAll("g." + classPrefix + "cell text." + classPrefix + "label").call(d3_textWrapping, labelWidth);
      }

      return text;
    },

    d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {
      var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);

      //for d3.scaleSequential that doesn't have a range function
      var range = scale.range && scale.range() || scale.domain();
      type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range, labelDelimiter);

      if (ascending) {
        type.labels = d3_reverse(type.labels);
        type.data = d3_reverse(type.data);
      }

      return type;
    },

    d3_filterCells: function d3_filterCells(type, cellFilter) {
      var filterCells = type.data.map(function (d, i) {
        return { data: d, label: type.labels[i] };
      }).filter(cellFilter);
      var dataValues = filterCells.map(function (d) {
        return d.data;
      });
      var labelValues = filterCells.map(function (d) {
        return d.label;
      });
      type.data = type.data.filter(function (d) {
        return dataValues.indexOf(d) !== -1;
      });
      type.labels = type.labels.filter(function (d) {
        return labelValues.indexOf(d) !== -1;
      });
      return type;
    },

    d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {
      cell.attr("transform", cellTrans);
      text.attr("transform", textTrans);
      if (orient === "horizontal") {
        text.style("text-anchor", labelAlign);
      }
    },

    d3_addEvents: function d3_addEvents(cells, dispatcher) {
      cells.on("mouseover.legend", function (d) {
        d3_cellOver(dispatcher, d, this);
      }).on("mouseout.legend", function (d) {
        d3_cellOut(dispatcher, d, this);
      }).on("click.legend", function (d) {
        d3_cellClick(dispatcher, d, this);
      });
    },

    d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
      if (title !== "") {
        var titleText = svg.selectAll("text." + classPrefix + "legendTitle");

        titleText.data([title]).enter().append("text").attr("class", classPrefix + "legendTitle");

        svg.selectAll("text." + classPrefix + "legendTitle").text(title);

        if (titleWidth) {
          svg.selectAll("text." + classPrefix + "legendTitle").call(d3_textWrapping, titleWidth);
        }

        var cellsSvg = svg.select("." + classPrefix + "legendCells");
        var yOffset = svg.select("." + classPrefix + "legendTitle").nodes().map(function (d) {
          return d.getBBox().height;
        })[0],
            xOffset = -cellsSvg.nodes().map(function (d) {
          return d.getBBox().x;
        })[0];
        cellsSvg.attr("transform", "translate(" + xOffset + "," + yOffset + ")");
      }
    },

    d3_defaultLocale: {
      format: format$2,
      formatPrefix: formatPrefix$1
    },

    d3_defaultFormatSpecifier: ".01f",

    d3_defaultDelimiter: "to"
  };

  function color$2() {
    var scale = linear$4(),
        shape = "rect",
        shapeWidth = 15,
        shapeHeight = 15,
        shapeRadius = 10,
        shapePadding = 2,
        cells = [5],
        cellFilter = void 0,
        labels = [],
        classPrefix = "",
        useClass = false,
        title = "",
        locale = helper.d3_defaultLocale,
        specifier = helper.d3_defaultFormatSpecifier,
        labelOffset = 10,
        labelAlign = "middle",
        labelDelimiter = helper.d3_defaultDelimiter,
        labelWrap = void 0,
        orient = "vertical",
        ascending = false,
        path = void 0,
        titleWidth = void 0,
        legendDispatcher = dispatch$1("cellover", "cellout", "cellclick");

    function legend(svg) {
      var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
          legendG = svg.selectAll("g").data([scale]);

      legendG.enter().append("g").attr("class", classPrefix + "legendCells");

      if (cellFilter) {
        helper.d3_filterCells(type, cellFilter);
      }

      var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);

      var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
      cellEnter.append(shape).attr("class", classPrefix + "swatch");

      var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch").data(type.data);

      //add event handlers
      helper.d3_addEvents(cellEnter, legendDispatcher);

      cell.exit().transition().style("opacity", 0).remove();
      shapes.exit().transition().style("opacity", 0).remove();

      shapes = shapes.merge(shapes);

      helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
      var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

      // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
      cell = cellEnter.merge(cell);

      // sets placement
      var textSize = text.nodes().map(function (d) {
        return d.getBBox();
      }),
          shapeSize = shapes.nodes().map(function (d) {
        return d.getBBox();
      });
      //sets scale
      //everything is fill except for line which is stroke,
      if (!useClass) {
        if (shape == "line") {
          shapes.style("stroke", type.feature);
        } else {
          shapes.style("fill", type.feature);
        }
      } else {
        shapes.attr("class", function (d) {
          return classPrefix + "swatch " + type.feature(d);
        });
      }

      var cellTrans = void 0,
          textTrans = void 0,
          textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

      //positions cells and text
      if (orient === "vertical") {
        (function () {
          var cellSize = textSize.map(function (d, i) {
            return Math.max(d.height, shapeSize[i].height);
          });

          cellTrans = function cellTrans(d, i) {
            var height = sum$2(cellSize.slice(0, i));
            return "translate(0, " + (height + i * shapePadding) + ")";
          };

          textTrans = function textTrans(d, i) {
            return "translate( " + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ", " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
          };
        })();
      } else if (orient === "horizontal") {
        cellTrans = function cellTrans(d, i) {
          return "translate(" + i * (shapeSize[i].width + shapePadding) + ",0)";
        };
        textTrans = function textTrans(d, i) {
          return "translate(" + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n          " + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")";
        };
      }

      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
      helper.d3_title(svg, title, classPrefix, titleWidth);

      cell.transition().style("opacity", 1);
    }

    legend.scale = function (_) {
      if (!arguments.length) return scale;
      scale = _;
      return legend;
    };

    legend.cells = function (_) {
      if (!arguments.length) return cells;
      if (_.length > 1 || _ >= 2) {
        cells = _;
      }
      return legend;
    };

    legend.cellFilter = function (_) {
      if (!arguments.length) return cellFilter;
      cellFilter = _;
      return legend;
    };

    legend.shape = function (_, d) {
      if (!arguments.length) return shape;
      if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === "string") {
        shape = _;
        path = d;
      }
      return legend;
    };

    legend.shapeWidth = function (_) {
      if (!arguments.length) return shapeWidth;
      shapeWidth = +_;
      return legend;
    };

    legend.shapeHeight = function (_) {
      if (!arguments.length) return shapeHeight;
      shapeHeight = +_;
      return legend;
    };

    legend.shapeRadius = function (_) {
      if (!arguments.length) return shapeRadius;
      shapeRadius = +_;
      return legend;
    };

    legend.shapePadding = function (_) {
      if (!arguments.length) return shapePadding;
      shapePadding = +_;
      return legend;
    };

    legend.labels = function (_) {
      if (!arguments.length) return labels;
      labels = _;
      return legend;
    };

    legend.labelAlign = function (_) {
      if (!arguments.length) return labelAlign;
      if (_ == "start" || _ == "end" || _ == "middle") {
        labelAlign = _;
      }
      return legend;
    };

    legend.locale = function (_) {
      if (!arguments.length) return locale;
      locale = formatLocale$3(_);
      return legend;
    };

    legend.labelFormat = function (_) {
      if (!arguments.length) return legend.locale().format(specifier);
      specifier = formatSpecifier$2(_);
      return legend;
    };

    legend.labelOffset = function (_) {
      if (!arguments.length) return labelOffset;
      labelOffset = +_;
      return legend;
    };

    legend.labelDelimiter = function (_) {
      if (!arguments.length) return labelDelimiter;
      labelDelimiter = _;
      return legend;
    };

    legend.labelWrap = function (_) {
      if (!arguments.length) return labelWrap;
      labelWrap = _;
      return legend;
    };

    legend.useClass = function (_) {
      if (!arguments.length) return useClass;
      if (_ === true || _ === false) {
        useClass = _;
      }
      return legend;
    };

    legend.orient = function (_) {
      if (!arguments.length) return orient;
      _ = _.toLowerCase();
      if (_ == "horizontal" || _ == "vertical") {
        orient = _;
      }
      return legend;
    };

    legend.ascending = function (_) {
      if (!arguments.length) return ascending;
      ascending = !!_;
      return legend;
    };

    legend.classPrefix = function (_) {
      if (!arguments.length) return classPrefix;
      classPrefix = _;
      return legend;
    };

    legend.title = function (_) {
      if (!arguments.length) return title;
      title = _;
      return legend;
    };

    legend.titleWidth = function (_) {
      if (!arguments.length) return titleWidth;
      titleWidth = _;
      return legend;
    };

    legend.textWrap = function (_) {
      if (!arguments.length) return textWrap;
      textWrap = _;
      return legend;
    };

    legend.on = function () {
      var value = legendDispatcher.on.apply(legendDispatcher, arguments);
      return value === legendDispatcher ? legend : value;
    };

    return legend;
  }

  function size() {
    var scale = linear$4(),
        shape = "rect",
        shapeWidth = 15,
        shapePadding = 2,
        cells = [5],
        cellFilter = void 0,
        labels = [],
        classPrefix = "",
        title = "",
        locale = helper.d3_defaultLocale,
        specifier = helper.d3_defaultFormatSpecifier,
        labelOffset = 10,
        labelAlign = "middle",
        labelDelimiter = helper.d3_defaultDelimiter,
        labelWrap = void 0,
        orient = "vertical",
        ascending = false,
        path = void 0,
        titleWidth = void 0,
        legendDispatcher = dispatch$1("cellover", "cellout", "cellclick");

    function legend(svg) {
      var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
          legendG = svg.selectAll("g").data([scale]);

      if (cellFilter) {
        helper.d3_filterCells(type, cellFilter);
      }

      legendG.enter().append("g").attr("class", classPrefix + "legendCells");

      var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);
      var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
      cellEnter.append(shape).attr("class", classPrefix + "swatch");

      var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch");

      //add event handlers
      helper.d3_addEvents(cellEnter, legendDispatcher);

      cell.exit().transition().style("opacity", 0).remove();

      shapes.exit().transition().style("opacity", 0).remove();
      shapes = shapes.merge(shapes);

      //creates shape
      if (shape === "line") {
        helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
        shapes.attr("stroke-width", type.feature);
      } else {
        helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
      }

      var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

      // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
      cell = cellEnter.merge(cell);

      //sets placement

      var textSize = text.nodes().map(function (d) {
        return d.getBBox();
      }),
          shapeSize = shapes.nodes().map(function (d, i) {
        var bbox = d.getBBox();
        var stroke = scale(type.data[i]);

        if (shape === "line" && orient === "horizontal") {
          bbox.height = bbox.height + stroke;
        } else if (shape === "line" && orient === "vertical") {
          bbox.width = bbox.width;
        }
        return bbox;
      });

      var maxH = max$4(shapeSize, function (d) {
        return d.height + d.y;
      }),
          maxW = max$4(shapeSize, function (d) {
        return d.width + d.x;
      });

      var cellTrans = void 0,
          textTrans = void 0,
          textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

      //positions cells and text
      if (orient === "vertical") {
        (function () {
          var cellSize = textSize.map(function (d, i) {
            return Math.max(d.height, shapeSize[i].height);
          });
          var y = shape == "circle" || shape == "line" ? shapeSize[0].height / 2 : 0;
          cellTrans = function cellTrans(d, i) {
            var height = sum$2(cellSize.slice(0, i));

            return "translate(0, " + (y + height + i * shapePadding) + ")";
          };

          textTrans = function textTrans(d, i) {
            return "translate( " + (maxW + labelOffset) + ",\n          " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
          };
        })();
      } else if (orient === "horizontal") {
        (function () {
          cellTrans = function cellTrans(d, i) {
            var width = sum$2(shapeSize.slice(0, i), function (d) {
              return d.width;
            });
            var y = shape == "circle" || shape == "line" ? maxH / 2 : 0;
            return "translate(" + (width + i * shapePadding) + ", " + y + ")";
          };

          var offset = shape == "line" ? maxH / 2 : maxH;
          textTrans = function textTrans(d, i) {
            return "translate( " + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n              " + (offset + labelOffset) + ")";
          };
        })();
      }

      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
      helper.d3_title(svg, title, classPrefix, titleWidth);

      cell.transition().style("opacity", 1);
    }

    legend.scale = function (_) {
      if (!arguments.length) return scale;
      scale = _;
      return legend;
    };

    legend.cells = function (_) {
      if (!arguments.length) return cells;
      if (_.length > 1 || _ >= 2) {
        cells = _;
      }
      return legend;
    };

    legend.cellFilter = function (_) {
      if (!arguments.length) return cellFilter;
      cellFilter = _;
      return legend;
    };

    legend.shape = function (_, d) {
      if (!arguments.length) return shape;
      if (_ == "rect" || _ == "circle" || _ == "line") {
        shape = _;
        path = d;
      }
      return legend;
    };

    legend.shapeWidth = function (_) {
      if (!arguments.length) return shapeWidth;
      shapeWidth = +_;
      return legend;
    };

    legend.shapePadding = function (_) {
      if (!arguments.length) return shapePadding;
      shapePadding = +_;
      return legend;
    };

    legend.labels = function (_) {
      if (!arguments.length) return labels;
      labels = _;
      return legend;
    };

    legend.labelAlign = function (_) {
      if (!arguments.length) return labelAlign;
      if (_ == "start" || _ == "end" || _ == "middle") {
        labelAlign = _;
      }
      return legend;
    };

    legend.locale = function (_) {
      if (!arguments.length) return locale;
      locale = formatLocale$3(_);
      return legend;
    };

    legend.labelFormat = function (_) {
      if (!arguments.length) return legend.locale().format(specifier);
      specifier = formatSpecifier$2(_);
      return legend;
    };

    legend.labelOffset = function (_) {
      if (!arguments.length) return labelOffset;
      labelOffset = +_;
      return legend;
    };

    legend.labelDelimiter = function (_) {
      if (!arguments.length) return labelDelimiter;
      labelDelimiter = _;
      return legend;
    };

    legend.labelWrap = function (_) {
      if (!arguments.length) return labelWrap;
      labelWrap = _;
      return legend;
    };

    legend.orient = function (_) {
      if (!arguments.length) return orient;
      _ = _.toLowerCase();
      if (_ == "horizontal" || _ == "vertical") {
        orient = _;
      }
      return legend;
    };

    legend.ascending = function (_) {
      if (!arguments.length) return ascending;
      ascending = !!_;
      return legend;
    };

    legend.classPrefix = function (_) {
      if (!arguments.length) return classPrefix;
      classPrefix = _;
      return legend;
    };

    legend.title = function (_) {
      if (!arguments.length) return title;
      title = _;
      return legend;
    };

    legend.titleWidth = function (_) {
      if (!arguments.length) return titleWidth;
      titleWidth = _;
      return legend;
    };

    legend.on = function () {
      var value = legendDispatcher.on.apply(legendDispatcher, arguments);
      return value === legendDispatcher ? legend : value;
    };

    return legend;
  }

  var xhtml$2 = "http://www.w3.org/1999/xhtml";

  var namespaces$2 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml$2,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace$2(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces$2.hasOwnProperty(prefix) ? {space: namespaces$2[prefix], local: name} : name;
  }

  function creatorInherit$2(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml$2 && document.documentElement.namespaceURI === xhtml$2
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed$2(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator$2(name) {
    var fullname = namespace$2(name);
    return (fullname.local
        ? creatorFixed$2
        : creatorInherit$2)(fullname);
  }

  function none$4() {}

  function selector$2(selector) {
    return selector == null ? none$4 : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select$2(select) {
    if (typeof select !== "function") select = selector$2(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection$3(subgroups, this._parents);
  }

  function empty$4() {
    return [];
  }

  function selectorAll$2(selector) {
    return selector == null ? empty$4 : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll$2(select) {
    if (typeof select !== "function") select = selectorAll$2(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection$3(subgroups, parents);
  }

  function matcher$3(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter$2(match) {
    if (typeof match !== "function") match = matcher$3(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection$3(subgroups, this._parents);
  }

  function sparse$2(update) {
    return new Array(update.length);
  }

  function selection_enter$2() {
    return new Selection$3(this._enter || this._groups.map(sparse$2), this._parents);
  }

  function EnterNode$2(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode$2.prototype = {
    constructor: EnterNode$2,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant$f(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix$1 = "$"; // Protect against keys like “__proto__”.

  function bindIndex$2(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode$2(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey$2(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix$1 + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix$1 + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode$2(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data$2(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey$2 : bindIndex$2,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant$f(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection$3(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit$2() {
    return new Selection$3(this._exit || this._groups.map(sparse$2), this._parents);
  }

  function selection_join$1(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge$2(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection$3(merges, this._parents);
  }

  function selection_order$2() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort$2(compare) {
    if (!compare) compare = ascending$6;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection$3(sortgroups, this._parents).order();
  }

  function ascending$6(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call$2() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes$2() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node$2() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size$2() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty$2() {
    return !this.node();
  }

  function selection_each$2(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove$3(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$3(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$3(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS$3(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction$3(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS$3(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr$2(name, value) {
    var fullname = namespace$2(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS$3 : attrRemove$3) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS$3 : attrFunction$3)
        : (fullname.local ? attrConstantNS$3 : attrConstant$3)))(fullname, value));
  }

  function defaultView$2(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove$3(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$3(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction$3(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style$2(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove$3 : typeof value === "function"
              ? styleFunction$3
              : styleConstant$3)(name, value, priority == null ? "" : priority))
        : styleValue$1(this.node(), name);
  }

  function styleValue$1(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView$2(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove$2(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant$2(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction$2(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property$2(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove$2 : typeof value === "function"
            ? propertyFunction$2
            : propertyConstant$2)(name, value))
        : this.node()[name];
  }

  function classArray$2(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList$2(node) {
    return node.classList || new ClassList$2(node);
  }

  function ClassList$2(node) {
    this._node = node;
    this._names = classArray$2(node.getAttribute("class") || "");
  }

  ClassList$2.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd$2(node, names) {
    var list = classList$2(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove$2(node, names) {
    var list = classList$2(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue$2(names) {
    return function() {
      classedAdd$2(this, names);
    };
  }

  function classedFalse$2(names) {
    return function() {
      classedRemove$2(this, names);
    };
  }

  function classedFunction$2(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd$2 : classedRemove$2)(this, names);
    };
  }

  function selection_classed$2(name, value) {
    var names = classArray$2(name + "");

    if (arguments.length < 2) {
      var list = classList$2(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction$2 : value
        ? classedTrue$2
        : classedFalse$2)(names, value));
  }

  function textRemove$2() {
    this.textContent = "";
  }

  function textConstant$3(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction$3(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text$2(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove$2 : (typeof value === "function"
            ? textFunction$3
            : textConstant$3)(value))
        : this.node().textContent;
  }

  function htmlRemove$2() {
    this.innerHTML = "";
  }

  function htmlConstant$2(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction$2(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html$2(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove$2 : (typeof value === "function"
            ? htmlFunction$2
            : htmlConstant$2)(value))
        : this.node().innerHTML;
  }

  function raise$2() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise$2() {
    return this.each(raise$2);
  }

  function lower$2() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower$2() {
    return this.each(lower$2);
  }

  function selection_append$2(name) {
    var create = typeof name === "function" ? name : creator$2(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull$2() {
    return null;
  }

  function selection_insert$2(name, before) {
    var create = typeof name === "function" ? name : creator$2(name),
        select = before == null ? constantNull$2 : typeof before === "function" ? before : selector$2(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove$2() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove$2() {
    return this.each(remove$2);
  }

  function selection_cloneShallow$1() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_cloneDeep$1() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_clone$1(deep) {
    return this.select(deep ? selection_cloneDeep$1 : selection_cloneShallow$1);
  }

  function selection_datum$2(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents$1 = {};

  if (typeof document !== "undefined") {
    var element$2 = document.documentElement;
    if (!("onmouseenter" in element$2)) {
      filterEvents$1 = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener$1(listener, index, group) {
    listener = contextListener$2(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener$2(listener, index, group) {
    return function(event1) {
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
      }
    };
  }

  function parseTypenames$4(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove$2(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd$2(typename, value, capture) {
    var wrap = filterEvents$1.hasOwnProperty(typename.type) ? filterContextListener$1 : contextListener$2;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on$2(typename, value, capture) {
    var typenames = parseTypenames$4(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd$2 : onRemove$2;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function dispatchEvent$2(node, type, params) {
    var window = defaultView$2(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant$2(type, params) {
    return function() {
      return dispatchEvent$2(this, type, params);
    };
  }

  function dispatchFunction$2(type, params) {
    return function() {
      return dispatchEvent$2(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch$2(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction$2
        : dispatchConstant$2)(type, params));
  }

  var root$3 = [null];

  function Selection$3(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  Selection$3.prototype = {
    constructor: Selection$3,
    select: selection_select$2,
    selectAll: selection_selectAll$2,
    filter: selection_filter$2,
    data: selection_data$2,
    enter: selection_enter$2,
    exit: selection_exit$2,
    join: selection_join$1,
    merge: selection_merge$2,
    order: selection_order$2,
    sort: selection_sort$2,
    call: selection_call$2,
    nodes: selection_nodes$2,
    node: selection_node$2,
    size: selection_size$2,
    empty: selection_empty$2,
    each: selection_each$2,
    attr: selection_attr$2,
    style: selection_style$2,
    property: selection_property$2,
    classed: selection_classed$2,
    text: selection_text$2,
    html: selection_html$2,
    raise: selection_raise$2,
    lower: selection_lower$2,
    append: selection_append$2,
    insert: selection_insert$2,
    remove: selection_remove$2,
    clone: selection_clone$1,
    datum: selection_datum$2,
    on: selection_on$2,
    dispatch: selection_dispatch$2
  };

  function select$2(selector) {
    return typeof selector === "string"
        ? new Selection$3([[document.querySelector(selector)]], [document.documentElement])
        : new Selection$3([[selector]], root$3);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$4 = _freeGlobal || freeSelf || Function('return this')();

  var _root = root$4;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /** Built-in value references. */
  var getPrototype = _overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = _getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$1.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  var isArray_1 = isArray;

  /** `Object#toString` result references. */
  var stringTag = '[object String]';

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag);
  }

  var isString_1 = isString;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
  }

  var isSymbol_1 = isSymbol;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol_1(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  var _isKey = isKey;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
      objectProto$3 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$2.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /* Built-in method references that are verified to be native. */
  var Map$1$1 = _getNative(_root, 'Map');

  var _Map = Map$1$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || _MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = _MapCache;

  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize_1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = _memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var _stringToPath = stringToPath;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }
    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }
    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = _castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get$3(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get$3;

  var RawGraphsError =
  /*#__PURE__*/
  function (_Error) {
    _inheritsLoose(RawGraphsError, _Error);

    function RawGraphsError(message) {
      var _this;

      _this = _Error.call(this, message) || this;
      _this.name = "RawGraphsError";
      _this.message = message;
      return _this;
    }

    return RawGraphsError;
  }(_wrapNativeSuper(Error));
  /*#__PURE__*/
  (function (_Error2) {
    _inheritsLoose(ValidationError, _Error2);

    function ValidationError(errors) {
      var _this2;

      _this2 = _Error2.call(this, "validation error") || this;
      _this2.name = "ValidationError";
      _this2.message = Object.values(errors).join("\n");
      _this2.errors = errors;
      return _this2;
    }

    return ValidationError;
  })(_wrapNativeSuper(Error));
  function getType(dataType) {
    if (isPlainObject_1(dataType)) {
      return getType(dataType.type);
    }

    if (isString_1(dataType)) {
      switch (dataType.toLowerCase()) {
        case "string":
          return String;

        case "number":
          return Number;

        case "boolean":
          return Boolean;

        case "date":
          return Date;

        default:
          return String;
      }
    }

    return dataType;
  }
  function getTypeName(dataType) {
    var type = getType(dataType);
    return type && type.name ? type.name.toLowerCase() : undefined;
  } // taken from: https://observablehq.com/@mbostock/localized-number-parsing

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  var _baseSum = baseSum;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (_baseSum(array, iteratee) / length) : NAN;
  }

  var _baseMean = baseMean;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$c(value) {
    return value;
  }

  var identity_1 = identity$c;

  /**
   * Computes the mean of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the mean.
   * @example
   *
   * _.mean([4, 2, 8, 6]);
   * // => 5
   */
  function mean$1(array) {
    return _baseMean(array, identity_1);
  }

  var mean_1 = mean$1;

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !isSymbol_1(current))
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  var _baseExtremum = baseExtremum;

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  var _baseGt = baseGt;

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max$5(array) {
    return (array && array.length)
      ? _baseExtremum(array, identity_1, _baseGt)
      : undefined;
  }

  var max_1 = max$5;

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  var _baseLt = baseLt;

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min$3(array) {
    return (array && array.length)
      ? _baseExtremum(array, identity_1, _baseLt)
      : undefined;
  }

  var min_1 = min$3;

  /**
   * Computes the sum of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 3.4.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the sum.
   * @example
   *
   * _.sum([4, 2, 8, 6]);
   * // => 20
   */
  function sum$3(array) {
    return (array && array.length)
      ? _baseSum(array, identity_1)
      : 0;
  }

  var sum_1 = sum$3;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? _strictIndexOf(array, value, fromIndex)
      : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /* Built-in method references that are verified to be native. */
  var Set$2 = _getNative(_root, 'Set');

  var _Set = Set$2;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop$5() {
    // No operation performed.
  }

  var noop_1 = noop$5;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY$2) ? noop_1 : function(values) {
    return new _Set(values);
  };

  var _createSet = createSet;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = _arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : _createSet(array);
      if (set) {
        return _setToArray(set);
      }
      isCommon = false;
      includes = _cacheHas;
      seen = new _SetCache;
    }
    else {
      seen = iteratee ? [] : result;
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      }
      else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  var _baseUniq = baseUniq;

  /**
   * Creates a duplicate-free version of an array, using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons, in which only the first occurrence of each element
   * is kept. The order of result values is determined by the order they occur
   * in the array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniq([2, 1, 2]);
   * // => [2, 1]
   */
  function uniq(array) {
    return (array && array.length) ? _baseUniq(array) : [];
  }

  var uniq_1 = uniq;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var NAN$1 = 0 / 0;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol_1(value)) {
      return NAN$1;
    }
    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN$1 : +value);
  }

  var toNumber_1 = toNumber;

  /** Used as references for various `Number` constants. */
  var INFINITY$3 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber_1(value);
    if (value === INFINITY$3 || value === -INFINITY$3) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new _ListCache;
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$1 = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _ListCache) {
      var pairs = data.__data__;
      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new _MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;

  var _Stack = Stack;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!_arraySome(other, function(othValue, othIndex) {
              if (!_cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /** Built-in value references. */
  var Uint8Array = _root.Uint8Array;

  var _Uint8Array = Uint8Array;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /** `Object#toString` result references. */
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = _mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$1;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$1:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  var _getSymbols = getSymbols;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag$1 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$1 = '[object Object]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$2 = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
  typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] =
  typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
  typedArrayTags[mapTag$1] = typedArrayTags[numberTag$2] =
  typedArrayTags[objectTag$1] = typedArrayTags[regexpTag$1] =
  typedArrayTags[setTag$1] = typedArrayTags[stringTag$2] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$6.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

    return value === proto;
  }

  var _isPrototype = isPrototype;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$8.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /* Built-in method references that are verified to be native. */
  var DataView$1 = _getNative(_root, 'DataView');

  var _DataView = DataView$1;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */
  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;

  /** `Object#toString` result references. */
  var mapTag$2 = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$2 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = _baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
      (_Map && getTag(new _Map) != mapTag$2) ||
      (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
      (_Set && getTag(new _Set) != setTag$2) ||
      (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$2;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$2;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var _getTag = getTag;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      objectTag$3 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$c = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$1 : _getTag(object),
        othTag = othIsArr ? arrayTag$1 : _getTag(other);

    objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
    othTag = othTag == argsTag$2 ? objectTag$3 : othTag;

    var objIsObj = objTag == objectTag$3,
        othIsObj = othTag == objectTag$3,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack);
      return (objIsArr || isTypedArray_1(object))
        ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new _Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new _Stack);
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
      return value !== value && other !== other;
    }
    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, _isStrictComparable(value)];
    }
    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = _getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) &&
      (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get_1(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn_1(object, path)
        : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity_1;
    }
    if (typeof value == 'object') {
      return isArray_1(value)
        ? _baseMatchesProperty(value[0], value[1])
        : _baseMatches(value);
    }
    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike_1(collection)) {
        var iteratee = _baseIteratee(predicate);
        collection = keys_1(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  var _createFind = createFind;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  var toInteger_1 = toInteger;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger_1(fromIndex);
    if (index < 0) {
      index = nativeMax$1(length + index, 0);
    }
    return _baseFindIndex(array, _baseIteratee(predicate), index);
  }

  var findIndex_1 = findIndex;

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find$2 = _createFind(findIndex_1);

  var find_1 = find$2;

  // import last from 'lodash/last'

  var aggregationsRegister = {};
  function registerAggregation(name, fun) {
    aggregationsRegister[name] = fun;
  }
  function getAggregatorNames() {
    return Object.keys(aggregationsRegister);
  }
  function getAggregator(aggregatorExpression) {
    if (isFunction_1(aggregatorExpression)) {
      return aggregatorExpression;
    }

    if (isString_1(aggregatorExpression)) {
      if (aggregationsRegister[aggregatorExpression]) {
        return aggregationsRegister[aggregatorExpression];
      } else {
        throw new RawGraphsError("Aggregator \"" + aggregatorExpression + "\" is is not registered in RawGraphs.");
      }
    }
  }
  // general purpose

  registerAggregation("count", function (items) {
    return items.length;
  }); // registerAggregation("last", last)
  // registerAggregation("first", first)

  registerAggregation("countDistinct", function (items) {
    return uniq_1(items).length;
  }); // numbers

  registerAggregation("mean", mean_1);
  registerAggregation("max", max_1);
  registerAggregation("min", min_1);
  registerAggregation("sum", sum_1);
  registerAggregation("median", median); //string

  var commaSeparated = function commaSeparated(items) {
    return items.join(",");
  }; // const tabSeparated = items => items.join("\t")
  // const newLineSeparated = items => items.join("\n")
  // const itemsList = items => items
  // const itemsUniq = items => uniq(items)


  registerAggregation("csv", commaSeparated);
  registerAggregation("csvDistinct", function (items) {
    return commaSeparated(uniq_1(items));
  }); // registerAggregation("commaSeparated", commaSeparated)
  // registerAggregation("tsv", tabSeparated)
  // registerAggregation("tsvDistinct", items => tabSeparated(uniq(items)))
  // registerAggregation("tabSeparated", tabSeparated)
  // registerAggregation("newLineSeparated", newLineSeparated)
  // registerAggregation("list", itemsList)
  // registerAggregation("distinct", itemsUniq)

  function getDefaultDimensionAggregation(dimension, dataType) {
    if (!dimension.aggregation) {
      throw new RawGraphsError("Dimension " + dimension.id + " is not aggregable");
    }

    var names = getAggregatorNames();
    var typeName = getTypeName(dataType);
    var defaultAggregation = get_1(dimension, 'aggregationDefault'); //#TODO check that default aggregation exists in registered ones

    if (defaultAggregation) {
      if (isPlainObject_1(defaultAggregation)) {
        return get_1(defaultAggregation, typeName, names[0]);
      } else {
        return defaultAggregation;
      }
    }

    return names[0];
  }
  function getDimensionAggregator(dimensionId, mapping, dataTypes, dimensions) {
    var dimension = find_1(dimensions, function (x) {
      return x.id === dimensionId;
    });
    var mappingValue = get_1(mapping[dimensionId], 'value', dimension.multiple ? [] : undefined); //#TODO: this is done to return function returning a scalar in any case
    // works well with undefined "size" dimensions (See matrix plot at rawgraphs-charts at commit 04013f633e32f4c630a5db2b855c6cf270b3af03), 
    // but this needs investigation

    if (!dimension.multiple && !mappingValue) {
      return function () {
        return 1;
      };
    }

    function getSingleDim(dimension, columnName, index) {
      var dataType = get_1(dataTypes, columnName);
      var defaultAggregation = getDefaultDimensionAggregation(dimension, dataType);
      var aggregation = get_1(mapping[dimension.id], 'config.aggregation', defaultAggregation);

      if (index !== undefined) {
        aggregation = aggregation[index];
      }

      var aggregator = getAggregator(aggregation);
      return aggregator;
    }

    if (Array.isArray(mappingValue)) {
      var out = mappingValue.map(function (columnName, i) {
        return getSingleDim(dimension, columnName, i);
      });
      return out;
    } else {
      return getSingleDim(dimension, mappingValue);
    }
  }

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$2 = 200;

  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }
    if (iteratee) {
      values = _arrayMap(values, _baseUnary(iteratee));
    }
    if (comparator) {
      includes = _arrayIncludesWith;
      isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE$2) {
      includes = _cacheHas;
      isCommon = false;
      values = new _SetCache(values);
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
    return result;
  }

  var _baseDifference = baseDifference;

  /** Built-in value references. */
  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  var _baseFlatten = baseFlatten;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$2 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax$2(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax$2(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$g(value) {
    return function() {
      return value;
    };
  }

  var constant_1 = constant$g;

  var defineProperty = (function() {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var _defineProperty = defineProperty;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };

  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /**
   * Creates an array of `array` values not included in the other given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * **Note:** Unlike `_.pullAll`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.without, _.xor
   * @example
   *
   * _.difference([2, 1], [2, 3]);
   * // => [1]
   */
  _baseRest(function(array, values) {
    return isArrayLikeObject_1(array)
      ? _baseDifference(array, _baseFlatten(values, 1, isArrayLikeObject_1, true))
      : [];
  });

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  var _arrayAggregator = arrayAggregator;

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = _createBaseFor();

  var _baseFor = baseFor;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = _createBaseEach(_baseForOwn);

  var _baseEach = baseEach;

  /**
   * Aggregates elements of `collection` on `accumulator` with keys transformed
   * by `iteratee` and values set by `setter`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function baseAggregator(collection, setter, iteratee, accumulator) {
    _baseEach(collection, function(value, key, collection) {
      setter(accumulator, value, iteratee(value), collection);
    });
    return accumulator;
  }

  var _baseAggregator = baseAggregator;

  /**
   * Creates a function like `_.groupBy`.
   *
   * @private
   * @param {Function} setter The function to set accumulator values.
   * @param {Function} [initializer] The accumulator object initializer.
   * @returns {Function} Returns the new aggregator function.
   */
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray_1(collection) ? _arrayAggregator : _baseAggregator,
          accumulator = initializer ? initializer() : {};

      return func(collection, setter, _baseIteratee(iteratee), accumulator);
    };
  }

  var _createAggregator = createAggregator;

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` thru `iteratee`. The corresponding value of
   * each key is the last element responsible for generating the key. The
   * iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * var array = [
   *   { 'dir': 'left', 'code': 97 },
   *   { 'dir': 'right', 'code': 100 }
   * ];
   *
   * _.keyBy(array, function(o) {
   *   return String.fromCharCode(o.code);
   * });
   * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
   *
   * _.keyBy(array, 'dir');
   * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
   */
  var keyBy = _createAggregator(function(result, value, key) {
    _baseAssignValue(result, key, value);
  });

  var keyBy_1 = keyBy;

  /* Node.js helper references. */
  _nodeUtil && _nodeUtil.isDate;

  //date formats mapping

  /*

  %a - abbreviated weekday name.*
  %A - full weekday name.*
  %b - abbreviated month name.*
  %B - full month name.*
  %c - the locale’s date and time, such as %x, %X.*
  %d - zero-padded day of the month as a decimal number [01,31].
  %e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.
  %f - microseconds as a decimal number [000000, 999999].
  %g - ISO 8601 week-based year without century as a decimal number [00,99].
  %G - ISO 8601 week-based year with century as a decimal number.
  %H - hour (24-hour clock) as a decimal number [00,23].
  %I - hour (12-hour clock) as a decimal number [01,12].
  %j - day of the year as a decimal number [001,366].
  %m - month as a decimal number [01,12].
  %M - minute as a decimal number [00,59].
  %L - milliseconds as a decimal number [000, 999].
  %p - either AM or PM.*
  %q - quarter of the year as a decimal number [1,4].
  %Q - milliseconds since UNIX epoch.
  %s - seconds since UNIX epoch.
  %S - second as a decimal number [00,61].
  %u - Monday-based (ISO 8601) weekday as a decimal number [1,7].
  %U - Sunday-based week of the year as a decimal number [00,53].
  %V - ISO 8601 week of the year as a decimal number [01, 53].
  %w - Sunday-based weekday as a decimal number [0,6].
  %W - Monday-based week of the year as a decimal number [00,53].
  %x - the locale’s date, such as %-m/%-d/%Y.*
  %X - the locale’s time, such as %-I:%M:%S %p.*
  %y - year without century as a decimal number [00,99].
  %Y - year with century as a decimal number, such as 1999.
  %Z - time zone offset, such as -0700, -07:00, -07, or Z.
  %% - a literal percent sign (%).

  */

  /* 

  Input	Example	Description
  YY	18	Two-digit year
  YYYY	2018	Four-digit year
  M	1-12	Month, beginning at 1
  MM	01-12	Month, 2-digits
  MMM	Jan-Dec	The abbreviated month name
  MMMM	January-December	The full month name
  D	1-31	Day of month
  DD	01-31	Day of month, 2-digits
  H	0-23	Hours
  HH	00-23	Hours, 2-digits
  h	1-12	Hours, 12-hour clock
  hh	01-12	Hours, 12-hour clock, 2-digits
  m	0-59	Minutes
  mm	00-59	Minutes, 2-digits
  s	0-59	Seconds
  ss	00-59	Seconds, 2-digits
  S	0-9	Hundreds of milliseconds, 1-digit
  SS	00-99	Tens of milliseconds, 2-digits
  SSS	000-999	Milliseconds, 3-digits
  Z	-05:00	Offset from UTC
  ZZ	-0500	Compact offset from UTC, 2-digits
  A	AM PM	Post or ante meridiem, upper-case
  a	am pm	Post or ante meridiem, lower-case
  Do	1st... 31st	Day of Month with ordinal

  */
  //#TODO: HANDLE DATEFORMATS WITH REGISTRATION APPROACH + DEFAULT
  var dateTokensMap = {
    YYYY: "%Y",
    MM: "%m",
    DD: "%d",
    YY: "%y",
    Month: "%B",
    HH: "%H",
    mm: "%M",
    ss: "%S"
  };
  var translateDateFormat = function translateDateFormat(df) {
    var out = new String(df);
    Object.keys(dateTokensMap).forEach(function (token) {
      var reg = new RegExp(token, 'g');
      out = out.replace(reg, dateTokensMap[token]);
    });
    return out;
  }; // actual dateFormats export

  var formatsLabels = ["YYYY-MM-DD", "DD/MM/YYYY", "YYYY-MM", "YY-MM", "MM/YY", "MM/YYYY", "DD Month YYYY", "YYYY", "YYYY-MM-DD HH:mm:ss", "YYYY-MM-DDTHH:mm:ss"];
  var dateFormats$1 = {};
  formatsLabels.forEach(function (label) {
    dateFormats$1[label] = translateDateFormat(label);
  }); // dateFormats["iso"] = undefined

  function scaleType(scale) {
    if (scale.interpolate) {
      return "continuous";
    } else if (scale.interpolator) {
      return "sequential";
    } else if (scale.invertExtent) {
      return "other";
    } else {
      return "ordinal";
    }
  }

  function legend(legendColor$1, legendSize$1, legendWidth, shapePadding, shapeWidth, shapeHeight, margin) {
    if (legendWidth === void 0) {
      legendWidth = 200;
    }

    if (shapePadding === void 0) {
      shapePadding = 5;
    }

    if (shapeWidth === void 0) {
      shapeWidth = 15;
    }

    if (margin === void 0) {
      margin = {
        top: 0,
        right: 5,
        bottom: 0,
        left: 5
      };
    }

    var legendFn = function legendFn(_selection) {
      var d3legendColor;
      var w = legendWidth - margin.left - margin.right;

      var legendContainer = _selection.append("g").attr("transform", "translate(" + margin.left + "," + 0 + ")"); //draw size scale


      if (legendSize$1 && legendSize$1.title) {
        legendContainer.append("g").attr("class", "legendSize").attr("transform", "translate(0," + margin.top + ")");

        var _d3LegendSize = size().scale(legendSize$1.scale).cells(legendSize$1.scale.domain()).shape(legendSize$1.shape ? legendSize$1.shape : "circle").title(legendSize$1.title).titleWidth(w).labelWrap(w - shapePadding - shapeWidth).labelOffset(5).shapePadding(legendSize$1.shape === "circle" ? legendSize$1.scale.range()[1] : shapePadding);

        legendContainer.select(".legendSize").call(_d3LegendSize);
      } //draw color scale


      if (legendColor$1 && legendColor$1.title) {
        var legendColorHeight = legendContainer.select(".legendSize").empty() ? 0 : legendContainer.select(".legendSize").node().getBBox().height + 20;
        legendContainer.append("g").attr("class", "legendColor").attr("transform", "translate(0," + legendColorHeight + ")");
        d3legendColor = color$2().shapePadding(shapePadding).title(legendColor$1.title).titleWidth(w).labelWrap(w - shapePadding - shapeWidth).labelOffset(5).scale(legendColor$1.scale);

        if (scaleType(legendColor$1.scale) !== "ordinal") {
          d3legendColor.shapePadding(0).orient("horizontal").shapeWidth(1).shapeHeight(10).cells(w).classPrefix("horizontal-").labelAlign("start").labels(function (_ref) {
            var i = _ref.i,
                genLength = _ref.genLength,
                generatedLabels = _ref.generatedLabels,
                domain = _ref.domain;

            if (i === 0 || i === genLength - 1) {
              return generatedLabels[i];
            }

            if (domain.length === 3 && i === genLength / 2 - 1) {
              return format$1(".01f")((domain[0] + domain[2]) / 2);
            }
          });
        }

        legendContainer.select(".legendColor").call(d3legendColor);
      } //Hardcore style with much love


      legendContainer.selectAll("text").attr("font-family", '"Arial", sans-serif').attr("font-size", "10px");
      legendContainer.selectAll(".legendTitle").attr("font-size", "12px").attr("font-weight", "bold");
      legendContainer.selectAll(".horizontal-legendTitle").attr("font-size", "12px").attr("font-weight", "bold");
      legendContainer.selectAll(".horizontal-cell text").style("text-anchor", "middle").attr("text-anchor", "middle");
      legendContainer.selectAll(".horizontal-cell:first-of-type text").style("text-anchor", "start").attr("text-anchor", "start");
      legendContainer.selectAll(".horizontal-cell:last-of-type text").style("text-anchor", "end").attr("text-anchor", "end");
      legendContainer.selectAll(".legendSize circle").attr("fill", "none").attr("stroke", "#ccc");
      legendContainer.selectAll(".legendSize rect").attr("fill", "none").attr("stroke", "#ccc");
    };

    legendFn.addColor = function (_title, _scale) {
      if (!arguments.length) return legendColor$1;
      legendColor$1 = {
        title: _title,
        scale: _scale
      };
      return legendFn;
    };

    legendFn.addSize = function (_title, _scale, _shape) {
      if (!arguments.length) return legendSize$1;
      legendSize$1 = {
        title: _title,
        scale: _scale,
        shape: _shape
      };
      return legendFn;
    };

    legendFn.legendWidth = function (_legendWidth) {
      if (!arguments.length) return legendWidth;
      legendWidth = _legendWidth;
      return legendFn;
    };

    return legendFn;
  }

  function hasOverlaps(corners, compCorners) {
    return corners[2] < compCorners[3] && corners[3] > compCorners[2] && corners[0] < compCorners[1] && corners[1] > compCorners[0];
  }

  function insert_and_check(datum, quadtree) {
    var corners = datum._bbox;
    quadtree._max_width = quadtree._max_width || 0;
    quadtree._max_height = quadtree._max_height || 0;
    datum._occluded = false;
    quadtree["visit"](function (node, x0, y0, x1, y1) {
      if (datum._occluded) {
        return true;
      }

      if (node.length) {
        var box_intersects_quad = hasOverlaps(corners, [x0 - quadtree._max_width / 2, x1 + quadtree._max_width / 2, y0 - quadtree._max_height / 2, y1 + quadtree._max_height / 2]);

        if (!box_intersects_quad) {
          return true;
        } else {
          return undefined;
        }
      } else {
        if (hasOverlaps(corners, node.data._bbox)) {
          datum._occluded = true;
          return "break";
        }
      }
    }, [quadtree.x()(datum), quadtree.y()(datum)]);

    if (!datum._occluded) {
      quadtree.add(datum);

      if (quadtree._max_width < corners[1] - corners[0]) {
        quadtree._max_width = corners[1] - corners[0];
      }

      if (quadtree._max_height < corners[3] - corners[2]) {
        quadtree._max_height = corners[3] - corners[2];
      }
    }
  }

  function formatOcclusion(data) {
    var labels;
    labels = quadtree().x(function (d) {
      return (d._bbox[0] + d._bbox[1]) / 2;
    }).y(function (d) {
      return (d._bbox[2] + d._bbox[3]) / 2;
    }); //labels.extent([-80, -35], [width + 80, height + 35]);

    data.forEach(function (d, i) {
      insert_and_check(d, labels);
      d.order = i;
    });
  }

  function labelsOcclusion(d3Selection, priority) {
    if (priority === void 0) {
      priority = function priority(d) {
        return d.priority;
      };
    }

    if (!d3Selection.size()) return;
    var labels = [];
    d3Selection.each(function (d, i, e) {
      var bbox = e[i].getBoundingClientRect();
      labels.push({
        priority: priority(d) || 0,
        node: e[i],
        _bbox: [bbox.x, bbox.x + bbox.width, bbox.y, bbox.y + bbox.height]
      });
    });
    labels.sort(function (a, b) {
      return descending(a.priority, b.priority);
    });
    formatOcclusion(labels);
    var filled = [];
    labels.forEach(function (d) {
      select$2(d.node).style("opacity", d._occluded ? 0 : 1);
      if (!d._occluded) filled.push(d);
    });
    return filled;
  }

  /** Used for built-in method references. */
  var objectProto$g = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$d = objectProto$g.hasOwnProperty;

  /**
   * The base implementation of `_.has` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHas(object, key) {
    return object != null && hasOwnProperty$d.call(object, key);
  }

  var _baseHas = baseHas;

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */
  function has(object, path) {
    return object != null && _hasPath(object, path, _baseHas);
  }

  var has_1 = has;

  var VERSION = "1";

  function objectsToMatrix(listOfObjects, columns) {
    return listOfObjects.map(function (obj) {
      return columns.map(function (col) {
        return obj[col];
      });
    });
  }

  function matrixToObjects(matrix, columns) {
    return matrix.map(function (record) {
      var obj = {};

      for (var i = 0; i < columns.length; i++) {
        obj[columns[i]] = record[i];
      }

      return obj;
    });
  }

  function serializeProject(_ref) {
    var userInput = _ref.userInput,
        userData = _ref.userData,
        userDataType = _ref.userDataType,
        parseError = _ref.parseError,
        unstackedData = _ref.unstackedData,
        unstackedColumns = _ref.unstackedColumns,
        data = _ref.data,
        separator = _ref.separator,
        thousandsSeparator = _ref.thousandsSeparator,
        decimalsSeparator = _ref.decimalsSeparator,
        locale = _ref.locale,
        stackDimension = _ref.stackDimension,
        dataSource = _ref.dataSource,
        currentChart = _ref.currentChart,
        mapping = _ref.mapping,
        visualOptions = _ref.visualOptions;
    var project = {
      version: "1"
    };
    /* First stage: user input */

    project.userInput = userInput;
    project.userInputFormat = userDataType;
    project.dataSource = dataSource;
    /* Second stage: parsed */

    project.rawData = objectsToMatrix(userData, Object.keys(data.dataTypes));
    project.parseError = parseError;
    project.parseOptions = {
      separator: separator,
      thousandsSeparator: thousandsSeparator,
      decimalsSeparator: decimalsSeparator,
      locale: locale,
      stackDimension: stackDimension,
      unstackedData: unstackedData,
      unstackedColumns: unstackedColumns
    };
    /* Third stage: typed data ready for chart */

    project.dataTypes = data.dataTypes;
    /* Chart: mapping and visual options */

    project.chart = currentChart.metadata.name;
    project.mapping = mapping;
    project.visualOptions = visualOptions;
    return project;
  }

  function getOrError(object, path) {
    if (!has_1(object, path)) {
      console.log("IMPORT ERROR", object, path);
      throw new Error("Selected project is not valid");
    }

    return get_1(object, path);
  }

  function deserializeProject(project, charts) {
    if (project.version !== "1") {
      throw new Error("Invalid version number, please use a suitable deserializer");
    }

    var chartName = getOrError(project, "chart");
    var chart = charts.find(function (c) {
      return c.metadata.name === chartName;
    });

    if (!chart) {
      throw new Error("Unknown chart!");
    }

    return {
      userInput: getOrError(project, "userInput"),
      userData: matrixToObjects(getOrError(project, "rawData"), Object.keys(getOrError(project, "dataTypes"))),
      userDataType: getOrError(project, "userInputFormat"),
      parseError: getOrError(project, "parseError"),
      unstackedData: getOrError(project, "parseOptions.unstackedData"),
      unstackedColumns: getOrError(project, "parseOptions.unstackedColumns"),
      dataTypes: getOrError(project, "dataTypes"),
      separator: getOrError(project, "parseOptions.separator"),
      thousandsSeparator: getOrError(project, "parseOptions.thousandsSeparator"),
      decimalsSeparator: getOrError(project, "parseOptions.decimalsSeparator"),
      locale: getOrError(project, "parseOptions.locale"),
      stackDimension: get_1(project, "parseOptions.stackDimension", undefined),
      dataSource: getOrError(project, "dataSource"),
      currentChart: chart,
      mapping: getOrError(project, "mapping"),
      visualOptions: getOrError(project, "visualOptions")
    };
  }

  var V1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VERSION: VERSION,
    serializeProject: serializeProject,
    deserializeProject: deserializeProject
  });

  var VERSION$1 = "1.1";

  function objectsToMatrix$1(listOfObjects, columns) {
    return listOfObjects.map(function (obj) {
      return columns.map(function (col) {
        return obj[col];
      });
    });
  }

  function matrixToObjects$1(matrix, columns) {
    return matrix.map(function (record) {
      var obj = {};

      for (var i = 0; i < columns.length; i++) {
        obj[columns[i]] = record[i];
      }

      return obj;
    });
  }

  function serializeProject$1(_ref) {
    var userInput = _ref.userInput,
        userData = _ref.userData,
        userDataType = _ref.userDataType,
        parseError = _ref.parseError,
        unstackedData = _ref.unstackedData,
        unstackedColumns = _ref.unstackedColumns,
        data = _ref.data,
        separator = _ref.separator,
        thousandsSeparator = _ref.thousandsSeparator,
        decimalsSeparator = _ref.decimalsSeparator,
        locale = _ref.locale,
        stackDimension = _ref.stackDimension,
        dataSource = _ref.dataSource,
        currentChart = _ref.currentChart,
        mapping = _ref.mapping,
        visualOptions = _ref.visualOptions;
    var project = {
      version: VERSION$1
    };
    /* First stage: user input */

    project.userInput = userInput;
    project.userInputFormat = userDataType;
    project.dataSource = dataSource;
    /* Second stage: parsed */

    project.rawData = objectsToMatrix$1(userData, Object.keys(data.dataTypes));
    project.parseError = parseError;
    project.parseOptions = {
      separator: separator,
      thousandsSeparator: thousandsSeparator,
      decimalsSeparator: decimalsSeparator,
      locale: locale,
      stackDimension: stackDimension,
      unstackedData: unstackedData,
      unstackedColumns: unstackedColumns
    };
    /* Third stage: typed data ready for chart */

    project.dataTypes = data.dataTypes;
    /* Chart: mapping and visual options */

    project.chart = currentChart.metadata.id;
    project.mapping = mapping;
    project.visualOptions = visualOptions;
    return project;
  }

  function getOrError$1(object, path) {
    if (!has_1(object, path)) {
      console.log("IMPORT ERROR", object, path);
      throw new Error("Selected project is not valid");
    }

    return get_1(object, path);
  }

  function deserializeProject$1(project, charts) {
    if (project.version !== VERSION$1) {
      throw new Error("Invalid version number, please use a suitable deserializer");
    }

    var chartId = getOrError$1(project, "chart");
    var chart = charts.find(function (c) {
      return c.metadata.id === chartId;
    });

    if (!chart) {
      throw new Error("Unknown chart!");
    }

    return {
      userInput: getOrError$1(project, "userInput"),
      userData: matrixToObjects$1(getOrError$1(project, "rawData"), Object.keys(getOrError$1(project, "dataTypes"))),
      userDataType: getOrError$1(project, "userInputFormat"),
      parseError: getOrError$1(project, "parseError"),
      unstackedData: getOrError$1(project, "parseOptions.unstackedData"),
      unstackedColumns: getOrError$1(project, "parseOptions.unstackedColumns"),
      dataTypes: getOrError$1(project, "dataTypes"),
      separator: getOrError$1(project, "parseOptions.separator"),
      thousandsSeparator: getOrError$1(project, "parseOptions.thousandsSeparator"),
      decimalsSeparator: getOrError$1(project, "parseOptions.decimalsSeparator"),
      locale: getOrError$1(project, "parseOptions.locale"),
      stackDimension: get_1(project, "parseOptions.stackDimension", undefined),
      dataSource: getOrError$1(project, "dataSource"),
      currentChart: chart,
      mapping: getOrError$1(project, "mapping"),
      visualOptions: getOrError$1(project, "visualOptions")
    };
  }

  var V1_1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VERSION: VERSION$1,
    serializeProject: serializeProject$1,
    deserializeProject: deserializeProject$1
  });

  keyBy_1([V1, V1_1], "VERSION");

  selection.prototype.styles = styles;
  transition.prototype.styles = styles; //other approach
  // export const multiStyles = function (styles) {
  //   return function (selection) {
  //     for (const property in styles) {
  //       selection.style(property, styles[property])
  //     }
  //   }
  // }
  //adapted from https://github.com/gka/d3-jetpack/blob/master/src/st.js

  function styles(name, value) {
    if (typeof name == 'object') {
      for (var key in name) {
        addStyle(this, key, name[key]);
      }

      return this;
    } else if (typeof name === 'function') {
      return this.each(styleFunction(name));
    } else {
      return arguments.length == 1 ? this.style(name) : addStyle(this, name, value);
    }

    function addStyle(sel, style, value) {
      style = style.replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
      var pxStyles = 'top left bottom right padding-top padding-left padding-bottom padding-right border-top b-width border-left-width border-botto-width m border-right-width margin-top margin-left margin-bottom margin-right font-size width stroke-width line-height margin padding border border-radius max-width min-width max-height min-height';

      if (~pxStyles.indexOf(style)) {
        sel.style(style, typeof value == 'function' ? wrapPx(value) : addPx(value));
      } else {
        sel.style(style, value);
      }

      return sel;
    }

    function addPx(d) {
      return d.match ? d : d + 'px';
    }

    function wrapPx(fn) {
      return function () {
        var val = fn.apply(this, arguments);
        return addPx(val);
      };
    }

    function styleFunction(value) {
      return function () {
        var v = value.apply(this, arguments);

        for (var key in v) {
          addStyle(select(this), key, v[key]);
        }
      };
    }
  }

  function render(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      xOrigin,
      yOrigin,
      maxDiameter,
      showStroke,
      showPoints,
      dotsDiameter,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      colorScale,
      showLabelsOutline,
      autoHideLabels,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // x scale

    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType.type === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType.type === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice(); // size scale

    const maxRadius = maxDiameter / 2;
    const size = sqrt$1().domain([0, max(data, d => d.size)]).rangeRound([0, maxRadius]);

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(x)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(y)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['y'].value).styles(styles.axisLabel));
    };

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis);
    const vizLayer = svg.append('g').attr('id', 'viz');

    if (mapping.connectedBy.value) {
      const line$1 = line().x(function (d) {
        return x(d.x);
      }).y(function (d) {
        return y(d.y);
      });
      vizLayer.append('path').attr('d', () => line$1(data.sort((a, b) => {
        return ascending(a.connectedBy, b.connectedBy);
      }))).attr('stroke', 'grey').attr('stroke-width', 0.5).attr('fill', 'none');
    }

    const bubbles = vizLayer.selectAll('g').data(data.sort((a, b) => {
      const sortValueA = mapping.size.value ? size(a.size) : maxRadius;
      const sortValueB = mapping.size.value ? size(b.size) : maxRadius;
      return sortValueB - sortValueA;
    })).join('g');
    bubbles.append('circle').attr('cx', d => x(d.x)).attr('cy', d => y(d.y)).attr('fill', d => {
      return colorScale(d.color);
    }).attr('r', d => {
      return mapping.size.value ? size(d.size) : maxRadius;
    }).attr('stroke', showStroke ? 'white' : 'none');

    if (showPoints) {
      bubbles.append('circle').attr('cx', d => x(d.x)).attr('cy', d => y(d.y)).attr('fill', 'black').attr('r', dotsDiameter / 2);
    }

    const labelsLayer = svg.append('g').attr('id', 'labels');
    labelsLayer.selectAll('g').data(mapping.label.value ? data : []).join('g').attr('transform', d => `translate(${x(d.x)},${y(d.y)})`).append('text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => Array.isArray(d.label) ? d.label : [d.label]).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * 12).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats$1[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(labelsLayer.selectAll('text'), d => d.size);
    }

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      if (mapping.size.value) {
        const legendSizeScale = size.copy();
        legendSizeScale.domain(extent(data, d => d.size)).rangeRound([size(min(data, d => d.size)), maxRadius]);
        chartLegend.addSize(mapping.size.value, legendSizeScale, 'circle');
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    xOrigin: {
      type: 'boolean',
      label: 'Origine des X à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    maxDiameter: {
      type: 'number',
      label: 'Diamètre maximum',
      default: 15,
      step: 1,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showStroke: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      },
      requiredDimensions: ['x', 'y']
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels'
    }
  };

  // http://www.w3.org/TR/CSS21/grammar.html
  // https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
  var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

  var parse = function(css, options){
    options = options || {};

    /**
     * Positional.
     */

    var lineno = 1;
    var column = 1;

    /**
     * Update lineno and column based on `str`.
     */

    function updatePosition(str) {
      var lines = str.match(/\n/g);
      if (lines) lineno += lines.length;
      var i = str.lastIndexOf('\n');
      column = ~i ? str.length - i : column + str.length;
    }

    /**
     * Mark position and patch `node.position`.
     */

    function position() {
      var start = { line: lineno, column: column };
      return function(node){
        node.position = new Position(start);
        whitespace();
        return node;
      };
    }

    /**
     * Store position information for a node
     */

    function Position(start) {
      this.start = start;
      this.end = { line: lineno, column: column };
      this.source = options.source;
    }

    /**
     * Non-enumerable source string
     */

    Position.prototype.content = css;

    /**
     * Error `msg`.
     */

    var errorsList = [];

    function error(msg) {
      var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
      err.reason = msg;
      err.filename = options.source;
      err.line = lineno;
      err.column = column;
      err.source = css;

      if (options.silent) {
        errorsList.push(err);
      } else {
        throw err;
      }
    }

    /**
     * Parse stylesheet.
     */

    function stylesheet() {
      var rulesList = rules();

      return {
        type: 'stylesheet',
        stylesheet: {
          source: options.source,
          rules: rulesList,
          parsingErrors: errorsList
        }
      };
    }

    /**
     * Opening brace.
     */

    function open() {
      return match(/^{\s*/);
    }

    /**
     * Closing brace.
     */

    function close() {
      return match(/^}/);
    }

    /**
     * Parse ruleset.
     */

    function rules() {
      var node;
      var rules = [];
      whitespace();
      comments(rules);
      while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
        if (node !== false) {
          rules.push(node);
          comments(rules);
        }
      }
      return rules;
    }

    /**
     * Match `re` and return captures.
     */

    function match(re) {
      var m = re.exec(css);
      if (!m) return;
      var str = m[0];
      updatePosition(str);
      css = css.slice(str.length);
      return m;
    }

    /**
     * Parse whitespace.
     */

    function whitespace() {
      match(/^\s*/);
    }

    /**
     * Parse comments;
     */

    function comments(rules) {
      var c;
      rules = rules || [];
      while (c = comment()) {
        if (c !== false) {
          rules.push(c);
        }
      }
      return rules;
    }

    /**
     * Parse comment.
     */

    function comment() {
      var pos = position();
      if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;

      var i = 2;
      while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
      i += 2;

      if ("" === css.charAt(i-1)) {
        return error('End of comment missing');
      }

      var str = css.slice(2, i - 2);
      column += 2;
      updatePosition(str);
      css = css.slice(i);
      column += 2;

      return pos({
        type: 'comment',
        comment: str
      });
    }

    /**
     * Parse selector.
     */

    function selector() {
      var m = match(/^([^{]+)/);
      if (!m) return;
      /* @fix Remove all comments from selectors
       * http://ostermiller.org/findcomment.html */
      return trim(m[0])
        .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
        .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m) {
          return m.replace(/,/g, '\u200C');
        })
        .split(/\s*(?![^(]*\)),\s*/)
        .map(function(s) {
          return s.replace(/\u200C/g, ',');
        });
    }

    /**
     * Parse declaration.
     */

    function declaration() {
      var pos = position();

      // prop
      var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
      if (!prop) return;
      prop = trim(prop[0]);

      // :
      if (!match(/^:\s*/)) return error("property missing ':'");

      // val
      var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);

      var ret = pos({
        type: 'declaration',
        property: prop.replace(commentre, ''),
        value: val ? trim(val[0]).replace(commentre, '') : ''
      });

      // ;
      match(/^[;\s]*/);

      return ret;
    }

    /**
     * Parse declarations.
     */

    function declarations() {
      var decls = [];

      if (!open()) return error("missing '{'");
      comments(decls);

      // declarations
      var decl;
      while (decl = declaration()) {
        if (decl !== false) {
          decls.push(decl);
          comments(decls);
        }
      }

      if (!close()) return error("missing '}'");
      return decls;
    }

    /**
     * Parse keyframe.
     */

    function keyframe() {
      var m;
      var vals = [];
      var pos = position();

      while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
        vals.push(m[1]);
        match(/^,\s*/);
      }

      if (!vals.length) return;

      return pos({
        type: 'keyframe',
        values: vals,
        declarations: declarations()
      });
    }

    /**
     * Parse keyframes.
     */

    function atkeyframes() {
      var pos = position();
      var m = match(/^@([-\w]+)?keyframes\s*/);

      if (!m) return;
      var vendor = m[1];

      // identifier
      var m = match(/^([-\w]+)\s*/);
      if (!m) return error("@keyframes missing name");
      var name = m[1];

      if (!open()) return error("@keyframes missing '{'");

      var frame;
      var frames = comments();
      while (frame = keyframe()) {
        frames.push(frame);
        frames = frames.concat(comments());
      }

      if (!close()) return error("@keyframes missing '}'");

      return pos({
        type: 'keyframes',
        name: name,
        vendor: vendor,
        keyframes: frames
      });
    }

    /**
     * Parse supports.
     */

    function atsupports() {
      var pos = position();
      var m = match(/^@supports *([^{]+)/);

      if (!m) return;
      var supports = trim(m[1]);

      if (!open()) return error("@supports missing '{'");

      var style = comments().concat(rules());

      if (!close()) return error("@supports missing '}'");

      return pos({
        type: 'supports',
        supports: supports,
        rules: style
      });
    }

    /**
     * Parse host.
     */

    function athost() {
      var pos = position();
      var m = match(/^@host\s*/);

      if (!m) return;

      if (!open()) return error("@host missing '{'");

      var style = comments().concat(rules());

      if (!close()) return error("@host missing '}'");

      return pos({
        type: 'host',
        rules: style
      });
    }

    /**
     * Parse media.
     */

    function atmedia() {
      var pos = position();
      var m = match(/^@media *([^{]+)/);

      if (!m) return;
      var media = trim(m[1]);

      if (!open()) return error("@media missing '{'");

      var style = comments().concat(rules());

      if (!close()) return error("@media missing '}'");

      return pos({
        type: 'media',
        media: media,
        rules: style
      });
    }


    /**
     * Parse custom-media.
     */

    function atcustommedia() {
      var pos = position();
      var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
      if (!m) return;

      return pos({
        type: 'custom-media',
        name: trim(m[1]),
        media: trim(m[2])
      });
    }

    /**
     * Parse paged media.
     */

    function atpage() {
      var pos = position();
      var m = match(/^@page */);
      if (!m) return;

      var sel = selector() || [];

      if (!open()) return error("@page missing '{'");
      var decls = comments();

      // declarations
      var decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }

      if (!close()) return error("@page missing '}'");

      return pos({
        type: 'page',
        selectors: sel,
        declarations: decls
      });
    }

    /**
     * Parse document.
     */

    function atdocument() {
      var pos = position();
      var m = match(/^@([-\w]+)?document *([^{]+)/);
      if (!m) return;

      var vendor = trim(m[1]);
      var doc = trim(m[2]);

      if (!open()) return error("@document missing '{'");

      var style = comments().concat(rules());

      if (!close()) return error("@document missing '}'");

      return pos({
        type: 'document',
        document: doc,
        vendor: vendor,
        rules: style
      });
    }

    /**
     * Parse font-face.
     */

    function atfontface() {
      var pos = position();
      var m = match(/^@font-face\s*/);
      if (!m) return;

      if (!open()) return error("@font-face missing '{'");
      var decls = comments();

      // declarations
      var decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }

      if (!close()) return error("@font-face missing '}'");

      return pos({
        type: 'font-face',
        declarations: decls
      });
    }

    /**
     * Parse import
     */

    var atimport = _compileAtrule('import');

    /**
     * Parse charset
     */

    var atcharset = _compileAtrule('charset');

    /**
     * Parse namespace
     */

    var atnamespace = _compileAtrule('namespace');

    /**
     * Parse non-block at-rules
     */


    function _compileAtrule(name) {
      var re = new RegExp('^@' + name + '\\s*([^;]+);');
      return function() {
        var pos = position();
        var m = match(re);
        if (!m) return;
        var ret = { type: name };
        ret[name] = m[1].trim();
        return pos(ret);
      }
    }

    /**
     * Parse at rule.
     */

    function atrule() {
      if (css[0] != '@') return;

      return atkeyframes()
        || atmedia()
        || atcustommedia()
        || atsupports()
        || atimport()
        || atcharset()
        || atnamespace()
        || atdocument()
        || atpage()
        || athost()
        || atfontface();
    }

    /**
     * Parse rule.
     */

    function rule() {
      var pos = position();
      var sel = selector();

      if (!sel) return error('selector missing');
      comments();

      return pos({
        type: 'rule',
        selectors: sel,
        declarations: declarations()
      });
    }

    return addParent(stylesheet());
  };

  /**
   * Trim `str`.
   */

  function trim(str) {
    return str ? str.replace(/^\s+|\s+$/g, '') : '';
  }

  /**
   * Adds non-enumerable parent node reference to each node.
   */

  function addParent(obj, parent) {
    var isNode = obj && typeof obj.type === 'string';
    var childParent = isNode ? obj : parent;

    for (var k in obj) {
      var value = obj[k];
      if (Array.isArray(value)) {
        value.forEach(function(v) { addParent(v, childParent); });
      } else if (value && typeof value === 'object') {
        addParent(value, childParent);
      }
    }

    if (isNode) {
      Object.defineProperty(obj, 'parent', {
        configurable: true,
        writable: true,
        enumerable: false,
        value: parent || null
      });
    }

    return obj;
  }

  function formatSelectorName(selector) {
    return selector.replace(/#|\./g, "");
  }

  function formatProperty(dec) {
    return dec.replace(/-(\w)/g, (a, b) => {
      return b.toUpperCase();
    });
  }

  function buildDeclarations(declarations) {
    const formattedDeclarations = {};
    declarations.forEach(dec => {
      if (dec.type !== "declaration") return;
      const property = formatProperty(dec.property);
      return formattedDeclarations[property] = dec.value.replace(/"|'/g, "");
    });
    return formattedDeclarations;
  }

  function convertCSS(cssInput, options) {
    const ast = parse(cssInput);
    const cssInJs = {};
    const pseudoSelectors = {};
    ast.stylesheet.rules.forEach(rule => {
      if (rule.type === "media") {
        const mediaQuery = `@media ${rule.media}`;
        rule.rules.forEach(innerRule => {
          const selectors = innerRule.selectors;
          const declarations = buildDeclarations(innerRule.declarations);
          selectors.forEach(selector => {
            cssInJs[formatSelectorName(selector)] = Object.assign(cssInJs[selector] || {}, {
              [mediaQuery]: declarations
            });
          });
        });
      }

      if (rule.type === "keyframes" && options.convertAnimations) {
        rule.keyframes.forEach(keyframe => {
          const declarations = buildDeclarations(keyframe.declarations);
          keyframe.values.forEach(value => {
            cssInJs[value] = Object.assign(cssInJs[value] || {}, declarations);
          });
        });
      }

      if (rule.type !== "rule") return;
      const declarations = buildDeclarations(rule.declarations);
      rule.selectors.forEach(selector => {
        if (selector.indexOf(":") !== -1) {
          return pseudoSelectors[formatSelectorName(selector)] = declarations;
        }

        return cssInJs[formatSelectorName(selector)] = declarations;
      });
    });
    Object.keys(pseudoSelectors).forEach(key => {
      const split = key.split(/(:+)/);
      cssInJs[split[0]] = Object.assign(cssInJs[split[0]] || {}, {
        [`${split[1]}${split[2]}`]: pseudoSelectors[key]
      });
    });
    return cssInJs;
  }

  var rawStyles = ".axisLabel {\n  font-family: 'Arial, sans-serif';\n  font-size: 12px;\n  fill: #7b7b7b;\n  font-weight: bold;\n}\n\n.axisLine{\n  stroke: #ccc;\n}\n\n.labelPrimary {\n  font-family: 'Arial, sans-serif';\n  font-size: 10px;\n  fill: black;\n  font-weight: bold;\n}\n\n.labelSecondary {\n  font-family: 'Arial, sans-serif';\n  font-size: 10px;\n  fill: black;\n  font-weight: normal;\n}\n\n.labelItalic {\n  font-family: 'Arial, sans-serif';\n  font-size: 10px;\n  fill: black;\n  font-weight: normal;\n  font-style: italic;\n}\n\n.seriesLabel {\n  font-family: 'Arial, sans-serif';\n  font-size: 12px;\n  fill: black;\n  font-weight: bold;\n  dominant-baseline: hanging;\n}\n\n.labelOutline {\n  stroke-width: 2px;\n  paint-order: stroke;\n  stroke: white;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n";

  const styles$1 = convertCSS(rawStyles);

  var bubblechart = {
    metadata,
    dimensions,
    mapData,
    render,
    visualOptions,
    styles: styles$1
  };

  var img$2 = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpolygon class='cls-1' points='24.671 41.145 16.489 37.054 7.706 41.026 7.294 40.114 16.511 35.946 24.329 39.855 32.235 28.076 40.156 23.125 46.1 15.2 46.9 15.8 40.765 23.924 32.856 28.867 24.671 41.145'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3cpolygon class='cls-2' points='40.639 35 32.312 35 24.34 28.024 16.562 28.996 7.613 31.084 7.387 30.109 16.387 28.013 24.66 26.976 32.687 34 40.361 34 45.243 31.071 45.757 31.929 40.639 35'/%3e %3c/g%3e%3c/svg%3e";

  var img$3 = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-10%2c .cls-11%2c .cls-2%2c .cls-5%2c .cls-7%2c .cls-8%2c .cls-9 %7b fill: none%3b stroke-linejoin: round%3b stroke-width: 1.5px%3b %7d .cls-2 %7b stroke: %23161616%3b %7d .cls-3%2c .cls-4 %7b font-size: 10px%3b %7d .cls-12%2c .cls-3%2c .cls-4%2c .cls-6 %7b font-family: Helvetica%3b %7d .cls-12%2c .cls-4%2c .cls-6 %7b isolation: isolate%3b %7d .cls-5 %7b stroke: %2369bda9%3b %7d .cls-10%2c .cls-11%2c .cls-5%2c .cls-7%2c .cls-8%2c .cls-9 %7b stroke-linecap: round%3b %7d .cls-12%2c .cls-6 %7b font-size: 12px%3b fill: %23161616%3b %7d .cls-7 %7b stroke: %239e0142%3b %7d .cls-8 %7b stroke: %23f0704a%3b %7d .cls-9 %7b stroke: %23fedd8d%3b %7d .cls-10 %7b stroke: %23e0f3a1%3b %7d .cls-11 %7b stroke: %235e4fa2%3b %7d .cls-12 %7b letter-spacing: -0.0547em%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg%3e %3cg id='axes'%3e %3cg%3e %3cpath class='cls-2' d='M30.5%2c150v-5.5h280V150'/%3e %3cg%3e %3cline class='cls-2' x1='30' y1='144' x2='30' y2='150'/%3e %3ctext class='cls-3' transform='translate(18.7539 160.1)'%3e1970%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='86.4939' y1='144' x2='86.4939' y2='150'/%3e %3ctext class='cls-4' transform='translate(75.3708 160.1)'%3e1980%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='142.5031' y1='144' x2='142.5031' y2='150'/%3e %3ctext class='cls-4' transform='translate(131.38 160.1)'%3e1990%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='198.4969' y1='144' x2='198.4969' y2='150'/%3e %3ctext class='cls-4' transform='translate(187.3739 160.1)'%3e2000%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='254.5061' y1='144' x2='254.5061' y2='150'/%3e %3ctext class='cls-4' transform='translate(243.3831 160.1)'%3e2010%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='310.5' y1='144' x2='310.5' y2='150'/%3e %3ctext class='cls-4' transform='translate(299.377 160.1)'%3e2020%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-2' d='M24%2c144.5h6.5V7.5H24'/%3e %3cg%3e %3cline class='cls-2' x1='30' y1='144.5' x2='24' y2='144.5'/%3e %3ctext class='cls-3' transform='translate(15.4385 147.7)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='132.0455' x2='24' y2='132.0455'/%3e %3ctext class='cls-3' transform='translate(9.877 135.2455)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='119.5909' x2='24' y2='119.5909'/%3e %3ctext class='cls-3' transform='translate(9.877 122.7909)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='107.1364' x2='24' y2='107.1364'/%3e %3ctext class='cls-3' transform='translate(9.877 110.3364)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='94.6818' x2='24' y2='94.6818'/%3e %3ctext class='cls-3' transform='translate(9.877 97.8818)'%3e80%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='82.2273' x2='24' y2='82.2273'/%3e %3ctext class='cls-3' transform='translate(4.3154 85.4273)'%3e100%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='69.7727' x2='24' y2='69.7727'/%3e %3ctext class='cls-3' transform='translate(4.3154 72.9727)'%3e120%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='57.3182' x2='24' y2='57.3182'/%3e %3ctext class='cls-3' transform='translate(4.3154 60.5182)'%3e140%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='44.8636' x2='24' y2='44.8636'/%3e %3ctext class='cls-3' transform='translate(4.3154 48.0636)'%3e160%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='32.4091' x2='24' y2='32.4091'/%3e %3ctext class='cls-3' transform='translate(4.3154 35.6091)'%3e180%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='19.9545' x2='24' y2='19.9545'/%3e %3ctext class='cls-3' transform='translate(4.3154 23.1545)'%3e200%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='30' y1='7.5' x2='24' y2='7.5'/%3e %3ctext class='cls-3' transform='translate(4.3154 10.7)'%3e220%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='viz-2' data-name='viz'%3e %3cg id='Tape'%3e %3cpath class='cls-5' d='M46.8043%2c123.1815s3.7309-.2191%2c5.5963-.1623%2c3.7309.8722%2c5.5963.5032a16.7749%2c16.7749%2c0%2c0%2c0%2c5.5964-2.7176%2c39.0713%2c39.0713%2c0%2c0%2c0%2c5.6116-4.6682c1.868-1.8227%2c3.7309-6.2888%2c5.5963-6.2679s3.7309%2c4.672%2c5.5963%2c6.3933%2c3.7284%2c3.3276%2c5.5964%2c3.9346%2c3.7436-.3541%2c5.6116-.2927%2c3.7309%2c1.4692%2c5.5963.6609%2c3.7309-3.3288%2c5.5964-5.5109%2c3.7283-6.46%2c5.5963-7.5821%2c3.7436.811%2c5.6116.8477%2c3.7309.3726%2c5.5964-.6272%2c3.7308-3.7015%2c5.5963-5.3714%2c3.7283-4.0183%2c5.5963-4.6477%2c3.7436.7233%2c5.6116.8713%2c3.7309-1.2273%2c5.5964.017%2c3.7308%2c6.3348%2c5.5963%2c7.4492%2c3.7283-1.1926%2c5.5963-.7633%2c3.7437%2c2.7011%2c5.6117%2c3.3387%2c3.7308-.9935%2c5.5963.4866%2c3.7309%2c6.1153%2c5.5963%2c8.3942a45.4179%2c45.4179%2c0%2c0%2c0%2c5.5963%2c5.2794c1.868%2c1.6842%2c3.7437%2c3.7482%2c5.6117%2c4.8254s3.7309.6671%2c5.5963%2c1.6379a38.9481%2c38.9481%2c0%2c0%2c1%2c5.5963%2c4.187c1.8655%2c1.4933%2c3.7283%2c3.55%2c5.5963%2c4.7733a24.9565%2c24.9565%2c0%2c0%2c0%2c5.6117%2c2.5633%2c41.9942%2c41.9942%2c0%2c0%2c0%2c5.5963%2c1.41c1.8654.3885%2c3.7309.6451%2c5.5963.9213s3.7284.5975%2c5.5964.7356%2c3.7436.0645%2c5.6116.0929%2c3.7309.0636%2c5.5963.0776%2c3.7309.0024%2c5.5963.0062%2c5.5964.0163%2c5.5964.0163'/%3e %3ctext class='cls-6' transform='translate(127.13 91.6732)'%3eB%3c/text%3e %3c/g%3e %3cg id='Disc'%3e %3cpath class='cls-7' d='M102.7982%2c143.7251a22.0942%2c22.0942%2c0%2c0%2c0%2c5.5963-1.308%2c19.035%2c19.035%2c0%2c0%2c0%2c5.6116-4.18%2c66.8337%2c66.8337%2c0%2c0%2c0%2c5.5964-7.7476c1.8654-2.7617%2c3.7308-6.3651%2c5.5963-8.8229a49.9309%2c49.9309%2c0%2c0%2c1%2c5.5963-5.9236c1.868-1.8151%2c3.7436-2.6566%2c5.6116-4.9666s3.7309-5.9114%2c5.5964-8.893%2c3.7308-5.8576%2c5.5963-8.9971%2c3.7283-6.3183%2c5.5963-9.84%2c3.7437-6.1943%2c5.6117-11.2908%2c3.7308-14.8091%2c5.5963-19.2883%2c3.7309-5.73%2c5.5963-7.5865%2c3.7283-3.2321%2c5.5963-3.5548%2c3.7437%2c3.4369%2c5.6117%2c1.6186%2c3.7309-8.6046%2c5.5963-12.5285%2c3.7309-9.3636%2c5.5963-11.0149%2c3.7283-.1986%2c5.5963%2c1.1074%2c3.7437%2c3.94%2c5.6117%2c6.7285%2c3.7309%2c6.832%2c5.5963%2c10.0041%2c3.7309%2c7.3579%2c5.5963%2c9.0282%2c3.7284-.9733%2c5.5964.9937%2c3.7436%2c7.0388%2c5.6116%2c10.8083%2c3.7309%2c7.0463%2c5.5963%2c11.8087%2c3.7309%2c11.1635%2c5.5963%2c16.7658%2c3.7284%2c12.6376%2c5.5964%2c16.8484%2c3.7436%2c5.795%2c5.6116%2c8.416%2c3.7309%2c5.6253%2c5.5963%2c7.31%2c3.7309%2c1.5467%2c5.5963%2c2.7988%2c3.7284%2c3.4926%2c5.5964%2c4.7137a41.6052%2c41.6052%2c0%2c0%2c0%2c5.6116%2c2.6128c1.868.8821%2c3.7309%2c1.8576%2c5.5964%2c2.68s3.7308%2c1.51%2c5.5963%2c2.2536a47.7586%2c47.7586%2c0%2c0%2c0%2c5.5963%2c2.2106c1.868.4731%2c3.7436.1154%2c5.6116.6281s3.7309%2c1.9395%2c5.5964%2c2.4481a32.3769%2c32.3769%2c0%2c0%2c0%2c5.5963.6037'/%3e %3ctext class='cls-6' transform='translate(188.0676 13.4009)'%3eC%3c/text%3e %3c/g%3e %3cg id='Download'%3e %3cpath class='cls-8' d='M220.3976%2c142.4535s3.7436-4.0743%2c5.6116-5.9882%2c3.7309-3.689%2c5.5963-5.4954%2c3.7309-4.2049%2c5.5963-5.3433a12.8413%2c12.8413%2c0%2c0%2c1%2c5.5964-1.4873%2c40.3869%2c40.3869%2c0%2c0%2c1%2c5.6116.1213c1.868.0326%2c3.7309.2077%2c5.5963.0747s3.7309-.6649%2c5.5963-.8733a34.4892%2c34.4892%2c0%2c0%2c1%2c5.5964-.3771%2c20.8728%2c20.8728%2c0%2c0%2c1%2c5.6116.9575c1.868.6243%2c3.7309%2c2.0485%2c5.5964%2c2.7879s3.7308.8287%2c5.5963%2c1.6489%2c3.7283%2c2.2034%2c5.5963%2c3.2723%2c3.7436%2c2.1957%2c5.6116%2c3.1412a44.15%2c44.15%2c0%2c0%2c0%2c5.5964%2c2.532%2c49.43%2c49.43%2c0%2c0%2c0%2c5.5963%2c1.2563'/%3e %3ctext class='cls-6' transform='translate(260.8657 117.0849)'%3eE%3c/text%3e %3c/g%3e %3cg id='Other'%3e %3cpath class='cls-9' d='M136.4067%2c142.5184a44.91%2c44.91%2c0%2c0%2c1%2c5.5964-.6172c1.8654.0169%2c3.7308.6662%2c5.5963.7183a49.32%2c49.32%2c0%2c0%2c0%2c5.5963-.4056c1.868-.1616%2c3.7437-.4479%2c5.6117-.564s3.7308-.1406%2c5.5963-.1325%2c3.7309.1667%2c5.5963.1812%2c3.7283.0576%2c5.5963-.0943a39.3276%2c39.3276%2c0%2c0%2c0%2c5.6117-.8172c1.868-.4276%2c3.7309-1.6843%2c5.5963-1.7488s3.7309.9693%2c5.5963%2c1.3619a37.0841%2c37.0841%2c0%2c0%2c0%2c5.5963.9935c1.868.0978%2c3.7437-.4035%2c5.6117-.407s3.7309.4719%2c5.5963.3858a32.1484%2c32.1484%2c0%2c0%2c0%2c5.5963-.9018c1.8655-.4242%2c3.7284-1.3964%2c5.5964-1.643a20.74%2c20.74%2c0%2c0%2c1%2c5.6116.1638c1.868.2627%2c3.7309%2c1.205%2c5.5963%2c1.4122s3.7309-.4837%2c5.5963-.1692%2c3.7284%2c1.9469%2c5.5964%2c2.0566%2c3.7436-1.2284%2c5.6116-1.3982a38.362%2c38.362%2c0%2c0%2c1%2c5.5963.3794c1.8655.1044%2c3.7309.1518%2c5.5963.247s3.7284.2545%2c5.5964.3238%2c3.7436.051%2c5.6116.092%2c3.7309.1261%2c5.5964.1541%2c3.7308.0017%2c5.5963.0133%2c3.7283.0385%2c5.5963.0565%2c3.7436.0808%2c5.6116.0512%2c3.7309-.2087%2c5.5964-.2286%2c5.5963.109%2c5.5963.109'/%3e %3ctext class='cls-6' transform='translate(215.7306 132.8277)'%3eD%3c/text%3e %3c/g%3e %3cg id='Streaming'%3e %3cpath class='cls-10' d='M220.3976%2c143.9418s3.7436-1.0195%2c5.6116-1.3243a55.8679%2c55.8679%2c0%2c0%2c1%2c5.5963-.5049c1.8655-.1154%2c3.7309-.1062%2c5.5963-.1877s3.7284-.2%2c5.5964-.3015%2c3.7436-.1419%2c5.6116-.3075%2c3.7309-.3624%2c5.5963-.6861a36.49%2c36.49%2c0%2c0%2c0%2c5.5963-1.2558%2c54.687%2c54.687%2c0%2c0%2c0%2c5.5964-2.5357c1.868-.8859%2c3.7436-1.9245%2c5.6116-2.7791s3.7309-1.3958%2c5.5964-2.3489%2c3.7308-1.0377%2c5.5963-3.37%2c3.7283-7.1%2c5.5963-10.6222%2c3.7436-7.1053%2c5.6116-10.5094%2c3.7309-6.8811%2c5.5964-9.9151%2c5.5963-8.2889%2c5.5963-8.2889'/%3e %3ctext class='cls-6' transform='translate(300.4017 83.005)'%3eF%3c/text%3e %3c/g%3e %3cg id='Vinyl'%3e %3cpath class='cls-11' d='M46.8043%2c92.51a41.0066%2c41.0066%2c0%2c0%2c0%2c5.5963%2c1.4363%2c13.7111%2c13.7111%2c0%2c0%2c0%2c5.5963-.1485c1.8655-.5557%2c3.7284-.8679%2c5.5964-3.1854s3.7436-8.4926%2c5.6116-10.7193%2c3.7309-4.5155%2c5.5963-2.6413%2c3.7309%2c10.6512%2c5.5963%2c13.8866a14.4226%2c14.4226%2c0%2c0%2c0%2c5.5964%2c5.5258c1.868%2c1.2264%2c3.7436.0146%2c5.6116%2c1.8325s3.7309%2c6.7079%2c5.5963%2c9.0748a25.7173%2c25.7173%2c0%2c0%2c0%2c5.5964%2c5.1268c1.8654%2c1.3533%2c3.7283%2c1.6268%2c5.5963%2c2.9932a63.47%2c63.47%2c0%2c0%2c1%2c5.6116%2c5.2051c1.868%2c1.7861%2c3.7309%2c3.9882%2c5.5964%2c5.5115s3.7308%2c2.2946%2c5.5963%2c3.6284%2c3.7283%2c2.7672%2c5.5963%2c4.374%2c3.7436%2c4.036%2c5.6116%2c5.2671a18.5641%2c18.5641%2c0%2c0%2c0%2c5.5964%2c2.1194%2c34.354%2c34.354%2c0%2c0%2c0%2c5.5963%2c1.1129c1.8654.2162%2c3.7283.1157%2c5.5963.1839s3.7437.1911%2c5.6117.2258%2c3.7308-.0058%2c5.5963-.0174%2c3.7309-.0256%2c5.5963-.0518%2c3.7283-.1164%2c5.5963-.1053%2c3.7437.1266%2c5.6117.172%2c3.7309.0815%2c5.5963.1%2c3.7309-.0014%2c5.5963.0126%2c3.7283.0643%2c5.5963.0712%2c3.7437-.0455%2c5.6117-.0293%2c3.7309.101%2c5.5963.1268%2c3.7309.0161%2c5.5963.028%2c3.7284.0183%2c5.5964.0434%2c3.7436.0857%2c5.6116.107%2c3.7309.0184%2c5.5963.0212%2c3.7309.0354%2c5.5963-.0044%2c3.7284-.1865%2c5.5964-.2341%2c3.7436-.0138%2c5.6116-.0513%2c3.7309-.11%2c5.5963-.1739%2c3.7309-.1315%2c5.5963-.2117%2c3.7284-.1726%2c5.5964-.27%2c3.7436-.2249%2c5.6116-.3132%2c3.7309-.08%2c5.5964-.2162%2c3.7308-.4823%2c5.5963-.6012%2c3.7283-.0646%2c5.5963-.1121%2c3.7436-.1225%2c5.6116-.1728%2c3.7309-.0322%2c5.5964-.1286%2c5.5963-.4494%2c5.5963-.4494'/%3e %3ctext class='cls-12' transform='translate(70.7993 71.2513)'%3eA%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$1 = {
    name: 'Graphique linéaire',
    id: 'rawgraphs.linechart',
    thumbnail: img$3,
    icon: img$2,
    categories: ['Series temporelles', 'correlations'],
    description: 'It displays a quantitative dimension over a continuous interval or time period. Colour can be optionally used to encode an additional quantitative or categorical dimension.' // code: "https://github.com/rawgraphs/raw",
    // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$1 = [{
    id: 'x',
    name: 'Axe X',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: true,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'lines',
    name: 'Lignes',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$1 = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const yAggregator = getDimensionAggregator('y', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'series' in mapping ? null : mapping.series = {
      value: undefined
    };
    'lines' in mapping ? null : mapping.lines = {
      value: undefined
    };
    let results = [];
    rollups(data, v => rollups(v, vv => {
      const item = {
        x: vv[0][mapping.x.value],
        //get the first one since it's grouped
        y: yAggregator(vv.map(d => d[mapping.y.value])),
        // aggregate
        color: colorAggregator(v.map(d => d[mapping.color.value])),
        // aggregate
        series: vv[0][mapping.series.value],
        //get the first one since it's grouped
        lines: vv[0][mapping.lines.value] //get the first one since it's grouped

      };
      results.push(item);
    }, d => d[mapping.x.value].toString() // sub-group functions. toString() to enable grouping on dates
    ), d => d[mapping.series.value], // series grouping
    d => d[mapping.lines.value] // group functions
    );
    return results;
  };

  function ascending$7(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector$2(compare) {
    if (compare.length === 1) compare = ascendingComparator$2(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator$2(f) {
    return function(d, x) {
      return ascending$7(f(d), x);
    };
  }

  var ascendingBisect$2 = bisector$2(ascending$7);
  var bisectRight$2 = ascendingBisect$2.right;

  var e10$2 = Math.sqrt(50),
      e5$2 = Math.sqrt(10),
      e2$2 = Math.sqrt(2);

  function ticks$2(start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  }

  function tickIncrement$1(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1);
  }

  function tickStep$2(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10$2) step1 *= 10;
    else if (error >= e5$2) step1 *= 5;
    else if (error >= e2$2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  var array$7 = Array.prototype;

  var map$5 = array$7.map;
  var slice$6 = array$7.slice;

  function define$2(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend$2(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color$2() {}

  var darker$2 = 0.7;
  var brighter$2 = 1 / darker$2;

  var reI$2 = "\\s*([+-]?\\d+)\\s*",
      reN$2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP$2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex$2 = /^#([0-9a-f]{3,8})$/,
      reRgbInteger$2 = new RegExp("^rgb\\(" + [reI$2, reI$2, reI$2] + "\\)$"),
      reRgbPercent$2 = new RegExp("^rgb\\(" + [reP$2, reP$2, reP$2] + "\\)$"),
      reRgbaInteger$2 = new RegExp("^rgba\\(" + [reI$2, reI$2, reI$2, reN$2] + "\\)$"),
      reRgbaPercent$2 = new RegExp("^rgba\\(" + [reP$2, reP$2, reP$2, reN$2] + "\\)$"),
      reHslPercent$2 = new RegExp("^hsl\\(" + [reN$2, reP$2, reP$2] + "\\)$"),
      reHslaPercent$2 = new RegExp("^hsla\\(" + [reN$2, reP$2, reP$2, reN$2] + "\\)$");

  var named$2 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define$2(Color$2, color$3, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex$2, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex$2,
    formatHsl: color_formatHsl$2,
    formatRgb: color_formatRgb$2,
    toString: color_formatRgb$2
  });

  function color_formatHex$2() {
    return this.rgb().formatHex();
  }

  function color_formatHsl$2() {
    return hslConvert$2(this).formatHsl();
  }

  function color_formatRgb$2() {
    return this.rgb().formatRgb();
  }

  function color$3(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex$2.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$2(m) // #ff0000
        : l === 3 ? new Rgb$2((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba$2(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba$2((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger$2.exec(format)) ? new Rgb$2(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent$2.exec(format)) ? new Rgb$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger$2.exec(format)) ? rgba$2(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent$2.exec(format)) ? rgba$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named$2.hasOwnProperty(format) ? rgbn$2(named$2[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb$2(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn$2(n) {
    return new Rgb$2(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba$2(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb$2(r, g, b, a);
  }

  function rgbConvert$2(o) {
    if (!(o instanceof Color$2)) o = color$3(o);
    if (!o) return new Rgb$2;
    o = o.rgb();
    return new Rgb$2(o.r, o.g, o.b, o.opacity);
  }

  function rgb$3(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$2(r) : new Rgb$2(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb$2(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define$2(Rgb$2, rgb$3, extend$2(Color$2, {
    brighter: function(k) {
      k = k == null ? brighter$2 : Math.pow(brighter$2, k);
      return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker$2 : Math.pow(darker$2, k);
      return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex$2, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex$2,
    formatRgb: rgb_formatRgb$2,
    toString: rgb_formatRgb$2
  }));

  function rgb_formatHex$2() {
    return "#" + hex$2(this.r) + hex$2(this.g) + hex$2(this.b);
  }

  function rgb_formatRgb$2() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex$2(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla$2(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl$2(h, s, l, a);
  }

  function hslConvert$2(o) {
    if (o instanceof Hsl$2) return new Hsl$2(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$2)) o = color$3(o);
    if (!o) return new Hsl$2;
    if (o instanceof Hsl$2) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$2(h, s, l, o.opacity);
  }

  function hsl$4(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$2(h) : new Hsl$2(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl$2(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define$2(Hsl$2, hsl$4, extend$2(Color$2, {
    brighter: function(k) {
      k = k == null ? brighter$2 : Math.pow(brighter$2, k);
      return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker$2 : Math.pow(darker$2, k);
      return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb$2(
        hsl2rgb$2(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb$2(h, m1, m2),
        hsl2rgb$2(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb$2(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  function constant$h(x) {
    return function() {
      return x;
    };
  }

  function linear$5(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential$3(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function gamma$3(y) {
    return (y = +y) === 1 ? nogamma$2 : function(a, b) {
      return b - a ? exponential$3(a, b, y) : constant$h(isNaN(a) ? b : a);
    };
  }

  function nogamma$2(a, b) {
    var d = b - a;
    return d ? linear$5(a, d) : constant$h(isNaN(a) ? b : a);
  }

  var rgb$4 = (function rgbGamma(y) {
    var color = gamma$3(y);

    function rgb(start, end) {
      var r = color((start = rgb$3(start)).r, (end = rgb$3(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma$2(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb.gamma = rgbGamma;

    return rgb;
  })(1);

  function numberArray$2(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray$2(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function genericArray$2(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue$1(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date$3(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function reinterpolate$1(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object$3(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue$1(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA$2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB$2 = new RegExp(reA$2.source, "g");

  function zero$2(b) {
    return function() {
      return b;
    };
  }

  function one$2(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string$1(a, b) {
    var bi = reA$2.lastIndex = reB$2.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA$2.exec(a))
        && (bm = reB$2.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: reinterpolate$1(am, bm)});
      }
      bi = reB$2.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one$2(q[0].x)
        : zero$2(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolateValue$1(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$h(b)
        : (t === "number" ? reinterpolate$1
        : t === "string" ? ((c = color$3(b)) ? (b = c, rgb$4) : string$1)
        : b instanceof color$3 ? rgb$4
        : b instanceof Date ? date$3
        : isNumberArray$2(b) ? numberArray$2
        : Array.isArray(b) ? genericArray$2
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$3
        : reinterpolate$1)(a, b);
  }

  function interpolateRound$2(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  function constant$i(x) {
    return function() {
      return x;
    };
  }

  function number$5(x) {
    return +x;
  }

  var unit$2 = [0, 1];

  function deinterpolateLinear$1(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant$i(b);
  }

  function deinterpolateClamp$1(deinterpolate) {
    return function(a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
    };
  }

  function reinterpolateClamp$1(reinterpolate) {
    return function(a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
    };
  }

  function bimap$2(domain, range, deinterpolate, reinterpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
    else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap$2(domain, range, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight$2(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy$3(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous$2(deinterpolate, reinterpolate) {
    var domain = unit$2,
        range = unit$2,
        interpolate = interpolateValue$1,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap$2 : bimap$2;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp$1(deinterpolate) : deinterpolate, interpolate)))(+x);
    }

    scale.invert = function(y) {
      return (input || (input = piecewise(range, domain, deinterpolateLinear$1, clamp ? reinterpolateClamp$1(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$5.call(_, number$5), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice$6.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice$6.call(_), interpolate = interpolateRound$2, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    return rescale();
  }

  function formatDecimal$3(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts$2(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent$4(x) {
    return x = formatDecimalParts$2(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup$3(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals$2(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re$3 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier$3(specifier) {
    if (!(match = re$3.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier$3({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier$3.prototype = FormatSpecifier$3.prototype; // instanceof

  function FormatSpecifier$3(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier$3.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim$2(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent$3;

  function formatPrefixAuto$3(x, p) {
    var d = formatDecimalParts$2(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent$3 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts$2(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded$3(x, p) {
    var d = formatDecimalParts$2(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes$3 = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": formatDecimal$3,
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded$3(x * 100, p); },
    "r": formatRounded$3,
    "s": formatPrefixAuto$3,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$d(x) {
    return x;
  }

  var map$6 = Array.prototype.map,
      prefixes$3 = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale$4(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$d : formatGroup$3(map$6.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$d : formatNumerals$2(map$6.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "-" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier$3(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes$3[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes$3[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim$2(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes$3[8 + prefixExponent$3 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier$3(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent$4(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes$3[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale$4;
  var format$3;
  var formatPrefix$2;

  defaultLocale$4({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    minus: "-"
  });

  function defaultLocale$4(definition) {
    locale$4 = formatLocale$4(definition);
    format$3 = locale$4.format;
    formatPrefix$2 = locale$4.formatPrefix;
    return locale$4;
  }

  function precisionFixed$2(step) {
    return Math.max(0, -exponent$4(Math.abs(step)));
  }

  function precisionPrefix$2(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$4(value) / 3))) * 3 - exponent$4(Math.abs(step)));
  }

  function precisionRound$2(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent$4(max) - exponent$4(step)) + 1;
  }

  function tickFormat$2(domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = tickStep$2(start, stop, count == null ? 10 : count),
        precision;
    specifier = formatSpecifier$3(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix$2(step, value))) specifier.precision = precision;
        return formatPrefix$2(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound$2(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed$2(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format$3(specifier);
  }

  function linearish$2(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks$2(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      return tickFormat$2(domain(), count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain(),
          i0 = 0,
          i1 = d.length - 1,
          start = d[i0],
          stop = d[i1],
          step;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }

      step = tickIncrement$1(start, stop, count);

      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement$1(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement$1(start, stop, count);
      }

      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear$6() {
    var scale = continuous$2(deinterpolateLinear$1, reinterpolate$1);

    scale.copy = function() {
      return copy$3(scale, linear$6());
    };

    return linearish$2(scale);
  }

  function brick(nodes, v) {

    if(!v.shiftX) {
      v.shiftX = 1/2;
    }

    if(!v.shiftY) {
      v.shiftY = 1/2;
    }

    var _cols = Math.ceil(Math.sqrt(nodes.length));
    var _rows = Math.ceil(nodes.length / _cols);

    v.x.domain([0, _cols]).range([0, v.size[0] - v.size[0] / _cols]);
    v.y.domain([0, _rows]).range([0, v.size[1] - v.size[1] / _rows]);

    nodes.forEach(function(n, i) {

      var col = i % _cols;
      var row = Math.floor(i / _cols);

      n[v.__x] = v.x(col) + v.offset[0] + v.padding;
      n[v.__y] = v.y(row) + v.offset[1] + v.padding;

      n[v.__width] = v.x.range()[1] / _cols - 2 * v.padding;
      n[v.__height] = v.y.range()[1] / _rows - 2 * v.padding;

      if(v.orient === "left") {
        if(row % 2 === 1) {
          n[v.__x] += n[v.__width] * v.shiftX;
        }
      } else if(v.orient === "up") {
        if(col % 2 === 1) {
          n[v.__y] += n[v.__height] * v.shiftY;
        }
      } else if(v.orient === "down") {
        if(col % 2 === 0) {
          n[v.__y] += n[v.__height] * v.shiftY;
        }
      } else if(v.orient === "right") {
        if(row % 2 === 0) {
          n[v.__x] += n[v.__width] * v.shiftX;
        }
      } else if(v.orient === "none") {
        n[v.__x] += 0;
        n[v.__y] += 0;
      } else { // default right
        if(row % 2 === 0) {
          n[v.__x] += n[v.__width] * v.shiftX;
        }
      }

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function central(nodes, v) {

    nodes.forEach(function(n) {

      n[v.__x] = 0 + v.padding + v.offset[0];
      n[v.__y] = 0 + v.padding + v.offset[1];

      n[v.__width] = v.size[0] - 2 * v.padding;
      n[v.__height] = v.size[1] - 2 * v.padding;

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

      n[v.__tx] = n[v.__cx] / 2;
      n[v.__ty] = v.padding / 2;

      n[v.__lx] = n[v.__cx] + v.padding / 2;
      n[v.__ly] = 0;

      n[v.__rx] = n[v.__cx] - v.padding / 2;
      n[v.__ry] = n[v.__yx] / 2;
    });

    return nodes;
  }

  function cascade(nodes, v) {

    var shiftX = v.size[0] / (2 * nodes.length);
    var shiftY = v.size[1] / (2 * nodes.length);

    nodes.forEach(function(n, i) {

      n[v.__x] = 0 + v.offset[0] + shiftX * i;
      n[v.__y] = 0 + v.offset[1] + shiftY * i;

      n[v.__width] = v.size[0] - shiftX * nodes.length;
      n[v.__height] = v.size[1] - shiftY * nodes.length;

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function margin(v, type) {
    if (typeof v.margin === "object") {
      if (type === "vertical") return margin(v, "top") + margin(v, "bottom");
      if (type === "horizontal") return margin(v, "left") + margin(v, "right");
      return +v.margin[type] || 0;
    } else {
      return +v.margin || 0;
    }
  }

  function coordinate(nodes, v) {

    var _valueX, _valueXmax;

    // Create random data if no value function has been set
    if(!v.valueX) {
      _valueX = function() { return Math.random(); };
      _valueXmax = 1;
    } else if(typeof v.valueX === "function" && typeof v.valueX(nodes[0]) === "string" && v.valueX(nodes[0]).indexOf("px") === v.valueX(nodes[0]).length - 2) {
      _valueX = function(d) { return +v.valueX(d).replace("px", ""); };
      _valueXmax = v.size[0];
    } else if(typeof v.valueX === "string") {
      _valueX = function(d) { return d[v.valueX]; };
      _valueXmax = max(nodes, _valueX);
    } else {
      _valueX = v.valueX;
      _valueXmax = max(nodes, _valueX);
    }

    v.x.domain([0, _valueXmax]).range([margin(v, "left") + v.padding, v.size[0] - margin(v, "right") - v.padding]);

    var _valueY, _valueYmax;

    // Same as for X, create random data for vertical axis
    if(!v.valueY) {
      _valueY = function() { return Math.random(); };
      _valueYmax = 1;
    } else if(typeof v.valueY === "function" && typeof v.valueY(nodes[0]) === "string" && v.valueY(nodes[0]).indexOf("px") === v.valueY(nodes[0]).length - 2) {
      _valueY = function(d) { return +v.valueY(d).replace("px", ""); };
      _valueYmax = v.size[1] - margin(v, "left");
    } else if(typeof v.valueY === "string") {
      _valueY = function(d) { return d[v.valueY]; };
      _valueYmax = max(nodes, _valueY);
    } else {
      _valueY = v.valueY;
      _valueYmax = max(nodes, v.valueY);
    }

    v.y.domain([0, _valueYmax]).range([margin(v, "top") + v.padding, v.size[1] - margin(v, "bottom") - v.padding]);

    var _valueWidth;

    if(!v.valueWidth) {
      _valueWidth = function() { return 1; };
      v.width.domain([0, nodes.length]);
    } else if(typeof v.valueWidth === "function" && typeof v.valueWidth(nodes[0]) === "string" && v.valueWidth(nodes[0]).indexOf("px") === v.valueWidth(nodes[0]).length - 2) {
      _valueWidth = function(d) { return +v.valueWidth(d).replace("px", ""); };
      v.width.domain([0, _valueXmax]);
    } else if(typeof v.valueWidth === "string") {
      _valueWidth = function(d) { return d[v.valueWidth]; };
      v.width.domain([0, _valueXmax]);
    } else if(typeof v.valueWidth === "number") { // proportion
      _valueWidth = function() { return v.valueWidth; };
      v.width.domain([0, v.size[0]]);
    } else { // function
      _valueWidth = v.valueWidth;
      v.width.domain([0, _valueXmax]);
    }
    v.width.range([0, v.size[0] - margin(v, "horizontal") - 2 * v.padding]);

    var _valueHeight;

    if(!v.valueHeight) {
      _valueHeight = function() { return 1; };
      v.height.domain([0, nodes.length]).range([0, v.size[1]]);
    } else if(typeof v.valueHeight === "function" && typeof v.valueHeight(nodes[0]) === "string" && v.valueHeight(nodes[0]).indexOf("px") === v.valueHeight(nodes[0]).length - 2) {
      _valueHeight = function(d) { return +v.valueHeight(d).replace("px", ""); };
      v.height.domain([0, _valueYmax]);
    } else if(typeof v.valueWidth === "string") { // pixels
      _valueHeight = function(d) { return d[v.valueHeight]; };
      v.height.domain([0, _valueYmax]);
    } else if(typeof v.valueWidth === "number") { // proportion
      _valueHeight = function() { return v.valueHeight; };
      v.height.domain([0, v.size[0]]);
    } else { // function
      _valueHeight = v.valueHeight;
      v.height.domain([0, _valueYmax]);
    }
    v.height.range([0, v.size[1] - margin(v, "vertical") - 2 * v.padding]);

    // Preveting overflows
    // v.x.range([0, v.size[0] - v.width(_valueWidth(nodes[0]))]);
    // v.width.range([0, v.size[0] - v.width(_valueWidth(nodes[0]))]);
    // v.y.range([0, v.size[1] - v.height(_valueHeight(nodes[0]))]);
    // v.height.range([0, v.size[1] - v.height(_valueHeight(nodes[0]))]);

    nodes.forEach(function(n) {


      n[v.__x] = v.x(_valueX(n)) + v.offset[0];
      n[v.__y] = v.y(_valueY(n)) + v.offset[1];

      n[v.__width] = v.width(_valueWidth(n));
      n[v.__height] = v.height(_valueHeight(n));

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

    });

    return nodes;
  }

  function corner(nodes, v) {

    var shiftX = v.size[0] / (2 * nodes.length);
    var shiftY = v.size[1] / (2 * nodes.length);

    var _valueWidth;

    if(!v.valueWidth) {
      _valueWidth = function(d, i) { return i; };
      v.width.domain([0, nodes.length]).range([0, v.size[0] - 2 * v.padding]);
    } else if(typeof v.valueWidth === "number") {
      _valueWidth = function() { return v.valueWidth; };
      v.width.domain([0, v.size[0]]).range([0, v.size[0] - 2 * v.padding]);
    } else {
      _valueWidth = v.valueWidth;
      v.width.domain([0, max(nodes, _valueWidth)]).range([0, v.size[0] - 2 * v.padding]);
    }

    var _valueHeight;

    if(!v.valueHeight) {
      _valueHeight = function(d, i) { return i; };
      v.height.domain([0, nodes.length]).range([0, v.size[1] - 2 * v.padding]);
    } else if(typeof v.valueHeight === "number") {
      _valueHeight = function() { return v.valueHeight; };
      v.height.domain([0, v.size[1]]).range([0, v.size[1] - 2 * v.padding]);
    } else {
      _valueHeight = v.valueHeight;
      v.height.domain([0, max(nodes, _valueHeight)]).range([0, v.size[1] - 2 * v.padding]);
    }

    nodes.forEach(function(n, i) {

      n[v.__width] = v.size[0] - shiftX * i * 2;
      n[v.__height] = v.size[1] - shiftY * i * 2;

      if(v.orient === "top right") {

        n[v.__x] = v.size[0] - n.width + v.offset[0];
        n[v.__y] = 0 + v.offset[1];

      } else if(v.orient === "bottom right") {

        n[v.__x] = v.size[0] - n[v.__width] + v.offset[0];
        n[v.__y] = v.size[1] - n[v.__height] + v.offset[1];

      } else if(v.orient === "bottom left") {

        n[v.__x] = 0 + v.offset[0];
        n[v.__y] = v.size[1] - n[v.__height] + v.offset[1];

      } else if(v.orient === "top") {

        n[v.__width] = v.width(_valueWidth(n, i)) - margin(v, "horizontal");
        n[v.__height] = v.height(_valueHeight(n, i)) - margin(v, "vertical");

        n[v.__x] = 0 + v.offset[0] + (v.size[0] / 2) - (n[v.__width] / 2) + v.padding;
        n[v.__y] = 0 + v.offset[1] + v.padding;

      } else if(v.orient === "bottom") {

        n[v.__width] = v.width(_valueWidth(n, i)) - margin(v, "horizontal");
        n[v.__height] = v.size[1] - 10 - 3*i;// v.height(_valueHeight(n, i)) - margin(v, "vertical");

        n[v.__x] = 0 + v.offset[0] + (v.size[0] / 2) - (n[v.__width] / 2) + 2 * i;
        n[v.__y] = 0 + v.offset[1] + v.size[1] - n[v.__height];

      } else if(v.orient === "middle") {

        n[v.__width] = v.width(_valueWidth(n, i)) - margin(v, "horizontal");
        n[v.__height] = v.height(_valueHeight(n, i)) - margin(v, "vertical");

        n[v.__x] = 0 + v.offset[0] + (v.size[0] / 2) - (n[v.__width] / 2);
        n[v.__y] = 0 + v.offset[1] + (v.size[1] / 2) - (n[v.__height] / 2);

      } else { // default top

        n[v.__x] = 0 + v.offset[0];
        n[v.__y] = 0 + v.offset[1];
        n[v.__width] = v.width(_valueWidth(n, i)) - margin(v, "horizontal");
        n[v.__height] = v.height(_valueHeight(n, i)) - margin(v, "vertical");

      }

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function diagonal(nodes, v) {

    v.x.domain([0, nodes.length]).range([0, v.size[0]]);
    v.y.domain([0, nodes.length]).range([0, v.size[1]]);

    nodes.forEach(function(n, i) {

      if(v.orient == "up") {
        n[v.__x] = v.x(i) + v.offset[0] + v.padding;
        n[v.__y] = v.size[1] - (v.y(i) + v.offset[1]) - v.size[1] / nodes.length + v.padding;
      } else {
        n[v.__x] = v.x(i) + v.offset[0] + v.padding;
        n[v.__y] = v.y(i) + v.offset[1] + v.padding;
      }

      n[v.__width] = v.size[0] / nodes.length - 2 * v.padding;
      n[v.__height] = v.size[1] / nodes.length - 2 * v.padding;

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function grid(nodes, v) {

    if(v.sort) {
      nodes = nodes.sort(v.sort);
    }

    var _cols;

    if(!v.cols) {
      _cols = Math.ceil(Math.sqrt(nodes.length));
    } else {
      _cols = v.cols;
    }

    var _rows;

    if(!v.rows) {
      _rows = Math.ceil(nodes.length / _cols);
    } else {
      _rows = v.rows;
    }

    if(v.cellSize) {
      v.size[0] = v.cellSize[0] * _cols;
      v.size[1] = v.cellSize[1] * _rows;
    }

    v.width.domain([0, nodes.length]).range([margin(v, "left"), v.size[0] - v.padding - margin(v, "horizontal")]);
    v.height.domain([0, 1]).range([0, v.size[1] - v.padding - margin(v, "vertical")]);

    v.x.domain([0, _cols]).range([margin(v, "left"), v.size[0] - margin(v, "right")]);
    v.y.domain([0, _rows]).range([margin(v, "top"), v.size[1] - margin(v, "bottom")]);

    nodes.forEach(function(n, i) {

      var col = i % _cols;
      var row = Math.floor(i / _cols);

      n[v.__x] = v.x(col) + v.offset[0] + v.padding;
      n[v.__y] = v.y(row) + v.offset[1] + v.padding;

      n[v.__width] = (v.size[0] - margin(v, "horizontal")) / _cols - 2 * v.padding ;
      n[v.__height] = (v.size[1] - margin(v, "vertical")) / _rows - 2 * v.padding;

      if(v.orient == "up") {
        n[v.__y] = v.size[1] - n[v.__y] - n[v.__height];
      } else if(v.orient == "down") {
        n[v.__y] = v.y(row) + v.offset[1] + v.padding;
      } else if(v.orient == "left") {
        n[v.__y] = v.y(row) + v.offset[1] + v.padding;
      } else if(v.orient == "right") {
        n[v.__y] = v.y(row) + v.offset[1] + v.padding;
      } else { // default down
        n[v.__y] = v.y(row) + v.offset[1] + v.padding;
      }

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

      n.tx = n[v.__x] + n[v.__width] / 2;
      n.ty = v.padding / 2;
    });

    return nodes;
  }

  function constant$j(x) {
    return function() {
      return x;
    };
  }

  function horizontal(nodes, v) {

    if (v.sort) {
      nodes = nodes.sort(v.sort);
    }

    var _valueHeight = v.valueHeight ? v.valueHeight : constant$j(1),
        _valueWidth = v.valueWidth ? v.valueWidth : constant$j(1),
        heights = nodes.map(_valueHeight),
        widths = nodes.map(_valueWidth);
    
    v.height.domain([0, sum(heights)])
      .range([0, max([1, v.size[1] - 2 * v.padding - nodes.length * (margin(v,"top") + margin(v,"bottom"))])]);

    v.width.domain([0, max(widths)])
      .range([0, max([1, v.size[0] - 2 * v.padding - (margin(v, "left") + margin(v, "right"))])]);

    if (nodes.length > 0) {
      nodes[0].y0 = v.padding;
    }

    nodes.forEach(function(n, i) {

      n[v.__y] = n.y0 + v.offset[1] + (i+1) * (margin(v, "top")) + i * margin(v, "bottom");

      if(v.orient === "right") {
        n[v.__x] = 0 + v.offset[0] + v.padding + margin(v, "left");
      } else if(v.orient === "left") {
        n[v.__x] = v.size[0] - v.width(widths[i])  + v.offset[0] - v.padding + margin(v, "right");
     } else if(v.orient === "up") {
        n[v.__x] = 0 + v.offset[0] + v.padding + margin(v, "left");
       // n[v.__y] = v.size[1] - n.y0 - v.height(heights[i]) - v.offset[1] - margin(v, "top");
      } else if(v.orient === "center") {
        n[v.__x] = (v.size[0] / 2) - v.width(widths[i]) / 2 + v.offset[0] + margin(v, "left");
      } else { // defaut right
        n[v.__x] = 0 + v.offset[0] + v.padding + margin(v, "left");
      }

      n[v.__width] = v.width(widths[i]);
      n[v.__height] = v.height(heights[i]);

      // Updates the next node's y0 for all nodes but the last one
      if(i < nodes.length - 1) {
        nodes[i+1].y0 = n.y0 + n[v.__height];
      }

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

    });

    return nodes;
  }

  function identity$e(nodes, v) {

    nodes.forEach(function(n) {

      n[v.__x] = n[v.__x] || 0;
      n[v.__y] = n[v.__y] || 0;

      n[v.__width] = n[v.__width] || v.size[0];
      n[v.__height] = n[v.__height] || v.size[1];

      n[v.__cx] = n[v.__cx] || n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__cy] || n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function count$2(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;
    else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  function node_count$1() {
    return this.eachAfter(count$2);
  }

  function node_each$1(callback) {
    var node = this, current, next = [node], children, i, n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        callback(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    } while (next.length);
    return this;
  }

  function node_eachBefore$1(callback) {
    var node = this, nodes = [node], children, i;
    while (node = nodes.pop()) {
      callback(node), children = node.children;
      if (children) for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
    return this;
  }

  function node_eachAfter$1(callback) {
    var node = this, nodes = [node], next = [], children, i, n;
    while (node = nodes.pop()) {
      next.push(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  }

  function node_sum$1(value) {
    return this.eachAfter(function(node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort$1(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path$1(end) {
    var start = this,
        ancestor = leastCommonAncestor$1(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }

  function leastCommonAncestor$1(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors$1() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants$1() {
    var nodes = [];
    this.each(function(node) {
      nodes.push(node);
    });
    return nodes;
  }

  function node_leaves$1() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links$1() {
    var root = this, links = [];
    root.each(function(node) {
      if (node !== root) { // Don’t include the root’s parent, if any.
        links.push({source: node.parent, target: node});
      }
    });
    return links;
  }

  function hierarchy$1(data, children) {
    var root = new Node$2(data),
        valued = +data.value && (root.value = data.value),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    if (children == null) children = defaultChildren;

    while (node = nodes.pop()) {
      if (valued) node.value = +node.data.value;
      if ((childs = children(node.data)) && (n = childs.length)) {
        node.children = new Array(n);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new Node$2(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight$1);
  }

  function node_copy$1() {
    return hierarchy$1(this).eachBefore(copyData$1);
  }

  function defaultChildren(d) {
    return d.children;
  }

  function copyData$1(node) {
    node.data = node.data.data;
  }

  function computeHeight$1(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && (node.height < ++height));
  }

  function Node$2(data) {
    this.data = data;
    this.depth =
    this.height = 0;
    this.parent = null;
  }

  Node$2.prototype = hierarchy$1.prototype = {
    constructor: Node$2,
    count: node_count$1,
    each: node_each$1,
    eachAfter: node_eachAfter$1,
    eachBefore: node_eachBefore$1,
    sum: node_sum$1,
    sort: node_sort$1,
    path: node_path$1,
    ancestors: node_ancestors$1,
    descendants: node_descendants$1,
    leaves: node_leaves$1,
    links: node_links$1,
    copy: node_copy$1
  };

  var slice$7 = Array.prototype.slice;

  function shuffle$2(array) {
    var m = array.length,
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }

    return array;
  }

  function enclose$1(circles) {
    var i = 0, n = (circles = shuffle$2(slice$7.call(circles))).length, B = [], p, e;

    while (i < n) {
      p = circles[i];
      if (e && enclosesWeak$1(e, p)) ++i;
      else e = encloseBasis$1(B = extendBasis$1(B, p)), i = 0;
    }

    return e;
  }

  function extendBasis$1(B, p) {
    var i, j;

    if (enclosesWeakAll$1(p, B)) return [p];

    // If we get here then B must have at least one element.
    for (i = 0; i < B.length; ++i) {
      if (enclosesNot$1(p, B[i])
          && enclosesWeakAll$1(encloseBasis2$1(B[i], p), B)) {
        return [B[i], p];
      }
    }

    // If we get here then B must have at least two elements.
    for (i = 0; i < B.length - 1; ++i) {
      for (j = i + 1; j < B.length; ++j) {
        if (enclosesNot$1(encloseBasis2$1(B[i], B[j]), p)
            && enclosesNot$1(encloseBasis2$1(B[i], p), B[j])
            && enclosesNot$1(encloseBasis2$1(B[j], p), B[i])
            && enclosesWeakAll$1(encloseBasis3$1(B[i], B[j], p), B)) {
          return [B[i], B[j], p];
        }
      }
    }

    // If we get here then something is very wrong.
    throw new Error;
  }

  function enclosesNot$1(a, b) {
    var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }

  function enclosesWeak$1(a, b) {
    var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function enclosesWeakAll$1(a, B) {
    for (var i = 0; i < B.length; ++i) {
      if (!enclosesWeak$1(a, B[i])) {
        return false;
      }
    }
    return true;
  }

  function encloseBasis$1(B) {
    switch (B.length) {
      case 1: return encloseBasis1$1(B[0]);
      case 2: return encloseBasis2$1(B[0], B[1]);
      case 3: return encloseBasis3$1(B[0], B[1], B[2]);
    }
  }

  function encloseBasis1$1(a) {
    return {
      x: a.x,
      y: a.y,
      r: a.r
    };
  }

  function encloseBasis2$1(a, b) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
        l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x1 + x2 + x21 / l * r21) / 2,
      y: (y1 + y2 + y21 / l * r21) / 2,
      r: (l + r1 + r2) / 2
    };
  }

  function encloseBasis3$1(a, b, c) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x3 = c.x, y3 = c.y, r3 = c.r,
        a2 = x1 - x2,
        a3 = x1 - x3,
        b2 = y1 - y2,
        b3 = y1 - y3,
        c2 = r2 - r1,
        c3 = r3 - r1,
        d1 = x1 * x1 + y1 * y1 - r1 * r1,
        d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
        d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
        ab = a3 * b2 - a2 * b3,
        xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
        xb = (b3 * c2 - b2 * c3) / ab,
        ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
        yb = (a2 * c3 - a3 * c2) / ab,
        A = xb * xb + yb * yb - 1,
        B = 2 * (r1 + xa * xb + ya * yb),
        C = xa * xa + ya * ya - r1 * r1,
        r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
    return {
      x: x1 + xa + xb * r,
      y: y1 + ya + yb * r,
      r: r
    };
  }

  function place$1(b, a, c) {
    var dx = b.x - a.x, x, a2,
        dy = b.y - a.y, y, b2,
        d2 = dx * dx + dy * dy;
    if (d2) {
      a2 = a.r + c.r, a2 *= a2;
      b2 = b.r + c.r, b2 *= b2;
      if (a2 > b2) {
        x = (d2 + b2 - a2) / (2 * d2);
        y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
        c.x = b.x - x * dx - y * dy;
        c.y = b.y - x * dy + y * dx;
      } else {
        x = (d2 + a2 - b2) / (2 * d2);
        y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
        c.x = a.x + x * dx - y * dy;
        c.y = a.y + x * dy + y * dx;
      }
    } else {
      c.x = a.x + c.r;
      c.y = a.y;
    }
  }

  function intersects$1(a, b) {
    var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function score$1(node) {
    var a = node._,
        b = node.next._,
        ab = a.r + b.r,
        dx = (a.x * b.r + b.x * a.r) / ab,
        dy = (a.y * b.r + b.y * a.r) / ab;
    return dx * dx + dy * dy;
  }

  function Node$3(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
  }

  function packEnclose$1(circles) {
    if (!(n = circles.length)) return 0;

    var a, b, c, n, aa, ca, i, j, k, sj, sk;

    // Place the first circle.
    a = circles[0], a.x = 0, a.y = 0;
    if (!(n > 1)) return a.r;

    // Place the second circle.
    b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
    if (!(n > 2)) return a.r + b.r;

    // Place the third circle.
    place$1(b, a, c = circles[2]);

    // Initialize the front-chain using the first three circles a, b and c.
    a = new Node$3(a), b = new Node$3(b), c = new Node$3(c);
    a.next = c.previous = b;
    b.next = a.previous = c;
    c.next = b.previous = a;

    // Attempt to place each remaining circle…
    pack: for (i = 3; i < n; ++i) {
      place$1(a._, b._, c = circles[i]), c = new Node$3(c);

      // Find the closest intersecting circle on the front-chain, if any.
      // “Closeness” is determined by linear distance along the front-chain.
      // “Ahead” or “behind” is likewise determined by linear distance.
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects$1(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects$1(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);

      // Success! Insert the new circle c between a and b.
      c.previous = a, c.next = b, a.next = b.previous = b = c;

      // Compute the new closest circle pair to the centroid.
      aa = score$1(a);
      while ((c = c.next) !== b) {
        if ((ca = score$1(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }

    // Compute the enclosing circle of the front chain.
    a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose$1(a);

    // Translate the circles to put the enclosing circle around the origin.
    for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

    return c.r;
  }

  function optional$1(f) {
    return f == null ? null : required$1(f);
  }

  function required$1(f) {
    if (typeof f !== "function") throw new Error;
    return f;
  }

  function constantZero$1() {
    return 0;
  }

  function constant$k(x) {
    return function() {
      return x;
    };
  }

  function defaultRadius$2(d) {
    return Math.sqrt(d.value);
  }

  function index$5() {
    var radius = null,
        dx = 1,
        dy = 1,
        padding = constantZero$1;

    function pack(root) {
      root.x = dx / 2, root.y = dy / 2;
      if (radius) {
        root.eachBefore(radiusLeaf$1(radius))
            .eachAfter(packChildren$1(padding, 0.5))
            .eachBefore(translateChild$1(1));
      } else {
        root.eachBefore(radiusLeaf$1(defaultRadius$2))
            .eachAfter(packChildren$1(constantZero$1, 1))
            .eachAfter(packChildren$1(padding, root.r / Math.min(dx, dy)))
            .eachBefore(translateChild$1(Math.min(dx, dy) / (2 * root.r)));
      }
      return root;
    }

    pack.radius = function(x) {
      return arguments.length ? (radius = optional$1(x), pack) : radius;
    };

    pack.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
    };

    pack.padding = function(x) {
      return arguments.length ? (padding = typeof x === "function" ? x : constant$k(+x), pack) : padding;
    };

    return pack;
  }

  function radiusLeaf$1(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }

  function packChildren$1(padding, k) {
    return function(node) {
      if (children = node.children) {
        var children,
            i,
            n = children.length,
            r = padding(node) * k || 0,
            e;

        if (r) for (i = 0; i < n; ++i) children[i].r += r;
        e = packEnclose$1(children);
        if (r) for (i = 0; i < n; ++i) children[i].r -= r;
        node.r = e + r;
      }
    };
  }

  function translateChild$1(k) {
    return function(node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  function roundNode$1(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  function treemapDice$1(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (x1 - x0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  }

  var keyPrefix$2 = "$", // Protect against keys like “__proto__”.
      preroot$1 = {depth: -1},
      ambiguous$1 = {};

  function defaultId$1(d) {
    return d.id;
  }

  function defaultParentId$1(d) {
    return d.parentId;
  }

  function stratify$1() {
    var id = defaultId$1,
        parentId = defaultParentId$1;

    function stratify(data) {
      var d,
          i,
          n = data.length,
          root,
          parent,
          node,
          nodes = new Array(n),
          nodeId,
          nodeKey,
          nodeByKey = {};

      for (i = 0; i < n; ++i) {
        d = data[i], node = nodes[i] = new Node$2(d);
        if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
          nodeKey = keyPrefix$2 + (node.id = nodeId);
          nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous$1 : node;
        }
      }

      for (i = 0; i < n; ++i) {
        node = nodes[i], nodeId = parentId(data[i], i, data);
        if (nodeId == null || !(nodeId += "")) {
          if (root) throw new Error("multiple roots");
          root = node;
        } else {
          parent = nodeByKey[keyPrefix$2 + nodeId];
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous$1) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        }
      }

      if (!root) throw new Error("no root");
      root.parent = preroot$1;
      root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight$1);
      root.parent = null;
      if (n > 0) throw new Error("cycle");

      return root;
    }

    stratify.id = function(x) {
      return arguments.length ? (id = required$1(x), stratify) : id;
    };

    stratify.parentId = function(x) {
      return arguments.length ? (parentId = required$1(x), stratify) : parentId;
    };

    return stratify;
  }

  function defaultSeparation$2(a, b) {
    return a.parent === b.parent ? 1 : 2;
  }

  // function radialSeparation(a, b) {
  //   return (a.parent === b.parent ? 1 : 2) / a.depth;
  // }

  // This function is used to traverse the left contour of a subtree (or
  // subforest). It returns the successor of v on this contour. This successor is
  // either given by the leftmost child of v or by the thread of v. The function
  // returns null if and only if v is on the highest level of its subtree.
  function nextLeft$1(v) {
    var children = v.children;
    return children ? children[0] : v.t;
  }

  // This function works analogously to nextLeft.
  function nextRight$1(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
  }

  // Shifts the current subtree rooted at w+. This is done by increasing
  // prelim(w+) and mod(w+) by shift.
  function moveSubtree$1(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }

  // All other shifts, applied to the smaller subtrees between w- and w+, are
  // performed by this function. To prepare the shifts, we have to adjust
  // change(w+), shift(w+), and change(w-).
  function executeShifts$1(v) {
    var shift = 0,
        change = 0,
        children = v.children,
        i = children.length,
        w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }

  // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
  // returns the specified (default) ancestor.
  function nextAncestor$1(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }

  function TreeNode$1(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null; // default ancestor
    this.a = this; // ancestor
    this.z = 0; // prelim
    this.m = 0; // mod
    this.c = 0; // change
    this.s = 0; // shift
    this.t = null; // thread
    this.i = i; // number
  }

  TreeNode$1.prototype = Object.create(Node$2.prototype);

  function treeRoot$1(root) {
    var tree = new TreeNode$1(root, 0),
        node,
        nodes = [tree],
        child,
        children,
        i,
        n;

    while (node = nodes.pop()) {
      if (children = node._.children) {
        node.children = new Array(n = children.length);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new TreeNode$1(children[i], i));
          child.parent = node;
        }
      }
    }

    (tree.parent = new TreeNode$1(null, 0)).children = [tree];
    return tree;
  }

  // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
  function tree$1() {
    var separation = defaultSeparation$2,
        dx = 1,
        dy = 1,
        nodeSize = null;

    function tree(root) {
      var t = treeRoot$1(root);

      // Compute the layout using Buchheim et al.’s algorithm.
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);

      // If a fixed node size is specified, scale x and y.
      if (nodeSize) root.eachBefore(sizeNode);

      // If a fixed tree size is specified, scale x and y based on the extent.
      // Compute the left-most, right-most, and depth-most nodes for extents.
      else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }

      return root;
    }

    // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
    // applied recursively to the children of v, as well as the function
    // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
    // node v is placed to the midpoint of its outermost children.
    function firstWalk(v) {
      var children = v.children,
          siblings = v.parent.children,
          w = v.i ? siblings[v.i - 1] : null;
      if (children) {
        executeShifts$1(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }

    // Computes all real x-coordinates by summing up the modifiers recursively.
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }

    // The core of the algorithm. Here, a new subtree is combined with the
    // previous subtrees. Threads are used to traverse the inside and outside
    // contours of the left and right subtree up to the highest common level. The
    // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
    // superscript o means outside and i means inside, the subscript - means left
    // subtree and + means right subtree. For summing up the modifiers along the
    // contour, we use respective variables si+, si-, so-, and so+. Whenever two
    // nodes of the inside contours conflict, we compute the left one of the
    // greatest uncommon ancestors using the function ANCESTOR and call MOVE
    // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
    // Finally, we add a new thread (if necessary).
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v,
            vop = v,
            vim = w,
            vom = vip.parent.children[0],
            sip = vip.m,
            sop = vop.m,
            sim = vim.m,
            som = vom.m,
            shift;
        while (vim = nextRight$1(vim), vip = nextLeft$1(vip), vim && vip) {
          vom = nextLeft$1(vom);
          vop = nextRight$1(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree$1(nextAncestor$1(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight$1(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft$1(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }

    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }

    tree.separation = function(x) {
      return arguments.length ? (separation = x, tree) : separation;
    };

    tree.size = function(x) {
      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
    };

    tree.nodeSize = function(x) {
      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
    };

    return tree;
  }

  function treemapSlice$1(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (y1 - y0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.x0 = x0, node.x1 = x1;
      node.y0 = y0, node.y1 = y0 += node.value * k;
    }
  }

  var phi$1 = (1 + Math.sqrt(5)) / 2;

  function squarifyRatio$1(ratio, parent, x0, y0, x1, y1) {
    var rows = [],
        nodes = parent.children,
        row,
        nodeValue,
        i0 = 0,
        i1 = 0,
        n = nodes.length,
        dx, dy,
        value = parent.value,
        sumValue,
        minValue,
        maxValue,
        newRatio,
        minRatio,
        alpha,
        beta;

    while (i0 < n) {
      dx = x1 - x0, dy = y1 - y0;

      // Find the next non-empty node.
      do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);

      // Keep adding nodes while the aspect ratio maintains or improves.
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) { sumValue -= nodeValue; break; }
        minRatio = newRatio;
      }

      // Position and record the row orientation.
      rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
      if (row.dice) treemapDice$1(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
      else treemapSlice$1(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
      value -= sumValue, i0 = i1;
    }

    return rows;
  }

  var squarify$1 = (function custom(ratio) {

    function squarify(parent, x0, y0, x1, y1) {
      squarifyRatio$1(ratio, parent, x0, y0, x1, y1);
    }

    squarify.ratio = function(x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return squarify;
  })(phi$1);

  function index$6() {
    var tile = squarify$1,
        round = false,
        dx = 1,
        dy = 1,
        paddingStack = [0],
        paddingInner = constantZero$1,
        paddingTop = constantZero$1,
        paddingRight = constantZero$1,
        paddingBottom = constantZero$1,
        paddingLeft = constantZero$1;

    function treemap(root) {
      root.x0 =
      root.y0 = 0;
      root.x1 = dx;
      root.y1 = dy;
      root.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root.eachBefore(roundNode$1);
      return root;
    }

    function positionNode(node) {
      var p = paddingStack[node.depth],
          x0 = node.x0 + p,
          y0 = node.y0 + p,
          x1 = node.x1 - p,
          y1 = node.y1 - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x0 += paddingLeft(node) - p;
        y0 += paddingTop(node) - p;
        x1 -= paddingRight(node) - p;
        y1 -= paddingBottom(node) - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        tile(node, x0, y0, x1, y1);
      }
    }

    treemap.round = function(x) {
      return arguments.length ? (round = !!x, treemap) : round;
    };

    treemap.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
    };

    treemap.tile = function(x) {
      return arguments.length ? (tile = required$1(x), treemap) : tile;
    };

    treemap.padding = function(x) {
      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };

    treemap.paddingInner = function(x) {
      return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$k(+x), treemap) : paddingInner;
    };

    treemap.paddingOuter = function(x) {
      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };

    treemap.paddingTop = function(x) {
      return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$k(+x), treemap) : paddingTop;
    };

    treemap.paddingRight = function(x) {
      return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$k(+x), treemap) : paddingRight;
    };

    treemap.paddingBottom = function(x) {
      return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$k(+x), treemap) : paddingBottom;
    };

    treemap.paddingLeft = function(x) {
      return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$k(+x), treemap) : paddingLeft;
    };

    return treemap;
  }

  function pack(nodes, v) {

    var pack = index$5()
        .size([v.size[0], v.size[1]])
        .padding(v.padding);

    var packed = pack(stratify$1()
        .id(function(d, i) { return i; })
        .parentId(function(d, i) {
          return i === 0 ? "": 0;
        })([{}].concat(nodes))
          .sum(function() { return 1; })
        );

    var _valueWidth;

    if(!v.valueWidth) {
      _valueWidth = function(_, i) { return packed.children[i].r; };
      v.width.domain([0, 1]).range([0, 1]);
    } else if(typeof v.valueWidth === "number") {
      _valueWidth = function() { return v.valueWidth; };
      v.width.domain([0, v.size[0]]).range([0, v.size[0] - 2 * v.padding]);
    } else {
      _valueWidth = v.valueWidth;
      v.width.domain(extent(nodes, v.valueX)).range([0, v.size[0]]);
    }

    var _valueHeight;

    if(!v.valueHeight) {
      _valueHeight = function(_, i) { return packed.children[i].r; };
      v.width.domain([0, 1]).range([0, 1]);
    } else if(typeof v.valueHeight === "number") {
      _valueHeight = function() { return v.valueHeight; };
      v.height.domain([0, v.size[1]]).range([0, v.size[1] - 2 * v.padding]);
    } else {
      _valueHeight = v.valueHeight;
      v.height.domain(extent(nodes, v.valueY)).range([0, v.size[1]]);
    }

    nodes.forEach(function(n, i) {
      n[v.__x] = packed.children[i].x + v.offset[0];
      n[v.__y] = packed.children[i].y + v.offset[1];

      n[v.__width] = v.width(_valueWidth(n, i));
      n[v.__height] = v.height(_valueHeight(n, i));

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function rotate(cx, cy, x, y, a) {
    var r = (Math.PI / 180) * a,
        cos = Math.cos(r),
        sin = Math.sin(r),
        resx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
        resy = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return [resx, resy];
  }

  function pyramid(nodes, v) {

    var shiftX, shiftY;

    nodes.forEach(function(n, i) {

      if(v.orient == "down") {

        shiftX = v.size[0] / (2 * nodes.length);
        shiftY = v.size[1] / (2 * nodes.length);

        n[v.__x] = 0 + v.offset[0] + shiftX * i;
        n[v.__y] = 0 + v.offset[1] + shiftY * i * 2;

        n[v.__width] = v.size[0] - shiftX * i * 2;
        n[v.__height] = v.size[1] - shiftY * i * 2;

        n[v.__cx] = n[v.__x] + n[v.__width] / 2;
        n[v.__cy] = n[v.__y] + shiftY;

      } else if(v.orient == "up") {

        shiftX = v.size[0] / (2 * nodes.length);
        shiftY = v.size[1] / (2 * nodes.length);

        n[v.__x] = 0 + v.offset[0] + shiftX * i;
        n[v.__y] = 0 + v.offset[1];

        n[v.__width] = v.size[0] - shiftX * i * 2;
        n[v.__height] = v.size[1] - shiftY * i * 2;

        n[v.__cx] = n[v.__x] + n[v.__width] / 2;
        n[v.__cy] = n[v.__y] + shiftY * i * 2 + shiftY;

      } else { // central default

        shiftX = v.size[0] / (2 * nodes.length);
        shiftY = v.size[1] / (2 * nodes.length);

        n[v.__x] = 0 + v.offset[0] + shiftX * i;
        n[v.__y] = 0 + v.offset[1] + shiftY * i;

        n[v.__width] = v.size[0] - shiftX * i * 2;
        n[v.__height] = v.size[1] - shiftY * i * 2;

        n[v.__cx] = n[v.__x] + n[v.__width] / 2;
        n[v.__cy] = n[v.__y] + n[v.__height] / 2;

        if(v.rotate !==null) {
          n["__p"] = [];
          n["__p"].push(rotate(n[v.__cx], n[v.__cy], n[v.__x], n[v.__y], v.rotate));
          n["__p"].push(rotate(n[v.__cx], n[v.__cy], n[v.__x] + n[v.__width], n[v.__y], v.rotate));
          n["__p"].push(rotate(n[v.__cx], n[v.__cy], n[v.__x] + n[v.__width], n[v.__y] + n[v.__height], v.rotate));
          n["__p"].push(rotate(n[v.__cx], n[v.__cy], n[v.__x], n[v.__y] + n[v.__height], v.rotate));
          n["__p"].push(rotate(n[v.__cx], n[v.__cy], n[v.__x], n[v.__y], v.rotate));
        }

      }
    });

    return nodes;
  }

  var pi$5 = Math.PI,
      tau$6 = 2 * pi$5,
      epsilon$6 = 1e-6,
      tauEpsilon$1 = tau$6 - epsilon$6;

  function Path$2() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path$1() {
    return new Path$2;
  }

  Path$2.prototype = path$1.prototype = {
    constructor: Path$2,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon$6));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi$5 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon$6) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon$6 || Math.abs(this._y1 - y0) > epsilon$6) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau$6 + tau$6;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon$1) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon$6) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi$5)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  function constant$l(x) {
    return function constant() {
      return x;
    };
  }

  var abs$4 = Math.abs;
  var atan2$2 = Math.atan2;
  var cos$3 = Math.cos;
  var max$6 = Math.max;
  var min$4 = Math.min;
  var sin$3 = Math.sin;
  var sqrt$3 = Math.sqrt;

  var epsilon$7 = 1e-12;
  var pi$6 = Math.PI;
  var halfPi$4 = pi$6 / 2;
  var tau$7 = 2 * pi$6;

  function acos$2(x) {
    return x > 1 ? 0 : x < -1 ? pi$6 : Math.acos(x);
  }

  function asin$2(x) {
    return x >= 1 ? halfPi$4 : x <= -1 ? -halfPi$4 : Math.asin(x);
  }

  function arcInnerRadius$1(d) {
    return d.innerRadius;
  }

  function arcOuterRadius$1(d) {
    return d.outerRadius;
  }

  function arcStartAngle$1(d) {
    return d.startAngle;
  }

  function arcEndAngle$1(d) {
    return d.endAngle;
  }

  function arcPadAngle$1(d) {
    return d && d.padAngle; // Note: optional!
  }

  function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0,
        x32 = x3 - x2, y32 = y3 - y2,
        t = y32 * x10 - x32 * y10;
    if (t * t < epsilon$7) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
  }

  // Compute perpendicular offset line of length rc.
  // http://mathworld.wolfram.com/Circle-LineIntersection.html
  function cornerTangents$1(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1,
        y01 = y0 - y1,
        lo = (cw ? rc : -rc) / sqrt$3(x01 * x01 + y01 * y01),
        ox = lo * y01,
        oy = -lo * x01,
        x11 = x0 + ox,
        y11 = y0 + oy,
        x10 = x1 + ox,
        y10 = y1 + oy,
        x00 = (x11 + x10) / 2,
        y00 = (y11 + y10) / 2,
        dx = x10 - x11,
        dy = y10 - y11,
        d2 = dx * dx + dy * dy,
        r = r1 - rc,
        D = x11 * y10 - x10 * y11,
        d = (dy < 0 ? -1 : 1) * sqrt$3(max$6(0, r * r * d2 - D * D)),
        cx0 = (D * dy - dx * d) / d2,
        cy0 = (-D * dx - dy * d) / d2,
        cx1 = (D * dy + dx * d) / d2,
        cy1 = (-D * dx + dy * d) / d2,
        dx0 = cx0 - x00,
        dy0 = cy0 - y00,
        dx1 = cx1 - x00,
        dy1 = cy1 - y00;

    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }

  function arc$1() {
    var innerRadius = arcInnerRadius$1,
        outerRadius = arcOuterRadius$1,
        cornerRadius = constant$l(0),
        padRadius = null,
        startAngle = arcStartAngle$1,
        endAngle = arcEndAngle$1,
        padAngle = arcPadAngle$1,
        context = null;

    function arc() {
      var buffer,
          r,
          r0 = +innerRadius.apply(this, arguments),
          r1 = +outerRadius.apply(this, arguments),
          a0 = startAngle.apply(this, arguments) - halfPi$4,
          a1 = endAngle.apply(this, arguments) - halfPi$4,
          da = abs$4(a1 - a0),
          cw = a1 > a0;

      if (!context) context = buffer = path$1();

      // Ensure that the outer radius is always larger than the inner radius.
      if (r1 < r0) r = r1, r1 = r0, r0 = r;

      // Is it a point?
      if (!(r1 > epsilon$7)) context.moveTo(0, 0);

      // Or is it a circle or annulus?
      else if (da > tau$7 - epsilon$7) {
        context.moveTo(r1 * cos$3(a0), r1 * sin$3(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$7) {
          context.moveTo(r0 * cos$3(a1), r0 * sin$3(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
        var a01 = a0,
            a11 = a1,
            a00 = a0,
            a10 = a1,
            da0 = da,
            da1 = da,
            ap = padAngle.apply(this, arguments) / 2,
            rp = (ap > epsilon$7) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$3(r0 * r0 + r1 * r1)),
            rc = min$4(abs$4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
            rc0 = rc,
            rc1 = rc,
            t0,
            t1;

        // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
        if (rp > epsilon$7) {
          var p0 = asin$2(rp / r0 * sin$3(ap)),
              p1 = asin$2(rp / r1 * sin$3(ap));
          if ((da0 -= p0 * 2) > epsilon$7) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon$7) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }

        var x01 = r1 * cos$3(a01),
            y01 = r1 * sin$3(a01),
            x10 = r0 * cos$3(a10),
            y10 = r0 * sin$3(a10);

        // Apply rounded corners?
        if (rc > epsilon$7) {
          var x11 = r1 * cos$3(a11),
              y11 = r1 * sin$3(a11),
              x00 = r0 * cos$3(a00),
              y00 = r0 * sin$3(a00),
              oc;

          // Restrict the corner radius according to the sector angle.
          if (da < pi$6 && (oc = intersect$1(x01, y01, x00, y00, x11, y11, x10, y10))) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / sin$3(acos$2((ax * bx + ay * by) / (sqrt$3(ax * ax + ay * ay) * sqrt$3(bx * bx + by * by))) / 2),
                lc = sqrt$3(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min$4(rc, (r0 - lc) / (kc - 1));
            rc1 = min$4(rc, (r1 - lc) / (kc + 1));
          }
        }

        // Is the sector collapsed to a line?
        if (!(da1 > epsilon$7)) context.moveTo(x01, y01);

        // Does the sector’s outer ring have rounded corners?
        else if (rc1 > epsilon$7) {
          t0 = cornerTangents$1(x00, y00, x01, y01, r1, rc1, cw);
          t1 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);

          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$2(t0.y01, t0.x01), atan2$2(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2$2(t0.y01, t0.x01), atan2$2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r1, atan2$2(t0.cy + t0.y11, t0.cx + t0.x11), atan2$2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
            context.arc(t1.cx, t1.cy, rc1, atan2$2(t1.y11, t1.x11), atan2$2(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the outer ring just a circular arc?
        else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

        // Is there no inner ring, and it’s a circular sector?
        // Or perhaps it’s an annular sector collapsed due to padding?
        if (!(r0 > epsilon$7) || !(da0 > epsilon$7)) context.lineTo(x10, y10);

        // Does the sector’s inner ring (or point) have rounded corners?
        else if (rc0 > epsilon$7) {
          t0 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
          t1 = cornerTangents$1(x01, y01, x00, y00, r0, -rc0, cw);

          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

          // Have the corners merged?
          if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$2(t0.y01, t0.x01), atan2$2(t1.y01, t1.x01), !cw);

          // Otherwise, draw the two corners and the ring.
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2$2(t0.y01, t0.x01), atan2$2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r0, atan2$2(t0.cy + t0.y11, t0.cx + t0.x11), atan2$2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
            context.arc(t1.cx, t1.cy, rc0, atan2$2(t1.y11, t1.x11), atan2$2(t1.y01, t1.x01), !cw);
          }
        }

        // Or is the inner ring just a circular arc?
        else context.arc(0, 0, r0, a10, a00, cw);
      }

      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
          a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$6 / 2;
      return [cos$3(a) * r, sin$3(a) * r];
    };

    arc.innerRadius = function(_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$l(+_), arc) : innerRadius;
    };

    arc.outerRadius = function(_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$l(+_), arc) : outerRadius;
    };

    arc.cornerRadius = function(_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$l(+_), arc) : cornerRadius;
    };

    arc.padRadius = function(_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$l(+_), arc) : padRadius;
    };

    arc.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$l(+_), arc) : startAngle;
    };

    arc.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$l(+_), arc) : endAngle;
    };

    arc.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$l(+_), arc) : padAngle;
    };

    arc.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), arc) : context;
    };

    return arc;
  }

  function descending$3(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  function identity$f(d) {
    return d;
  }

  function pie$1() {
    var value = identity$f,
        sortValues = descending$3,
        sort = null,
        startAngle = constant$l(0),
        endAngle = constant$l(tau$7),
        padAngle = constant$l(0);

    function pie(data) {
      var i,
          n = data.length,
          j,
          k,
          sum = 0,
          index = new Array(n),
          arcs = new Array(n),
          a0 = +startAngle.apply(this, arguments),
          da = Math.min(tau$7, Math.max(-tau$7, endAngle.apply(this, arguments) - a0)),
          a1,
          p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
          pa = p * (da < 0 ? -1 : 1),
          v;

      for (i = 0; i < n; ++i) {
        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
          sum += v;
        }
      }

      // Optionally sort the arcs by previously-computed values or by data.
      if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
      else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

      // Compute the arcs! They are stored in the original data's order.
      for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
        j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }

      return arcs;
    }

    pie.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$l(+_), pie) : value;
    };

    pie.sortValues = function(_) {
      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };

    pie.sort = function(_) {
      return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };

    pie.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$l(+_), pie) : startAngle;
    };

    pie.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$l(+_), pie) : endAngle;
    };

    pie.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$l(+_), pie) : padAngle;
    };

    return pie;
  }

  var slice$8 = Array.prototype.slice;

  function none$5(series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }

  function none$6(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }

  function stackValue$1(d, key) {
    return d[key];
  }

  function stack$1() {
    var keys = constant$l([]),
        order = none$6,
        offset = none$5,
        value = stackValue$1;

    function stack(data) {
      var kz = keys.apply(this, arguments),
          i,
          m = data.length,
          n = kz.length,
          sz = new Array(n),
          oz;

      for (i = 0; i < n; ++i) {
        for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
          si[j] = sij = [0, +value(data[j], ki, j, data)];
          sij.data = data[j];
        }
        si.key = ki;
      }

      for (i = 0, oz = order(sz); i < n; ++i) {
        sz[oz[i]].index = i;
      }

      offset(sz, oz);
      return sz;
    }

    stack.keys = function(_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$l(slice$8.call(_)), stack) : keys;
    };

    stack.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$l(+_), stack) : value;
    };

    stack.order = function(_) {
      return arguments.length ? (order = _ == null ? none$6 : typeof _ === "function" ? _ : constant$l(slice$8.call(_)), stack) : order;
    };

    stack.offset = function(_) {
      return arguments.length ? (offset = _ == null ? none$5 : _, stack) : offset;
    };

    return stack;
  }

  function ascending$8(series) {
    var sums = series.map(sum$4);
    return none$6(series).sort(function(a, b) { return sums[a] - sums[b]; });
  }

  function sum$4(series) {
    var s = 0, i = -1, n = series.length, v;
    while (++i < n) if (v = +series[i][1]) s += v;
    return s;
  }

  function descending$4(series) {
    return ascending$8(series).reverse();
  }

  function radial$2(nodes, v) {

    if(!v.radius) {
      v.radius = Math.min(v.size[0], v.size[1]) - 2 * (v.size[1] / nodes.length);
    }

    var arc = arc$1()
        .outerRadius(v.radius)
        .innerRadius(0);

    var pie = pie$1()
        .sort(v.sort)
        .value(function() { return 1; });

    var arcs = pie(nodes);

    nodes.forEach(function(n, i) {

      n[v.__width] = v.size[0] / nodes.length;
      n[v.__height] = v.size[1] / nodes.length;

      // Must be after width & height
      n[v.__x] = arc.centroid(arcs[i])[0] + v.size[0] / 2 + v.offset[0] - n[v.__width] / 2 + v.padding;
      n[v.__y] = arc.centroid(arcs[i])[1] + v.size[1] / 2 + v.offset[1] - n[v.__height] / 2 + v.padding;

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function stack$2(nodes, v) {

    if(v.sort) {
      nodes = nodes.sort(v.sort);
    }

    var stack = stack$1()
        .keys(nodes.map(function(d, i) { return i + "_"; })) // Creates unique ids for nodes
        .order(descending$4)
        .value(function(d, key) { return nodes.indexOf(d[key]); });

    v.y.domain([0, sum(sequence(nodes.length)) + nodes.length]).range([0, v.size[1]]);

    var new_data = {};

    nodes.map(function(d, i) {
      new_data[i+"_"] = d;
    });

    var stacked = stack([new_data]);

    nodes.forEach(function(n, i) {
      var s = stacked[i][0];

      n[v.__x] = v.offset[0] + v.padding;
      n[v.__y] = v.y(s[1]) + v.offset[1] + v.padding;

      n[v.__width] = v.size[0];
      n[v.__height] = v.y(s[1]) - v.y(s[0]);

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function step$1(nodes, v) {

    var _shiftX = v.size[0] / (2 * nodes.length);

    nodes.forEach(function(n, i) {

      n[v.__x] = 0 + v.offset[0] + _shiftX * i  + v.padding;
      n[v.__y] = 0 + v.offset[1] + v.padding;

      n[v.__width] = v.size[0] - _shiftX * i * 2;
      n[v.__height] = v.size[1];

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;
    });

    return nodes;
  }

  function tree$2(nodes, v) {

    var treeData = stratify$1()
        .id(v.id)
        .parentId(v.parentId)(nodes);

    var tree = tree$1()
        .size([v.size[0], v.size[1] / 2]);

    var treeLayout = hierarchy$1(treeData, function(d) {
        return d.children;
      });

    treeLayout = tree(treeLayout);

    nodes.forEach(function(n, i) {

      n[v.__width] = v.cellSize ? v.cellSize[0]: v.size[0] / nodes.length;
      n[v.__height] = v.cellSize ? v.cellSize[1]: v.size[1] / nodes.length;

      n[v.__x] = treeLayout.descendants()[i].x + v.offset[0] - n[v.__width] / 2;
      n[v.__y] = treeLayout.descendants()[i].y + v.offset[1];

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

    });

    return nodes;
  }

  function treemap(nodes, v) {

    var treemap = index$6()
        .size([v.size[0] - margin(v, "left") - margin(v, "right"), v.size[1] - margin(v, "top") - margin(v, "bottom")])
        .padding(v.padding);

    var stratify = stratify$1()
        .parentId(function(d) { return d.___parent_id; });

    nodes.forEach(function(d, i) {
      d.id = "_" + i;
      d.___parent_id = "_x";
    });

    var extra = [{"id": "_x", "___parent_id": ""}];

    var root = stratify(nodes.concat(extra))
        .sum(function(d) { return d.___parent_id === "" ? 0: 1; });

    if(v.valueHeight) {
      root.sum(function(d) { return v.valueHeight(d); });
    }

    if(v.sort) {
      if(v.sortAsc) {
        root.sort(function(a, b) { return a.value - b.value; });
      } else {
        root.sort(function(a, b) { return b.value - a.value; });
      }
    }

    var tree = treemap(root);

    tree.leaves().forEach(function(t, i) {
      t.data[v.__x] = t.x0 + v.offset[0] + margin(v, "left");
      t.data[v.__y] = t.y0 + v.offset[1] + margin(v, "top");

      t.data[v.__width] = t.x1 - t.x0;
      t.data[v.__height] = t.y1 - t.y0;

      t.data[v.__cx] = nodes[i][v.__x] + nodes[i][v.__width] / 2;
      t.data[v.__cy] = nodes[i][v.__y] + nodes[i][v.__height] / 2;
    });

    return nodes;
  }

  function vertical(nodes, v) {

    if(v.sort) {
      nodes = nodes.sort(v.sort);
    }

    var _valueHeight = v.valueHeight ? v.valueHeight : constant$j(1),
        _valueWidth = v.valueWidth ? v.valueWidth : constant$j(1),
        heights = nodes.map(_valueHeight),
        widths = nodes.map(_valueWidth);
    
    v.height.domain([0, max(heights)])
      .range([0, Math.max(1, v.size[1] - 2 * v.padding - (margin(v,"top") + margin(v,"bottom")))]);

    v.width.domain([0, sum(widths)])
      .range([0, Math.max(1, v.size[0] - 2 * v.padding - nodes.length * (margin(v, "left") + margin(v, "right")))]);


    if(nodes.length > 0) {
      nodes[0].x0 = v.padding;
    }

    nodes.forEach(function(n, i) {

      n[v.__x] = n.x0 + v.offset[0] + (i+1) * (margin(v, "left")) + i * margin(v, "right");

      if(v.orient === "down") {
        n[v.__y] = 0 + v.offset[1] + margin(v, "top") + v.padding;
      } else if(v.orient === "up") {
        n[v.__y] = v.size[1] - v.height(heights[i]) + v.offset[1] + margin(v, "bottom") - v.padding;
      } else if(v.orient === "center") {
        n[v.__y] = (v.size[1] / 2) - v.height(heights[i]) / 2 + v.offset[1] + margin(v, "top") - v.padding;
      } else { // defaut up
        n[v.__y] = v.size[1] - v.height(heights[i]) + v.offset[1] + margin(v, "bottom") - v.padding;
      }

      n[v.__height] = v.height(heights[i]);
      n[v.__width] = v.width(widths[i]);

      // Updates the next node's y0 for all nodes but the last one
      if(i < nodes.length - 1) {
        nodes[i+1].x0 = n.x0 + n[v.__width];
      }

      n[v.__cx] = n[v.__x] + n[v.__width] / 2;
      n[v.__cy] = n[v.__y] + n[v.__height] / 2;

      if(v.rotate !==null) {
        n["__p"] = [];
        n["__p"].push(rotate(v.size[0] / 2, v.size[1] / 2, n[v.__x], n[v.__y], v.rotate));
        n["__p"].push(rotate(v.size[0] / 2, v.size[1] / 2, n[v.__x] + n[v.__width], n[v.__y], v.rotate));
        n["__p"].push(rotate(v.size[0] / 2, v.size[1] / 2, n[v.__x] + n[v.__width], n[v.__y] + n[v.__height], v.rotate));
        n["__p"].push(rotate(v.size[0] / 2, v.size[1] / 2, n[v.__x], n[v.__y] + n[v.__height], v.rotate));
        n["__p"].push(rotate(v.size[0] / 2, v.size[1] / 2, n[v.__x], n[v.__y], v.rotate));
      }

    });

    return nodes;
  }

  function gridding() {

    var vars = {
      __prefix: "",
      __x: "",
      __y: "",
      __width: "",
      __height: "",
      __cx: "",
      __cy: "",
      __r: "",
      cellSize: null,
      cols: null,
      height: linear$6(),
      id: function(d, i) { return i; },
      layout: identity$e,
      margin: 0,
      mode: "identity",
      modes: {
        "brick": {
          "layout": brick,
          "properties": [
            {"key": "orient", "value": "left"},
            {"key": "orient", "value": "right", "default": true},
            {"key": "orient", "value": "up"},
            {"key": "orient", "value": "down"}
          ]
        },
        "cascade": {
          "layout": cascade,
          "properties": [
          ]
        },
        "central": {
          "layout": central,
          "properties": [
          ]
        },
        "coordinate": {
          "layout": coordinate,
          "properties": [
            {"key": "valueX", "value": null},
            {"key": "valueY", "value": null}
          ]
        },
        "corner": {
          "layout": corner,
          "properties": [
            {"key": "orient", "value": "top right"}
          ]
        },
        "diagonal": {
          "layout": diagonal,
          "properties": [
            {"key": "orient", "value": "top"}
          ]
        },
        "grid": {
          "layout": grid,
          "properties": [
            {"key": "orient", "value": "up"},
            {"key": "orient", "value": "down", "default": true},
            {"key": "orient", "value": "left"},
            {"key": "orient", "value": "right"}
          ]
        },
        "horizontal": {
          "layout": horizontal,
          "properties": [
            {"key": "orient", "value": "up"},
            {"key": "orient", "value": "left"},
            {"key": "orient", "value": "right"},
            {"key": "orient", "value": "center"},
            {"key": "valueY", "value": null},
            {"key": "valueWidth", "value": null}
          ]
        },
        "pack": {
          "layout": pack,
          "properties": []
        },
        "pyramid": {
          "layout": pyramid,
          "properties": [
            {"key": "orient", "value": "center", "default": true},
            {"key": "orient", "value": "up"},
            {"key": "orient", "value": "down"}
          ]
        },
        "radial": {
          "layout": radial$2,
          "properties": [
            {"key": "orient", "value": "top"}
          ]
        },
        "stack": {
          "layout": stack$2,
          "properties": [
            {"key": "orient", "value": "top"}
          ]
        },
        "step": {
          "layout": step$1,
          "properties": [
            {"key": "orient", "value": "top"}
          ]
        },
        "tree": {
          "layout": tree$2,
          "properties": [
            {"key": "orient", "value": "top"}
          ]
        },
        "treemap": {
          "layout": treemap,
          "properties": []
        },
        "vertical": {
          "layout": vertical,
          "properties": [
            {"key": "orient", "value": "up", "default": true},
            {"key": "orient", "value": "left"},
            {"key": "orient", "value": "right"},
            {"key": "orient", "value": "center"},
            {"key": "valueHeight", "value": null}
          ]
        }
      },
      offset: [0, 0],
      orient: "down",
      parentId: function(d, i) { return i === 0 ? null: 0; },
      padding: 0,
      radius: null,
      rotate: null,
      rows: null,
      shiftX: null,
      shiftY: null,
      size: [1, 1],
      sort: null,
      sortAsc: true,
      value: function(d) { return d; },
      valueHeight: null,
      valueWidth: null,
      valueX: null,
      valueY: null,
      width: linear$6(),
      x: linear$6(),
      y: linear$6()
    };

    function gridding(nodes) {

      // In case a prefix has been set
      vars.__x = vars.__prefix + "x";
      vars.__y = vars.__prefix + "y";
      vars.__width = vars.__prefix + "width";
      vars.__height = vars.__prefix + "height";
      vars.__cx = vars.__prefix + "cx";
      vars.__cy = vars.__prefix + "cy";
      vars.__r = vars.__prefix + "r";

      if (!nodes) {
        nodes = [];
      } else {
        nodes = Array.from(nodes, function(d,i) {
          var value = vars.value(d,i);
          if (typeof value !== "object")
            value = {"__value": value, "__index": i};
          return value;
        });
      }
      
      nodes.forEach(function(n) {
        n[vars.__r] = 0;
      });

      return vars.layout(nodes, vars);
    }

    gridding.mode = function(_mode) {
      if (!arguments.length) return vars.mode;
      vars.mode = _mode;
      if(vars.mode === "identity") {
        vars.layout = identity$e;
      } else if(Object.keys(vars.modes).indexOf(_mode) >= 0) {
        vars.layout = vars.modes[vars.mode].layout;
      }
      return gridding;
    };

    gridding.modes = function(_mode) {
      if(arguments.length === 1) return vars.modes[_mode].properties;
      return Object.keys(vars.modes);
    };

    gridding.size = function(_size) {
      if(!arguments.length) return vars.size;
      vars.size = _size;
      return gridding;
    };

    gridding.cellSize = function(_cellSize) {
      if(!arguments.length) return vars.cellSize;
      vars.cellSize = _cellSize;
      return gridding;
    };

    gridding.value = function(_value) {
      if(!arguments.length) return vars.value;
      vars.value = _value;
      return gridding;
    };

    gridding.valueX = function(_valueX) {
      if(!arguments.length) return vars.valueX;
      if(typeof _valueX === "string") {
        vars.valueX = function(d) { return d[_valueX]; };
      } else {
        vars.valueX = _valueX;
      }
      return gridding;
    };

    gridding.valueY = function(_valueY) {
      if(!arguments.length) return vars.valueY;
      if(typeof _valueY === "string") {
        vars.valueY = function(d) { return d[_valueY]; };
      } else {
        vars.valueY = _valueY;
      }
      return gridding;
    };

    gridding.valueHeight = function(_valueHeight) {
      if(!arguments.length) return vars.valueHeight;
      if(typeof _valueHeight === "string") {
        vars.valueHeight = function(d) { return d[_valueHeight]; };
      } else {
        vars.valueHeight = _valueHeight;
      }
      return gridding;
    };

    gridding.valueWidth = function(_valueWidth) {
      if(!arguments.length) return vars.valueWidth;
      if(typeof _valueWidth === "string") {
        vars.valueWidth = function(d) { return d[_valueWidth]; };
      } else {
        vars.valueWidth = _valueWidth;
      }
      return gridding;
    };

    gridding.sort = function(_sort) {
      if(!arguments.length) return vars.sort;
      if(typeof _sort === "string") {
        vars.sort = function(d) { return d[_sort]; };
      } else {
        vars.sort = _sort;
      }
      return gridding;
    };

    gridding.sortAsc = function(_sortAsc) {
      if(!arguments.length) return vars.sortAsc;
      vars.sortAsc = _sortAsc;
      return gridding;
    };

    gridding.padding = function(_padding) {
      if(!arguments.length) return vars.padding;
      vars.padding = _padding;
      return gridding;
    };

    gridding.margin = function(_margin) {
      if(!arguments.length) return vars.margin;
      vars.margin = _margin;
      return gridding;
    };

    gridding.offset = function(_offset) {
      if(!arguments.length) return vars.offset;
      vars.offset = _offset;
      return gridding;
    };

    gridding.orient = function(_orient) {
      if(!arguments.length) return vars.orient;
      vars.orient = _orient;
      return gridding;
    };

    gridding.cols = function(_cols) {
      if(!arguments.length) return vars.cols;
      vars.cols = _cols;
      return gridding;
    };

    gridding.rows = function(_rows) {
      if(!arguments.length) return vars.rows;
      vars.rows = _rows;
      return gridding;
    };

    gridding.radius = function(_radius) {
      if(!arguments.length) return vars.radius;
      vars.radius = _radius;
      return gridding;
    };

    gridding.rotate = function(_rotate) {
      if(!arguments.length) return vars.rotate;
      vars.rotate = _rotate;
      return gridding;
    };

    gridding.prefix = function(_prefix) {
      if(!arguments.length) return vars.__prefix;
      vars.__prefix = _prefix;
      return gridding;
    };

    gridding.id = function(_id) {
      if(!arguments.length) return vars.id;
      vars.id = _id;
      return gridding;
    };

    gridding.params = function(_params) {
      if(!arguments.length) return vars;
      for(var key in _params) {
        if (_params.hasOwnProperty(key)) {
          if(key === "mode") {
            gridding.mode(_params[key]);
          } else {
            vars[key] = _params[key];
          }
        }
      }
      return gridding;
    };

    gridding.parentId = function(_parentId) {
      if(!arguments.length) return vars.parentId;
      vars.parentId = _parentId;
      return gridding;
    };

    gridding.shiftX = function(_shiftX) {
      if(!arguments.length) return vars.shiftX;
      vars.shiftX = _shiftX;
      return gridding;
    };

    gridding.shiftY = function(_shiftY) {
      if(!arguments.length) return vars.shiftY;
      vars.shiftY = _shiftY;
      return gridding;
    };

    return gridding;
  }

  function render$1(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      interpolation,
      showPoints,
      dotsDiameter,
      yOrigin,
      // series options
      columnsNumber,
      useSameScale,
      // @TODO: add
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid,
      // labels options
      showLabels,
      labelsPosition,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; // create nest structure

    const nestedData = rollups(data, v => v.sort((a, b) => ascending(a.x, b.x)), d => d.series, d => d.lines); // comupte max values for series
    // will add it as property to each series.

    nestedData.forEach(function (serie) {
      serie.totalValue = data.filter(item => item.series == serie[0]).reduce((result, item) => result + item.y, 0);
    }); // series sorting functions

    const seriesSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a.totalValue, b.totalValue);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a.totalValue, b.totalValue);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      }
    }; // sort series

    nestedData.sort(seriesSortings[sortSeriesBy]); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(mapping.series.value ? columnsNumber : 1);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz'); // create the clip path

    svg.append('clipPath').attr('id', 'serieClipPath').append('rect').attr('x', -margin.left).attr('y', -margin.top).attr('width', griddingData[0].width).attr('height', griddingData[0].height);
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')');
    mapping.x.dataType === 'number' ? mapping.x.dataType = {
      type: 'number'
    } : null; // @TODO it should be better to have always the same kind of object in mapping
    // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    } // now add everything to each series


    series.each(function (d, serieIndex) {
      // load the single selection
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // add the clip path
      // clip-path: url(#clipPath);

      selection.attr('clip-path', 'url(#serieClipPath)'); // compute each serie width and height

      const serieWidth = d.width - margin.right - margin.left;
      const serieHeight = d.height - margin.top - margin.bottom; // get domains

      const xDomain = extent(data, e => e.x);
      const yDomain = useSameScale ? // compute extent of the whole dataset
      extent(data, e => e.y) : // compute extent of the single serie
      extent(d[1].map(e => e[1]).flat(2), e => e.y);

      if (yOrigin) {
        yDomain[0] = 0;
      } // define the x scale


      let xScale;

      switch (mapping.x.dataType.type) {
        case 'number':
          xScale = linear$2().domain(xDomain).nice().range([0, serieWidth]);
          break;

        case 'date':
          xScale = time().domain(xDomain).nice().range([0, serieWidth]);
          break;
      } // define the y scale


      const yScale = linear$2().domain(yDomain).nice().range([serieHeight, 0]); // define the line path function

      const line$1 = line().x(function (d) {
        return xScale(d.x);
      }).y(function (d) {
        return yScale(d.y);
      }).curve(d3['curve' + interpolation]);

      const xAxis = g => {
        return g.attr('transform', d => 'translate(0,' + (yDomain[0] >= 0 ? serieHeight : yScale(0)) + ')').call(axisBottom(xScale).tickSizeOuter(0)).call(g => g.append('text').attr('x', serieWidth).attr('dy', -5).attr('text-anchor', 'end').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping['x'].value).styles(styles.axisLabel));
      };

      const yAxis = g => {
        return g.attr('transform', d => 'translate(' + (mapping.x.dataType.type === 'date' || xDomain[0] >= 0 ? 0 : xScale(0)) + ',0)').call(axisLeft(yScale).tickSizeOuter(0)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping['y'].value).styles(styles.axisLabel));
      };

      const axisLayer = selection.append('g').attr('id', 'axis');
      axisLayer.append('g').call(xAxis);
      axisLayer.append('g').call(yAxis); // create a group for each line.
      // the group will contain the line and the dots.

      const groups = selection.append('g').attr('id', 'viz').selectAll('g').data(d => d[1]) // pass the single line
      .join('g').attr('id', d => d[0]);
      groups.append('path').attr('d', d => line$1(d[1])).attr('stroke', d => colorScale(d[1][0].color)).attr('fill', 'none');

      if (showPoints) {
        groups.append('g').selectAll('circle').data(d => d[1]).join('circle').attr('class', 'dot').attr('cx', d => xScale(d.x)).attr('cy', d => yScale(d.y)).attr('r', dotsDiameter / 2).attr('fill', d => colorScale(d.color));
      } // add lines labels


      if (showLabels) {
        let labels = groups.append('text').attr('font-family', 'sans-serif').attr('font-size', 10).attr('class', 'labels').text(d => d[0]);

        if (labelsPosition == 'side') {
          labels.attr('x', d => xScale(d[1].slice(-1)[0].x)) // get last x
          .attr('y', d => yScale(d[1].slice(-1)[0].y)) // get last y
          .attr('dx', 5).attr('dy', 4).attr('text-anchor', 'start');
        } else if (labelsPosition == 'inline') {
          labels.attr('x', d => {
            const maxPos = greatest(d[1], e => e.y);
            return xScale(maxPos.x);
          }).attr('y', d => {
            const maxPos = greatest(d[1], e => e.y);
            return yScale(maxPos.y);
          }).attr('dx', 0).attr('dy', -4).attr('text-anchor', 'middle');
        }
      } // add series titles


      if (showSeriesLabels) {
        select(this).append('text').attr('y', 4).attr('x', 4).text(d => d[0]).styles(styles.seriesLabel);
      }
    });

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$1 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 15,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart'
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      }
    },
    interpolation: {
      type: 'text',
      label: 'Type de courbe',
      default: 'Linear',
      options: [{
        label: 'Basis',
        value: 'Basis'
      }, {
        label: 'Bundle',
        value: 'Bundle'
      }, {
        label: 'Cardinal',
        value: 'Cardinal'
      }, {
        label: 'Catmull–Rom',
        value: 'CatmullRom'
      }, {
        label: 'Linear',
        value: 'Linear'
      }, {
        label: 'Monotone X',
        value: 'MonotoneX'
      }, {
        label: 'Natural',
        value: 'Natural'
      }, {
        label: 'Step',
        value: 'Step'
      }, {
        label: 'Step After',
        value: 'StepAfter'
      }, {
        label: 'Step Before',
        value: 'StepBefore'
      }],
      group: 'chart'
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['y']
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Total value (descending)'
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    repeatAxesLabels: {
      type: 'boolean',
      label: 'Repeat axis labels for each series',
      default: false,
      group: 'series'
    },
    showLabels: {
      type: 'boolean',
      label: 'Show labels',
      default: true,
      group: 'labels'
    },
    labelsPosition: {
      type: 'text',
      label: 'Labels position',
      options: ['inline', 'side'],
      default: 'inline',
      group: 'labels',
      disabled: {
        showLabels: false
      }
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: true,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var linechart = {
    metadata: metadata$1,
    dimensions: dimensions$1,
    mapData: mapData$1,
    render: render$1,
    visualOptions: visualOptions$1,
    styles: styles$1
  };

  const metadata$2 = {
    name: 'Color test',
    // thumbnail,
    // icon,
    category: 'Test and Debugging',
    description: 'A test for color scales',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions$2 = [{
    id: 'color',
    name: 'color',
    validTypes: ['number', 'date', 'string'],
    required: true
  }];

  const mapData$2 = {
    color: 'get'
  };

  // import { categoryLegend } from 'rawgraphs-core'

  function render$2(svgNode, data, visualOptions, mapping, originalData) {
    const {
      width = 500,
      height = 500,
      background = '#ffffff',
      colorScale
    } = visualOptions;
    const samples = colorScale.ticks ? colorScale.ticks() : colorScale.domain();
    const sampleHeight = height / samples.length;
    const svg = select(svgNode);
    const vizLayer = svg.append('g').attr('id', 'viz');
    vizLayer.selectAll('rect').data(samples).join('rect').attr('width', width).attr('height', sampleHeight).attr('y', (d, i) => i * sampleHeight).attr('stroke', '#222').attr('fill', d => {
      const col = colorScale(d);
      return col;
    });
  }

  const visualOptions$2 = {
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'schemeCategory10'
      },
      group: 'chart'
    }
  };

  var colortest = {
    metadata: metadata$2,
    dimensions: dimensions$2,
    mapData: mapData$2,
    render: render$2,
    visualOptions: visualOptions$2
  };

  var img$4 = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3crect class='cls-1' x='34' y='10' width='4' height='4'/%3e %3crect class='cls-1' x='27' y='19' width='2' height='2'/%3e %3crect class='cls-1' x='26' y='26' width='4' height='4'/%3e %3crect class='cls-1' x='32' y='24' width='8' height='8'/%3e %3crect class='cls-1' x='42' y='26' width='4' height='4'/%3e %3crect class='cls-1' x='19' y='35' width='2' height='2'/%3e %3crect class='cls-1' x='8' y='40' width='8' height='8'/%3e %3crect class='cls-1' x='32' y='40' width='8' height='8'/%3e %3c/g%3e %3cg id='primary'%3e %3crect class='cls-2' x='8' y='8' width='8' height='8'/%3e %3crect class='cls-2' x='18' y='10' width='4' height='4'/%3e %3crect class='cls-2' x='24' y='8' width='8' height='8'/%3e %3crect class='cls-2' x='43' y='11' width='2' height='2'/%3e %3crect class='cls-2' x='10' y='18' width='4' height='4'/%3e %3crect class='cls-2' x='19' y='19' width='2' height='2'/%3e %3crect class='cls-2' x='42' y='18' width='4' height='4'/%3e %3crect class='cls-2' x='34' y='18' width='4' height='4'/%3e %3crect class='cls-2' x='9' y='25' width='6' height='6'/%3e %3crect class='cls-2' x='17' y='25' width='6' height='6'/%3e %3crect class='cls-2' x='10' y='34' width='4' height='4'/%3e %3crect class='cls-2' x='27' y='35' width='2' height='2'/%3e %3crect class='cls-2' x='34' y='34' width='4' height='4'/%3e %3crect class='cls-2' x='43' y='35' width='2' height='2'/%3e %3crect class='cls-2' x='19' y='43' width='2' height='2'/%3e %3crect class='cls-2' x='26' y='42' width='4' height='4'/%3e %3crect class='cls-2' x='42' y='42' width='4' height='4'/%3e %3c/g%3e%3c/svg%3e";

  var img$5 = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2%2c .cls-3 %7b fill: none%3b %7d .cls-2 %7b stroke: black%3b %7d .cls-3 %7b stroke: %23e5e5e5%3b %7d .cls-4 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-5 %7b fill: %23feea9e%3b %7d .cls-6 %7b fill: %23d5ee9f%3b %7d .cls-7 %7b fill: %2389cfa5%3b %7d .cls-8 %7b fill: %23fdc374%3b %7d .cls-9 %7b fill: %23f6faae%3b %7d .cls-10 %7b fill: %23ce384b%3b %7d .cls-11 %7b fill: %23eef8a8%3b %7d .cls-12 %7b fill: %23fdf3aa%3b %7d .cls-13 %7b fill: %23fed281%3b %7d .cls-14 %7b fill: %23ee6949%3b %7d .cls-15 %7b fill: %2361b7ab%3b %7d .cls-16 %7b fill: %23af1446%3b %7d .cls-17 %7b fill: %23b1e0a1%3b %7d .cls-18 %7b fill: %23fba05c%3b %7d .cls-19 %7b fill: %234285b4%3b %7d .cls-20 %7b fill: %23e3f4a1%3b %7d .cls-21 %7b fill: %23f47b4c%3b %7d .cls-22 %7b fill: %23f88e53%3b %7d .cls-23 %7b fill: %235e4fa2%3b %7d .cls-24 %7b fill: %2374c4a7%3b %7d .cls-25 %7b fill: %234673b1%3b %7d .cls-26 %7b fill: %23e55949%3b %7d .cls-27 %7b fill: %23c4e79f%3b %7d .cls-28 %7b fill: %23bf2749%3b %7d .cls-29 %7b fill: %23db494a%3b %7d .cls-30 %7b fill: %235161aa%3b %7d .cls-31 %7b fill: %23fedf90%3b %7d .cls-32 %7b fill: %239dd8a3%3b %7d .cls-33 %7b fill: %2351a8af%3b %7d .cls-34 %7b fill: %239e0142%3b %7d .cls-35 %7b fill: %23fbf8b0%3b %7d .cls-36 %7b fill: %234696b3%3b %7d .cls-37 %7b fill: %23fcb368%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg%3e %3cpath class='cls-2' d='M20.5%2c20.5h290'/%3e %3cg%3e %3cline class='cls-3' x1='37.0519' y1='20' x2='37.0519' y2='14'/%3e %3ctext class='cls-4' transform='translate(35.6404 13.6366) rotate(-45)'%3ea%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='69.0389' y1='20' x2='69.0389' y2='14'/%3e %3ctext class='cls-4' transform='translate(67.6275 13.6366) rotate(-45)'%3eb%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='101.026' y1='20' x2='101.026' y2='14'/%3e %3ctext class='cls-4' transform='translate(99.6143 13.6366) rotate(-45)'%3ec%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='133.013' y1='20' x2='133.013' y2='14'/%3e %3ctext class='cls-4' transform='translate(131.6014 13.6366) rotate(-45)'%3ed%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='165' y1='20' x2='165' y2='14'/%3e %3ctext class='cls-4' transform='translate(163.5884 13.6366) rotate(-45)'%3ee%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='196.987' y1='20' x2='196.987' y2='14'/%3e %3ctext class='cls-4' transform='translate(195.5755 13.6366) rotate(-45)'%3ef%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='228.974' y1='20' x2='228.974' y2='14'/%3e %3ctext class='cls-4' transform='translate(227.5625 13.6366) rotate(-45)'%3eg%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='260.9611' y1='20' x2='260.9611' y2='14'/%3e %3ctext class='cls-4' transform='translate(259.5496 13.6366) rotate(-45)'%3eh%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='292.9481' y1='20' x2='292.9481' y2='14'/%3e %3ctext class='cls-4' transform='translate(291.5367 13.6366) rotate(-45)'%3ei%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-2' d='M20.5%2c20.5V149.3889'/%3e %3cg%3e %3cline class='cls-3' x1='20' y1='36.8977' x2='14' y2='36.8977'/%3e %3ctext class='cls-4' transform='translate(4.8916 40.0977)'%3e%ce%b1%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='20' y1='68.5955' x2='14' y2='68.5955'/%3e %3ctext class='cls-4' transform='translate(4.8916 71.7955)'%3e%ce%b2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='20' y1='100.2934' x2='14' y2='100.2934'/%3e %3ctext class='cls-4' transform='translate(5.4385 103.4933)'%3e%ce%b3%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-3' x1='20' y1='131.9912' x2='14' y2='131.9912'/%3e %3ctext class='cls-4' transform='translate(4.8916 135.1912)'%3e%ce%b4%3c/text%3e %3c/g%3e %3c/g%3e %3crect class='cls-5' x='22.1168' y='22.0976' width='30.2222' height='30.2222'/%3e %3crect class='cls-6' x='54.8144' y='22.8082' width='28.8011' height='28.8011'/%3e %3crect class='cls-7' x='91.6693' y='27.6761' width='19.0654' height='19.0654'/%3e %3crect class='cls-8' x='128.3619' y='32.3817' width='9.6541' height='9.6541'/%3e %3crect class='cls-9' x='158.1809' y='30.2137' width='13.9902' height='13.9902'/%3e %3crect class='cls-10' x='188.2623' y='28.3081' width='17.8013' height='17.8013'/%3e %3crect class='cls-11' x='222.4964' y='30.5551' width='13.3073' height='13.3073'/%3e %3crect class='cls-12' x='256.5577' y='32.6294' width='9.1587' height='9.1587'/%3e %3crect class='cls-13' x='285.0468' y='29.1315' width='16.1544' height='16.1545'/%3e %3crect class='cls-14' x='23.3213' y='54.9999' width='27.8133' height='27.8133'/%3e %3crect class='cls-15' x='59.9299' y='59.6215' width='18.5701' height='18.5701'/%3e %3crect class='cls-16' x='94.9082' y='62.6128' width='12.5874' height='12.5875'/%3e %3crect class='cls-17' x='120.0579' y='55.7755' width='26.2621' height='26.2621'/%3e %3crect class='cls-16' x='153.3521' y='57.0827' width='23.6477' height='23.6477'/%3e %3crect class='cls-18' x='193.7498' y='65.4933' width='6.8265' height='6.8265'/%3e %3crect class='cls-19' x='224.323' y='64.0795' width='9.6541' height='9.6541'/%3e %3crect class='cls-20' x='250.5615' y='58.331' width='21.1512' height='21.1511'/%3e %3crect class='cls-21' x='283.1145' y='58.8969' width='20.0192' height='20.0192'/%3e %3crect class='cls-22' x='31.5164' y='94.8929' width='11.4229' height='11.4229'/%3e %3crect class='cls-23' x='56.5353' y='87.9247' width='25.3593' height='25.3593'/%3e %3crect class='cls-24' x='87.8074' y='87.2098' width='26.7891' height='26.7891'/%3e %3crect class='cls-18' x='126.8952' y='94.3107' width='12.5875' height='12.5874'/%3e %3crect class='cls-25' x='160.5966' y='96.025' width='9.1587' height='9.1587'/%3e %3crect class='cls-14' x='192.8456' y='96.2869' width='8.6349' height='8.6349'/%3e %3crect class='cls-26' x='219.1404' y='90.5948' width='20.0192' height='20.0192'/%3e %3crect class='cls-27' x='249.3132' y='88.7805' width='23.6477' height='23.6477'/%3e %3crect class='cls-28' x='278.2461' y='85.7264' width='29.756' height='29.756'/%3e %3crect class='cls-29' x='30.2328' y='125.3071' width='13.9902' height='13.9902'/%3e %3crect class='cls-30' x='54.6535' y='117.7408' width='29.1229' height='29.1229'/%3e %3crect class='cls-31' x='91.9169' y='123.0171' width='18.5701' height='18.5701'/%3e %3crect class='cls-32' x='126.8952' y='126.0085' width='12.5875' height='12.5875'/%3e %3crect class='cls-33' x='154.0632' y='121.1894' width='22.2255' height='22.2255'/%3e %3crect class='cls-34' x='195.6366' y='130.7757' width='3.0529' height='3.0529'/%3e %3crect class='cls-35' x='220.3812' y='123.5334' width='17.5376' height='17.5376'/%3e %3crect class='cls-36' x='250.236' y='121.4011' width='21.8021' height='21.8021'/%3e %3crect class='cls-37' x='279.1339' y='118.312' width='27.9803' height='27.9803'/%3e %3c/g%3e%3c/svg%3e";

  const metadata$3 = {
    name: 'Matrix Plot',
    id: 'rawgraphs.matrixplot',
    thumbnail: img$5,
    icon: img$4,
    categories: ['correlations', 'Series temporelles', 'proportions'],
    description: 'It allows comparison of two categorical dimensions, disposing them on the horizontal and vertical axes. Each glyph (square or circle) represents a possible correlation among the two dimensions. Associated quantitative variables can be represented with size and/or color.' // code:'https://github.com/rawgraphs/raw',
    // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$3 = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: 'csvDistinct'
  }];

  const mapData$3 = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    const result = rollups(data, v => {
      return {
        x: v[0][mapping.x.value],
        // get the first one since it's grouped
        y: v[0][mapping.y.value],
        // get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        // aggregate. If not mapped, give 1 as size
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : undefined,
        // aggregate, by default single color.
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
    }, d => d[mapping.x.value] + '_' + d[mapping.y.value] // crossgrup functions
    );
    return result.map(d => d[1]);
  };

  function render$3(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      padding,
      rounding,
      sortXAxisBy,
      sortYAxisBy,
      showGrid,
      colorScale,
      labelStyles,
      showLabelsOutline,
      // legend
      showLegend,
      legendWidth
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    let chartWidth = width - margin.left - margin.right;
    let chartHeight = height - margin.top - margin.bottom; // sort data

    let rowsValues = rollups(data, v => sum(v, d => d.size), d => d.y).map(d => ({
      key: d[0],
      value: d[1]
    }));
    const colsValues = rollups(data, v => sum(v, d => d.size), d => d.x).map(d => ({
      key: d[0],
      value: d[1]
    }));

    switch (sortXAxisBy) {
      case 'Total value (descending)':
        colsValues.sort((a, b) => descending(a.value, b.value));
        break;

      case 'Total value (ascending)':
        colsValues.sort((a, b) => ascending(a.value, b.value));
        break;

      case 'Name':
        colsValues.sort((a, b) => ascending(a.key, b.key));
    }

    switch (sortYAxisBy) {
      case 'Total value (descending)':
        rowsValues.sort((a, b) => descending(a.value, b.value));
        break;

      case 'Total value (ascending)':
        rowsValues.sort((a, b) => ascending(a.value, b.value));
        break;

      case 'Name':
        rowsValues.sort((a, b) => ascending(a.key, b.key));
    } // first thing, understand if there are more rows or lines


    const rows = [...new Set(rowsValues.map(d => d.key))];
    const cols = [...new Set(colsValues.map(d => d.key))];
    let cellSize;

    if (rows.length > cols.length) {
      cellSize = (chartHeight - rows.length * padding) / rows.length;
      chartWidth = (cellSize + padding) * cols.length;
    } else {
      cellSize = (chartWidth - cols.length * padding) / cols.length;
      chartHeight = (cellSize + padding) * rows.length;
    }

    const x = band().range([0, chartWidth]).domain(cols).padding(padding / cellSize); // d3 expects padding expressed in % (0-1)

    const y = band().range([0, chartHeight]).domain(rows).padding(padding / cellSize); // d3 expects padding expressed in % (0-1)

    const sizeScale = sqrt$1().domain([0, max(data, d => d.size)]).range([0, cellSize]);
    const roundingScale = linear$2().domain([0, 100]).rangeRound([0, 50]); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');

    if (showGrid) {
      // add the X gridlines
      svg.append('g').attr('class', 'grid').attr('transform', 'translate(' + (cellSize / 2 + 1) + ',0)') // not clear why there is an offset of 2px
      .call(axisTop(x).tickSize(Math.round(-chartHeight + 1)).tickSizeOuter(0)); // add the Y gridlines

      svg.append('g').attr('class', 'grid').attr('transform', 'translate(0,' + (cellSize / 2 + 1) + ')') // not clear why there is an offset of 2px
      .call(axisLeft(y).tickSize(Math.round(-chartWidth + 1)).tickSizeOuter(0));
    } // add top x axis


    svg.append('g').call(axisTop(x).tickSizeOuter(0)).selectAll('text').attr('dx', Math.sqrt(12)) // proportional to text size. @TODO we should use a variable.
    .attr('dy', Math.sqrt(12)) // proportional to text size. @TODO we should use a variable
    .attr('text-anchor', 'start').attr('transform', 'rotate(-45)'); // add left y axis

    svg.append('g').call(axisLeft(y).tickSizeOuter(0)).selectAll('text'); // add y axis title

    svg.append('text').attr('dx', -9) // proportional to tick lines
    .attr('dy', -9) // proportional to tick lines
    .style('text-anchor', 'end').text(mapping.y.value).styles(styles.axisLabel); // add x axis title

    svg.append('text').attr('x', (chartWidth + 9) / Math.sqrt(2)) // proportional to tick lines
    .attr('y', (chartWidth + 9) / Math.sqrt(2)) // proportional to tick lines
    .attr('dx', Math.sqrt(12)) // proportional to text size. @TODO we should use a variable.
    .attr('dy', -Math.sqrt(12)) // proportional to text size. @TODO we should use a variable.
    .attr('transform', 'rotate(-45)').style('text-anchor', 'start').text(mapping.x.value).styles(styles.axisLabel); // draw squares or circles for each value

    svg.selectAll().data(data).enter().append('rect').attr('x', d => x(d.x) + (cellSize - sizeScale(d.size)) / 2).attr('y', d => y(d.y) + (cellSize - sizeScale(d.size)) / 2).attr('rx', d => roundingScale(rounding) * sizeScale(d.size) / 100).attr('ry', d => roundingScale(rounding) * sizeScale(d.size) / 100).attr('width', d => sizeScale(d.size)).attr('height', d => sizeScale(d.size)).style('fill', d => colorScale(d.color));
    const labelsLayer = svg.append('g').attr('id', 'labels');
    labelsLayer.selectAll('g').data(mapping.label.value ? data : []).join('g').attr('transform', d => `translate(${x(d.x) + cellSize / 2},${y(d.y) + cellSize / 2})`).append('text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => Array.isArray(d.label) ? d.label : [d.label]).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * (+styles[labelStyles[i]].fontSize.replace('px', '') + 2)).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      if (mapping.size.value) {
        const legendSizeScale = sizeScale.copy();
        const maxSize = sizeScale(max(data, d => d.size)) > legendWidth * 0.66 ? legendWidth * 0.66 : sizeScale(max(data, d => d.size));
        const shape = rounding >= 100 ? 'circle' : 'square';
        legendSizeScale.domain(extent(data, d => d.size)).rangeRound([sizeScale(min(data, d => d.size)), maxSize]);

        if (shape === 'circle') {
          legendSizeScale.rangeRound(legendSizeScale.range().map(d => d / 2));
        }

        chartLegend.addSize(mapping.size.value, legendSizeScale, shape);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$3 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 100,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    rounding: {
      type: 'number',
      label: 'Round Corners',
      default: 0,
      min: 0,
      max: 100,
      step: 1,
      group: 'chart'
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 2,
      group: 'chart'
    },
    sortXAxisBy: {
      type: 'text',
      label: 'Sort X axis by',
      group: 'chart',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Original'
    },
    sortYAxisBy: {
      type: 'text',
      label: 'Sort Y axis by',
      group: 'chart',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Original'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show grid',
      default: false,
      group: 'chart'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var matrixplot = {
    metadata: metadata$3,
    dimensions: dimensions$3,
    mapData: mapData$3,
    render: render$3,
    visualOptions: visualOptions$3,
    styles: styles$1
  };

  var img$6 = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M21.3809%2c16.8352l-3.3315-6.1467A20.0207%2c20.0207%2c0%2c0%2c0%2c9.2866%2c20.9942L15.96%2c23.1183A13.0486%2c13.0486%2c0%2c0%2c1%2c21.3809%2c16.8352Z'/%3e %3cpath class='cls-1' d='M27%2c15.0507v-7a19.8756%2c19.8756%2c0%2c0%2c0-8.0724%2c2.16l3.3317%2c6.1473A12.9065%2c12.9065%2c0%2c0%2c1%2c27%2c15.0507Z'/%3e %3cpath class='cls-1' d='M36.288%2c9.8245l-2.7429%2c6.4376A13.07%2c13.07%2c0%2c0%2c1%2c39.0645%2c21.2l6.0944-3.4295A20.0446%2c20.0446%2c0%2c0%2c0%2c36.288%2c9.8245Z'/%3e %3cpath class='cls-1' d='M29%2c8.0505v7a12.93%2c12.93%2c0%2c0%2c1%2c3.6276.8141l2.7346-6.4183A19.9179%2c19.9179%2c0%2c0%2c0%2c29%2c8.0505Z'/%3e %3cpath class='cls-1' d='M45.6652%2c18.6337l-6.102%2c3.4337a12.9061%2c12.9061%2c0%2c0%2c1%2c.102%2c11.634l6.052%2c3.56a19.941%2c19.941%2c0%2c0%2c0-.052-18.6275Z'/%3e %3cpath class='cls-1' d='M33.049%2c39.9792A12.915%2c12.915%2c0%2c0%2c1%2c30.87%2c40.67l1.2833%2c6.8863a20.1278%2c20.1278%2c0%2c0%2c0%2c4.1029-1.3548Z'/%3e %3cpath class='cls-1' d='M28%2c41a12.9119%2c12.9119%2c0%2c0%2c1-4.6613-.8786L20.5742%2c46.56a19.8067%2c19.8067%2c0%2c0%2c0%2c10.5965%2c1.1831l-1.2851-6.8956A12.9706%2c12.9706%2c0%2c0%2c1%2c28%2c41Z'/%3e %3cpath class='cls-1' d='M15%2c28a12.9514%2c12.9514%2c0%2c0%2c1%2c.3568-2.9746L8.6812%2c22.9005A19.8792%2c19.8792%2c0%2c0%2c0%2c19.6576%2c46.16l2.7634-6.4355A13.0035%2c13.0035%2c0%2c0%2c1%2c15%2c28Z'/%3e %3cpath class='cls-1' d='M34.8188%2c39.0472l3.2137%2c6.2356a20.08%2c20.08%2c0%2c0%2c0%2c6.6712-6.2971l-6.0495-3.5583A13.0845%2c13.0845%2c0%2c0%2c1%2c34.8188%2c39.0472Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M27%2c22.5956V16.0507a12.0185%2c12.0185%2c0%2c0%2c0-10.0878%2c7.3709l6.24%2c1.9861A5.513%2c5.513%2c0%2c0%2c1%2c27%2c22.5956Z'/%3e %3cpath class='cls-2' d='M33.5%2c28a5.46%2c5.46%2c0%2c0%2c1-.3369%2c1.8768l5.6382%2c3.3164A11.9619%2c11.9619%2c0%2c0%2c0%2c29%2c16.0507v6.5449A5.5059%2c5.5059%2c0%2c0%2c1%2c33.5%2c28Z'/%3e %3cpath class='cls-2' d='M22.5%2c28a5.5033%2c5.5033%2c0%2c0%2c1%2c.0475-.6858L16.31%2c25.3289A11.9871%2c11.9871%2c0%2c0%2c0%2c32.5878%2c39.0844l-3-5.82A5.4953%2c5.4953%2c0%2c0%2c1%2c22.5%2c28Z'/%3e %3cpath class='cls-2' d='M31.3632%2c32.3423%2c34.36%2c38.1572a12.0783%2c12.0783%2c0%2c0%2c0%2c3.428-3.2393L32.1481%2c31.6A5.5383%2c5.5383%2c0%2c0%2c1%2c31.3632%2c32.3423Z'/%3e %3c/g%3e%3c/svg%3e";

  var img$7 = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: none%3b %7d .cls-2 %7b clip-path: url(%23clip-path)%3b %7d .cls-3 %7b fill: white%3b %7d .cls-4 %7b fill: %23ccc%3b %7d .cls-5 %7b fill: %23a0d9a3%3b %7d .cls-6 %7b fill: %234ba0b1%3b %7d .cls-7 %7b fill: %235e4fa2%3b %7d .cls-8 %7b fill: %239e0142%3b %7d .cls-9 %7b fill: %23e1524a%3b %7d .cls-10 %7b fill: %23fba35e%3b %7d .cls-11 %7b fill: %23fee89a%3b %7d .cls-12 %7b fill: %23ebf7a6%3b %7d .cls-13%2c .cls-14%2c .cls-15%2c .cls-16 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-13 %7b letter-spacing: -0.0547em%3b %7d .cls-15 %7b letter-spacing: -0.0366em%3b %7d .cls-16 %7b letter-spacing: -0.0176em%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' width='320' height='160'/%3e %3c/clipPath%3e %3c/defs%3e %3cg class='cls-2'%3e %3cg%3e %3crect id='backgorund' class='cls-3' x='60' y='-20' width='200' height='200'/%3e %3cg id='viz'%3e %3cg%3e %3cpath class='cls-4' d='M160.1225%2c32a48%2c48%2c0%2c0%2c1%2c45.1469%2c63.9585l-22.1433-7.87A24.5%2c24.5%2c0%2c0%2c0%2c160.1225%2c55.5Z'/%3e %3cpath class='cls-3' d='M160.1225%2c32a48%2c48%2c0%2c0%2c1%2c45.1469%2c63.9585l-22.1433-7.87A24.5%2c24.5%2c0%2c0%2c0%2c160.1225%2c55.5V32m-1-1.0026V56.4953l.995.005a23.5%2c23.5%2c0%2c0%2c1%2c22.0647%2c31.2586l-.3286.9392.9376.3332%2c22.1433%2c7.87.9447.3357.3333-.9455A49%2c49%2c0%2c0%2c0%2c160.1251%2c31l-1.0026-.0026Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-4' d='M205.1874%2c96.19a48%2c48%2c0%2c0%2c1-92.1584-6.3038l23.0087-4.7813A24.5%2c24.5%2c0%2c0%2c0%2c183.0441%2c88.32Z'/%3e %3cpath class='cls-3' d='M136.0377%2c85.1045A24.5%2c24.5%2c0%2c0%2c0%2c183.0441%2c88.32l22.1433%2c7.87a48%2c48%2c0%2c0%2c1-92.1583-6.3038l23.0086-4.7813m.7707-1.1815-.9742.2025-23.0086%2c4.7812-.9816.204.2065.9811a48.9951%2c48.9951%2c0%2c0%2c0%2c94.0783%2c6.4351l.3381-.9438-.9446-.3358-22.1433-7.87-.9376-.3332-.3379.9359a23.3594%2c23.3594%2c0%2c0%2c1-17.2073%2c15.004%2c23.4734%2c23.4734%2c0%2c0%2c1-27.88-18.0881l-.2073-.9732Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-4' d='M112.9792%2c89.6459A48%2c48%2c0%2c0%2c1%2c159.8775%2c32V55.5a24.5%2c24.5%2c0%2c0%2c0-23.89%2c29.3644Z'/%3e %3cpath class='cls-3' d='M159.8775%2c32V55.5a24.5%2c24.5%2c0%2c0%2c0-23.89%2c29.3644l-23.0086%2c4.7812A48%2c48%2c0%2c0%2c1%2c159.8775%2c32m1-1.0026L159.8749%2c31A49%2c49%2c0%2c0%2c0%2c112%2c89.8469l.2014.9821.9817-.204%2c23.0085-4.7812.9742-.2025-.1975-.9752A23.5%2c23.5%2c0%2c0%2c1%2c159.8825%2c56.5l.995-.005V30.9976Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-5' d='M160.1225%2c7.5a72.5013%2c72.5013%2c0%2c0%2c1%2c28.6492%2c5.9534L179.4092%2c35.008A48.9975%2c48.9975%2c0%2c0%2c0%2c160.1225%2c31Z'/%3e %3cpath class='cls-3' d='M160.1225%2c7.5a72.5013%2c72.5013%2c0%2c0%2c1%2c28.6492%2c5.9534L179.4092%2c35.008A48.9975%2c48.9975%2c0%2c0%2c0%2c160.1225%2c31V7.5m-1-1.0017V31.9977L160.12%2c32a47.7325%2c47.7325%2c0%2c0%2c1%2c18.8931%2c3.926l.916.3951.3974-.9149%2c9.3623-21.5545.3992-.9188-.9195-.3975A73.0859%2c73.0859%2c0%2c0%2c0%2c160.1242%2c6.5l-1.0017-.0017Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-6' d='M188.9964%2c13.5511a72.4993%2c72.4993%2c0%2c0%2c1%2c35.3188%2c32.9855L203.45%2c57.3481A49%2c49%2c0%2c0%2c0%2c179.634%2c35.1056Z'/%3e %3cpath class='cls-3' d='M188.9964%2c13.5511a72.4993%2c72.4993%2c0%2c0%2c1%2c35.3188%2c32.9855L203.45%2c57.3481A49%2c49%2c0%2c0%2c0%2c179.634%2c35.1056l9.3624-21.5545m-.5181-1.3172-.3991.9188-9.3625%2c21.5545-.3974.9149.914.4a48.1614%2c48.1614%2c0%2c0%2c1%2c23.33%2c21.7886l.4611.8845.8857-.4589%2c20.8653-10.8115.8894-.4609-.4624-.8886a73.7354%2c73.7354%2c0%2c0%2c0-35.8059-33.44l-.9181-.4006Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-7' d='M224.4279%2c46.7541a72.5%2c72.5%2c0%2c0%2c1%2c3.9269%2c57.4092l-22.1431-7.87a49%2c49%2c0%2c0%2c0-2.6491-38.728Z'/%3e %3cpath class='cls-3' d='M224.428%2c46.7541a72.5%2c72.5%2c0%2c0%2c1%2c3.9269%2c57.4092l-22.1432-7.87a49%2c49%2c0%2c0%2c0-2.6491-38.7279L224.428%2c46.7541m.4293-1.3487-.8894.4608L203.1025%2c56.6778l-.8856.4589.4567.8868a48.19%2c48.19%2c0%2c0%2c1%2c2.595%2c37.9376l-.3317.9407.94.3341%2c22.1432%2c7.87.9439.3354.3338-.9444a73.7776%2c73.7776%2c0%2c0%2c0-3.981-58.2011l-.4594-.89Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-8' d='M228.2728%2c104.3942a72.5%2c72.5%2c0%2c0%2c1-15.2037%2c25.0013l-17.1746-16.04A49.0008%2c49.0008%2c0%2c0%2c0%2c206.13%2c96.5245Z'/%3e %3cpath class='cls-3' d='M206.13%2c96.5245l22.1432%2c7.87a72.5009%2c72.5009%2c0%2c0%2c1-15.2036%2c25.0013l-17.1747-16.04A49.0008%2c49.0008%2c0%2c0%2c0%2c206.13%2c96.5245m-.605-1.2763-.3364.939a47.7326%2c47.7326%2c0%2c0%2c1-10.0263%2c16.4876l-.679.7307.729.6808%2c17.1747%2c16.04.7321.6837.6824-.7333a73.0843%2c73.0843%2c0%2c0%2c0%2c15.4134-25.3462l.3371-.9432-.9439-.3355-22.1432-7.87-.94-.334Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-9' d='M212.9019%2c129.5746a72.5%2c72.5%2c0%2c0%2c1-98.5607%2c6.7417l14.8306-18.2293a49%2c49%2c0%2c0%2c0%2c66.5554-4.5525Z'/%3e %3cpath class='cls-3' d='M195.7272%2c113.5345l17.1747%2c16.04a72.4976%2c72.4976%2c0%2c0%2c1-98.5607%2c6.7417l14.8306-18.2293a48.9982%2c48.9982%2c0%2c0%2c0%2c66.5554-4.5525m-.0464-1.4116-.6827.7273a47.9984%2c47.9984%2c0%2c0%2c1-65.1971%2c4.46l-.7754-.6276-.63.7738-14.8306%2c18.2292-.6322.777.7781.6309a73.4975%2c73.4975%2c0%2c0%2c0%2c99.92-6.8348l.6849-.7309-.732-.6837-17.1747-16.04-.729-.6808Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-10' d='M114.1512%2c136.1617a72.5%2c72.5%2c0%2c0%2c1-25.11-41.2912L112.05%2c90.0893a49%2c49%2c0%2c0%2c0%2c16.9318%2c27.8431Z'/%3e %3cpath class='cls-3' d='M112.05%2c90.0892a49%2c49%2c0%2c0%2c0%2c16.9319%2c27.8432l-14.8306%2c18.2293a72.5%2c72.5%2c0%2c0%2c1-25.11-41.2912L112.05%2c90.0892m.7732-1.182-.9766.203L88.838%2c93.8914l-.9808.2038.2055.98a73.7347%2c73.7347%2c0%2c0%2c0%2c25.4561%2c41.8607l.7759.6335.6322-.777%2c14.83-18.2293.63-.7738-.7723-.6314a48.16%2c48.16%2c0%2c0%2c1-16.5862-27.275l-.2054-.9761Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-11' d='M88.9916%2c94.6306a72.5%2c72.5%2c0%2c0%2c1%2c11.7075-56.34l19.1989%2c13.552A49%2c49%2c0%2c0%2c0%2c112%2c89.8494Z'/%3e %3cpath class='cls-3' d='M100.6991%2c38.2908l19.1988%2c13.552A49.0006%2c49.0006%2c0%2c0%2c0%2c112%2c89.8494L88.9916%2c94.6306a72.5%2c72.5%2c0%2c0%2c1%2c11.7075-56.34m-.2417-1.3946-.5762.8193A73.7772%2c73.7772%2c0%2c0%2c0%2c88.0121%2c94.8324l.2022.9811.9807-.2038%2c23.0086-4.7813.9766-.2029-.2005-.9771a48.1884%2c48.1884%2c0%2c0%2c1%2c7.7367-37.2309l.5732-.8164-.815-.5752L101.2758%2c37.4738l-.8184-.5776Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-12' d='M100.84%2c38.0907A72.5%2c72.5%2c0%2c0%2c1%2c159.8775%2c7.5V31a49%2c49%2c0%2c0%2c0-39.8383%2c20.6425Z'/%3e %3cpath class='cls-3' d='M159.8775%2c7.5V31a49%2c49%2c0%2c0%2c0-39.8383%2c20.6425L100.84%2c38.0907A72.5%2c72.5%2c0%2c0%2c1%2c159.8775%2c7.5m1-1.0017L159.8758%2c6.5a73.625%2c73.625%2c0%2c0%2c0-59.8514%2c31.0125l-.579.8174.8183.5776L119.4626%2c52.46l.8149.5753.5773-.8135A48.0911%2c48.0911%2c0%2c0%2c1%2c159.88%2c32l.9975-.0024V6.4984Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-6' d='M198.7572-8.9206a96.996%2c96.996%2c0%2c0%2c1%2c11.5377%2c5.9783l-12.21%2c20.0789a73.49%2c73.49%2c0%2c0%2c0-8.69-4.5027Z'/%3e %3cpath class='cls-3' d='M198.7572-8.9206a96.996%2c96.996%2c0%2c0%2c1%2c11.5377%2c5.9783l-12.21%2c20.0789a73.4973%2c73.4973%2c0%2c0%2c0-8.69-4.5027l9.3624-21.5545m-.5183-1.3168-.3989.9184-9.3625%2c21.5545-.3977.9156.9151.3993a72.7518%2c72.7518%2c0%2c0%2c1%2c8.5716%2c4.4415l.8539.5173.5187-.853%2c12.21-20.0789.52-.8555-.8562-.5191a98.325%2c98.325%2c0%2c0%2c0-11.6567-6.04l-.9178-.4Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-7' d='M246.1812%2c35.4825a97.0035%2c97.0035%2c0%2c0%2c1%2c8.765%2c24.6623l-23.0085%2c4.7813a73.5008%2c73.5008%2c0%2c0%2c0-6.6219-18.6321Z'/%3e %3cpath class='cls-3' d='M246.1812%2c35.4825a97.0035%2c97.0035%2c0%2c0%2c1%2c8.765%2c24.6623l-23.0085%2c4.7813a73.5044%2c73.5044%2c0%2c0%2c0-6.6218-18.6321l20.8653-10.8115m.4289-1.3485-.889.4606L224.8558%2c45.4062l-.8864.4592.4578.8872a72.5065%2c72.5065%2c0%2c0%2c1%2c6.5317%2c18.3786l.2048.9771.9774-.2032L255.15%2c61.1239l.98-.2037-.2049-.98A98.0087%2c98.0087%2c0%2c0%2c0%2c247.07%2c35.0236l-.46-.89Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-7' d='M254.996%2c60.3847a97.003%2c97.003%2c0%2c0%2c1%2c1.7694%2c12.8736L233.32%2c74.862a73.493%2c73.493%2c0%2c0%2c0-1.3327-9.6961Z'/%3e %3cpath class='cls-3' d='M254.996%2c60.3847a96.9865%2c96.9865%2c0%2c0%2c1%2c1.7694%2c12.8736L233.32%2c74.862a73.493%2c73.493%2c0%2c0%2c0-1.3327-9.6961l23.0085-4.7812m.7768-1.1828-.98.2037L231.784%2c64.1869l-.9774.2031.2015.9778a72.7592%2c72.7592%2c0%2c0%2c1%2c1.3145%2c9.5641l.07.9959.9959-.0682%2c23.4453-1.6036.9989-.0684-.07-.9988a98.321%2c98.321%2c0%2c0%2c0-1.7877-13.0063l-.2025-.9806Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-8' d='M251.3582%2c112.5987a97.0007%2c97.0007%2c0%2c0%2c1-5.177%2c11.9188L225.3158%2c113.706a73.4984%2c73.4984%2c0%2c0%2c0%2c3.8993-8.977Z'/%3e %3cpath class='cls-3' d='M229.2151%2c104.729l22.1431%2c7.87a97.0007%2c97.0007%2c0%2c0%2c1-5.177%2c11.9188L225.3159%2c113.706a73.5133%2c73.5133%2c0%2c0%2c0%2c3.8992-8.977m-.6058-1.2765-.3359.94a72.78%2c72.78%2c0%2c0%2c1-3.8462%2c8.8548l-.4578.8872.8864.4592%2c20.8653%2c10.8116.889.4606.46-.89a98.3358%2c98.3358%2c0%2c0%2c0%2c5.23-12.0416l.3365-.943-.9434-.3353-22.1431-7.87-.9407-.3343Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-9' d='M230.8074%2c146.2971a97%2c97%2c0%2c0%2c1-32.05%2c22.6235l-9.3624-21.5545a73.4991%2c73.4991%2c0%2c0%2c0%2c24.238-17.109Z'/%3e %3cpath class='cls-3' d='M213.6328%2c130.2571l17.1746%2c16.04a97%2c97%2c0%2c0%2c1-32.05%2c22.6235l-9.3624-21.5545a73.4991%2c73.4991%2c0%2c0%2c0%2c24.238-17.109m-.0471-1.4122-.6826.7284A72.0921%2c72.0921%2c0%2c0%2c1%2c188.9949%2c146.45l-.9151.3993.3977.9156L197.84%2c169.319l.3989.9184.9178-.4a97.4441%2c97.4441%2c0%2c0%2c0%2c32.3807-22.8567l.6843-.7309-.7317-.6834-17.1747-16.04-.73-.6814Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-10' d='M98.69%2c155.1666A97%2c97%2c0%2c0%2c1%2c80.8246%2c136.038l19.1988-13.552A73.4985%2c73.4985%2c0%2c0%2c0%2c113.52%2c136.9374Z'/%3e %3cpath class='cls-3' d='M100.0234%2c122.486A73.4985%2c73.4985%2c0%2c0%2c0%2c113.52%2c136.9374L98.69%2c155.1666A97.0033%2c97.0033%2c0%2c0%2c1%2c80.8246%2c136.038l19.1988-13.552m.239-1.3927-.8156.5758L80.248%2c135.2211l-.818.5774.5784.8172a98.0078%2c98.0078%2c0%2c0%2c0%2c18.049%2c19.3258l.7759.6329.6319-.7767%2c14.8306-18.2292.63-.7744-.7733-.6314a72.508%2c72.508%2c0%2c0%2c1-13.3131-14.2547l-.577-.8147Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-11' d='M65.004%2c99.6153a97%2c97%2c0%2c0%2c1%2c0-39.2306l23.0085%2c4.7812a73.499%2c73.499%2c0%2c0%2c0%2c0%2c29.6682Z'/%3e %3cpath class='cls-3' d='M65.004%2c60.3847l23.0085%2c4.7812a73.499%2c73.499%2c0%2c0%2c0%2c0%2c29.6682L65.004%2c99.6153a97%2c97%2c0%2c0%2c1%2c0-39.2306m-.7768-1.1828-.2025.9806a97.443%2c97.443%2c0%2c0%2c0%2c0%2c39.635l.2025.9806.98-.2037%2c23.0084-4.7813.9775-.2031-.2015-.9778a72.0924%2c72.0924%2c0%2c0%2c1%2c0-29.2644l.2015-.9778-.9775-.2031L65.2075%2c59.4056l-.98-.2037Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-12' d='M121.4675-9.0182A97.0157%2c97.0157%2c0%2c0%2c1%2c133.7118-13.37l6.34%2c22.6286a73.5011%2c73.5011%2c0%2c0%2c0-9.2221%2c3.2776Z'/%3e %3cpath class='cls-3' d='M133.7118-13.37l6.34%2c22.6286a73.5011%2c73.5011%2c0%2c0%2c0-9.2221%2c3.2776L121.4675-9.0182A97.0157%2c97.0157%2c0%2c0%2c1%2c133.7118-13.37m.6928-1.2339-.9638.2714a98.3347%2c98.3347%2c0%2c0%2c0-12.37%2c4.3965l-.9189.3977.3988.9184%2c9.3625%2c21.5545.3977.9157.9163-.3963a72.7684%2c72.7684%2c0%2c0%2c1%2c9.0967-3.2329l.9608-.271-.2692-.9613-6.34-22.6286-.27-.9641Z'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-12' d='M133.9477-13.436A96.9973%2c96.9973%2c0%2c0%2c1%2c159.8775-17V6.5a73.4985%2c73.4985%2c0%2c0%2c0-19.59%2c2.6925Z'/%3e %3cpath class='cls-3' d='M159.8775-17V6.5a73.4985%2c73.4985%2c0%2c0%2c0-19.59%2c2.6925l-6.34-22.6285A96.9933%2c96.9933%2c0%2c0%2c1%2c159.8775-17m1-1.0013L159.8762-18a98.0075%2c98.0075%2c0%2c0%2c0-26.1971%2c3.6007l-.9644.2689.27.9642%2c6.34%2c22.6285.2694.9613.9617-.2677A72.51%2c72.51%2c0%2c0%2c1%2c159.8792%2c7.5l.9983-.0017v-25.5Z'/%3e %3c/g%3e %3c/g%3e %3cg%3e %3ctext class='cls-13' transform='translate(189.315 63.5932) rotate(-35.2174)'%3eA%3c/text%3e %3ctext class='cls-14' transform='translate(160.7473 120.2018) rotate(-86.0871)'%3eB%3c/text%3e %3ctext class='cls-14' transform='translate(126.4549 57.2496) rotate(39.1306)'%3eC%3c/text%3e %3ctext class='cls-14' transform='translate(175.6043 22.1702) rotate(-78.2606)'%3eI%3c/text%3e %3ctext class='cls-15' transform='matrix(0.6826%2c -0.7308%2c 0.7308%2c 0.6826%2c 202.474%2c 39.5994)'%3eL%3c/text%3e %3ctext class='cls-14' transform='translate(217.1808 79.626) rotate(-3.9129)'%3eM%3c/text%3e %3ctext class='cls-14' transform='translate(207.4671 112.9127) rotate(31.3041)'%3eD%3c/text%3e %3ctext class='cls-14' transform='translate(160.4322 138.009) rotate(86.0871)'%3eE%3c/text%3e %3ctext class='cls-14' transform='translate(106.8484 116.44) rotate(-31.3041)'%3eF%3c/text%3e %3ctext class='cls-14' transform='translate(95.4458 70.1712) rotate(11.7394)'%3eG%3c/text%3e %3ctext class='cls-14' transform='matrix(0.4601%2c 0.8879%2c -0.8879%2c 0.4601%2c 127.0505%2c 24.1006)'%3eH%3c/text%3e %3ctext class='cls-14' transform='matrix(0.4601%2c -0.8879%2c 0.8879%2c 0.4601%2c 201.233%2c 8.1878)'%3eF%3c/text%3e %3ctext class='cls-14' transform='translate(238.5645 55.78) rotate(-19.5653)'%3eU%3c/text%3e %3ctext class='cls-14' transform='translate(242.1843 72.2519) rotate(-7.8262)'%3eV%3c/text%3e %3ctext class='cls-14' transform='translate(233.9428 115.915) rotate(23.4782)'%3eN%3c/text%3e %3ctext class='cls-14' transform='translate(204.3448 148.8938) rotate(54.7826)'%3eO%3c/text%3e %3ctext class='cls-16' transform='matrix(0.7308%2c -0.6826%2c 0.6826%2c 0.7308%2c 97.289%2c 143.4203)'%3eP%3c/text%3e %3ctext class='cls-14' transform='translate(70.3608 83.5)'%3eQ%3c/text%3e %3ctext class='cls-14' transform='translate(126.7882 -3.0332) rotate(70.4347)'%3eR%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$4 = {
    name: 'Diagramme sunburst',
    id: 'rawgraphs.sunburst',
    thumbnail: img$7,
    icon: img$6,
    categories: ['hierarchies', 'proportions'],
    description: 'Il affiche des données structurées hiérarchiquement et une dimension quantitative associée à l\'aide de cercles concentriques. Le cercle au centre représente le nœud racine, les hiérarchies se déplaçant vers l\'extérieur à partir du centre. L\'angle de chaque arc correspond à la dimension qualitative.',
    code: 'https://observablehq.com/@d3/sunburst' // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$4 = [{
    id: 'hierarchy',
    name: 'Hiérarchie',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé feuille',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }];

  const mapData$4 = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    const results = [];
    rollups(data, v => {
      const item = {
        hierarchy: new Map(mapping.hierarchy.value.map(d => [d, v[0][d]])),
        //get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'cells color',
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
      results.push(item);
      return item;
    }, ...mapping.hierarchy.value.map(level => d => d[level]) // create a grouping for each level of the hierarchy
    );
    return results;
  };

  function render$4(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legend
      showLegend,
      legendWidth,
      // chart
      padding,
      // labels
      label1Style,
      label2Style,
      label3Style,
      // colors
      colorScale,
      // labels
      showHierarchyLabels,
      labelHierarchyStyle,
      labelStyles,
      showLabelsOutline,
      autoHideLabels
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const radius = chartWidth > chartHeight ? chartHeight / 2 : chartWidth / 2; // create the hierarchical structure

    const nest = rollup(data, v => v[0], ...mapping.hierarchy.value.map(level => d => d.hierarchy.get(level)));
    const hierarchy$1 = hierarchy(nest).sum(d => d[1] instanceof Map ? 0 : d[1].size); // since maps have also a .size porperty, sum only values for leaves, and not for Maps
    //@TODO: find a way to filter hierarchy

    const partition$1 = nest => partition() // copied from example of d3v6, not clear the meaning
    .size([2 * Math.PI, radius])(hierarchy$1);

    const root = partition$1();
    const arc$1 = arc().startAngle(d => d.x0).endAngle(d => d.x1).padAngle(padding / (radius / 2)) // convert padding in radians
    .padRadius(radius / 2).innerRadius(d => d.y0).outerRadius(d => d.y1 - padding);
    const svg = select(svgNode); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    svg.append('g').attr('transform', `translate(${width / 2},${height / 2})`).attr('id', 'viz').selectAll('path').data(root.descendants().filter(d => d.depth)).join('path').attr('fill', function (d) {
      if ('children' in d) {
        // if not leaf, check if leaves has the same value
        const childrenColors = [...new Set(d.leaves().map(l => l.data[1].color))];
        return childrenColors.length == 1 ? colorScale(childrenColors[0]) : '#cccccc';
      } else {
        // otherwise, if it's a leaf use its own color
        return colorScale(d.data[1].color);
      }
    }).attr('display', d => d.data[0] != '' ? '' : 'none').attr('d', arc$1).append('title').text(d => d.data[0]);
    const textGroups = svg.append('g').attr('id', 'labels').attr('transform', `translate(${width / 2},${height / 2})`).attr('text-anchor', 'middle').selectAll('text').data(root.descendants()).join('text').filter(d => showHierarchyLabels ? true : !d.children) // if showHierarchyLabels is false, hide non-leaf nodes
    .filter(d => d.data[0] != '').attr('transform', function (d) {
      const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
      const y = (d.y0 + d.y1) / 2;
      return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
    });
    textGroups.selectAll('tspan') // if node not a leaf, show just its name.
    .data(d => {
      console.log(d);

      if (d.children) {
        return [{
          string: d.data[0],
          hierarchy: true
        }];
      } else {
        // if labels are mapped, return them
        if (mapping.label.value.length > 0) {
          return d.data[1].label.map(d => ({
            string: d,
            hierarchy: false
          }));
        } else {
          //otherwise, return just leaf name
          return [{
            string: d.data[0],
            hierarchy: true
          }];
        }
      }
    }).join('tspan').attr('x', 0).attr('y', (d, i, n) => (i + 1) * 12 - n.length / 2 * 12 - 2) // @TODO: 12 is the font size. we should expose this
    .text(d => d.string).styles((d, i) => d.hierarchy ? styles[labelHierarchyStyle] : styles[labelStyles[i]]);

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      textGroups.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(textGroups, d => d.size);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$4 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 2,
      group: 'chart'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    showHierarchyLabels: {
      type: 'boolean',
      label: 'Show hierarchy labels',
      default: true,
      group: 'labels'
    },
    labelHierarchyStyle: {
      type: 'text',
      label: 'Hierarchy labels',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelItalic',
      disabled: {
        showHierarchyLabels: false
      }
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels'
    }
  };

  var sunburst = {
    metadata: metadata$4,
    dimensions: dimensions$4,
    mapData: mapData$4,
    render: render$4,
    visualOptions: visualOptions$4,
    styles: styles$1
  };

  var img$8 = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M45%2c25a90.3265%2c90.3265%2c0%2c0%2c1-18.2163-1.6064A77.3649%2c77.3649%2c0%2c0%2c0%2c11%2c22V8A90.3265%2c90.3265%2c0%2c0%2c1%2c29.2163%2c9.6064%2c77.3649%2c77.3649%2c0%2c0%2c0%2c45%2c11Z'/%3e %3cpath class='cls-1' d='M20%2c34a11.2837%2c11.2837%2c0%2c0%2c1-6.6768-2.1445A3.5143%2c3.5143%2c0%2c0%2c0%2c11%2c31V23a11.2837%2c11.2837%2c0%2c0%2c1%2c6.6768%2c2.1445A3.5143%2c3.5143%2c0%2c0%2c0%2c20%2c26Z'/%3e %3cpath class='cls-1' d='M11%2c40V38a6.3605%2c6.3605%2c0%2c0%2c0%2c3.9556-1.3389A8.3093%2c8.3093%2c0%2c0%2c1%2c20%2c35v2a6.3605%2c6.3605%2c0%2c0%2c0-3.9556%2c1.3389A8.3093%2c8.3093%2c0%2c0%2c1%2c11%2c40Z'/%3e %3cpath class='cls-1' d='M11%2c48V41a46.4412%2c46.4412%2c0%2c0%2c0%2c9.8623-.9414A53.0311%2c53.0311%2c0%2c0%2c1%2c32%2c39v7a46.4412%2c46.4412%2c0%2c0%2c0-9.8623.9414A53.0311%2c53.0311%2c0%2c0%2c1%2c11%2c48Z'/%3e %3cpath class='cls-1' d='M32%2c38a19.419%2c19.419%2c0%2c0%2c1-5.334-.6641A8.857%2c8.857%2c0%2c0%2c0%2c24%2c37V26a19.419%2c19.419%2c0%2c0%2c1%2c5.334.6641A8.857%2c8.857%2c0%2c0%2c0%2c32%2c27Z'/%3e %3cpath class='cls-1' d='M36%2c46V27a9.243%2c9.243%2c0%2c0%2c0%2c2.4922-.2852A27.6609%2c27.6609%2c0%2c0%2c1%2c45%2c26V45a9.243%2c9.243%2c0%2c0%2c0-2.4922.2852A27.6609%2c27.6609%2c0%2c0%2c1%2c36%2c46Z'/%3e %3c/g%3e %3cg id='primary'%3e %3crect class='cls-2' x='8' y='8' width='2' height='23'/%3e %3crect class='cls-2' x='8' y='38' width='2' height='10'/%3e %3crect class='cls-2' x='46' y='11' width='2' height='34'/%3e %3crect class='cls-2' x='21' y='26' width='2' height='11'/%3e %3crect class='cls-2' x='33' y='27' width='2' height='19'/%3e %3c/g%3e%3c/svg%3e";

  var img$9 = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: %23666%3b %7d .cls-3%2c .cls-4%2c .cls-5%2c .cls-6%2c .cls-7%2c .cls-8 %7b fill: none%3b stroke: %23ccc%3b stroke-opacity: 0.5%3b %7d .cls-3 %7b stroke-width: 67.1111px%3b %7d .cls-4 %7b stroke-width: 41.9444px%3b %7d .cls-5 %7b stroke-width: 16.7778px%3b %7d .cls-6 %7b stroke-width: 25.1667px%3b %7d .cls-7 %7b stroke-width: 58.7222px%3b %7d .cls-8 %7b stroke-width: 83.8889px%3b %7d .cls-10%2c .cls-9 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-9 %7b letter-spacing: -0.0547em%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg%3e %3crect class='cls-2' x='2' y='2' width='10' height='109.0556'/%3e %3crect class='cls-2' x='308' y='2' width='10' height='151'/%3e %3crect class='cls-2' x='104' y='71.4903' width='10' height='58.7222'/%3e %3crect class='cls-2' x='2' y='116.0556' width='10' height='41.9444'/%3e %3crect class='cls-2' x='206' y='73.7409' width='10' height='83.8889'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-3' d='M12%2c35.5556H308'/%3e %3cpath class='cls-4' d='M12%2c90.0833c46%2c0%2c46%2c2.3792%2c92%2c2.3792'/%3e %3cpath class='cls-5' d='M12%2c124.4444c46%2c0%2c46-2.6208%2c92-2.6208'/%3e %3cpath class='cls-6' d='M12%2c145.4167c97%2c0%2c97-.37%2c194-.37'/%3e %3cpath class='cls-7' d='M114%2c100.8514c46%2c0%2c46%2c2.2506%2c92%2c2.2506'/%3e %3cpath class='cls-8' d='M216%2c115.6853c46%2c0%2c46-4.63%2c92-4.63'/%3e %3c/g%3e %3cg%3e %3ctext class='cls-9' transform='translate(18 60.0278)'%3eA%3c/text%3e %3ctext class='cls-10' transform='translate(295.3301 81)'%3eE%3c/text%3e %3ctext class='cls-10' transform='translate(120 104.3514)'%3eC%3c/text%3e %3ctext class='cls-10' transform='translate(18 140.5278)'%3eB%3c/text%3e %3ctext class='cls-10' transform='translate(192.7783 119.1853)'%3eD%3c/text%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$5 = {
    name: 'Sankey Diagram',
    id: 'rawgraphs.sankeydiagram',
    thumbnail: img$9,
    icon: img$8,
    categories: ['networks'],
    description: 'It represents flows among nodes of a network. Nodes are represented as rectangles, the height represents their value. Flows are represented with curved lines whose width is proportional to their value.',
    code: 'https://observablehq.com/@d3/sankey-diagram'
  };

  const dimensions$5 = [{
    id: 'source',
    name: 'Source node',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'target',
    name: 'Target node',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }];

  const mapData$5 = function (data, mapping, dataTypes, dimensions) {
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const results = [];
    rollups(data, v => {
      const item = {
        source: v[0][mapping.source.value],
        target: v[0][mapping.target.value],
        value: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : 1
      };
      results.push(item);
      return item;
    }, d => d[mapping.source.value] + d[mapping.target.value] // crossgrup functions. aggregate links among same source and target
    );
    return results;
  };

  function targetDepth(d) {
    return d.target.depth;
  }

  function left$1(node) {
    return node.depth;
  }

  function right$1(node, n) {
    return n - 1 - node.height;
  }

  function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
  }

  function center$2(node) {
    return node.targetLinks.length ? node.depth
        : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1
        : 0;
  }

  function constant$m(x) {
    return function() {
      return x;
    };
  }

  function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
  }

  function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
  }

  function ascendingBreadth(a, b) {
    return a.y0 - b.y0;
  }

  function value(d) {
    return d.value;
  }

  function defaultId$2(d) {
    return d.index;
  }

  function defaultNodes(graph) {
    return graph.nodes;
  }

  function defaultLinks(graph) {
    return graph.links;
  }

  function find$3(nodeById, id) {
    const node = nodeById.get(id);
    if (!node) throw new Error("missing: " + id);
    return node;
  }

  function computeLinkBreadths({nodes}) {
    for (const node of nodes) {
      let y0 = node.y0;
      let y1 = y0;
      for (const link of node.sourceLinks) {
        link.y0 = y0 + link.width / 2;
        y0 += link.width;
      }
      for (const link of node.targetLinks) {
        link.y1 = y1 + link.width / 2;
        y1 += link.width;
      }
    }
  }

  function Sankey() {
    let x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent
    let dx = 24; // nodeWidth
    let dy = 8, py; // nodePadding
    let id = defaultId$2;
    let align = justify;
    let sort;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations = 6;

    function sankey() {
      const graph = {nodes: nodes.apply(null, arguments), links: links.apply(null, arguments)};
      computeNodeLinks(graph);
      computeNodeValues(graph);
      computeNodeDepths(graph);
      computeNodeHeights(graph);
      computeNodeBreadths(graph);
      computeLinkBreadths(graph);
      return graph;
    }

    sankey.update = function(graph) {
      computeLinkBreadths(graph);
      return graph;
    };

    sankey.nodeId = function(_) {
      return arguments.length ? (id = typeof _ === "function" ? _ : constant$m(_), sankey) : id;
    };

    sankey.nodeAlign = function(_) {
      return arguments.length ? (align = typeof _ === "function" ? _ : constant$m(_), sankey) : align;
    };

    sankey.nodeSort = function(_) {
      return arguments.length ? (sort = _, sankey) : sort;
    };

    sankey.nodeWidth = function(_) {
      return arguments.length ? (dx = +_, sankey) : dx;
    };

    sankey.nodePadding = function(_) {
      return arguments.length ? (dy = py = +_, sankey) : dy;
    };

    sankey.nodes = function(_) {
      return arguments.length ? (nodes = typeof _ === "function" ? _ : constant$m(_), sankey) : nodes;
    };

    sankey.links = function(_) {
      return arguments.length ? (links = typeof _ === "function" ? _ : constant$m(_), sankey) : links;
    };

    sankey.linkSort = function(_) {
      return arguments.length ? (linkSort = _, sankey) : linkSort;
    };

    sankey.size = function(_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
    };

    sankey.extent = function(_) {
      return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
    };

    sankey.iterations = function(_) {
      return arguments.length ? (iterations = +_, sankey) : iterations;
    };

    function computeNodeLinks({nodes, links}) {
      for (const [i, node] of nodes.entries()) {
        node.index = i;
        node.sourceLinks = [];
        node.targetLinks = [];
      }
      const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]));
      for (const [i, link] of links.entries()) {
        link.index = i;
        let {source, target} = link;
        if (typeof source !== "object") source = link.source = find$3(nodeById, source);
        if (typeof target !== "object") target = link.target = find$3(nodeById, target);
        source.sourceLinks.push(link);
        target.targetLinks.push(link);
      }
      if (linkSort != null) {
        for (const {sourceLinks, targetLinks} of nodes) {
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      }
    }

    function computeNodeValues({nodes}) {
      for (const node of nodes) {
        node.value = node.fixedValue === undefined
            ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value))
            : node.fixedValue;
      }
    }

    function computeNodeDepths({nodes}) {
      const n = nodes.length;
      let current = new Set(nodes);
      let next = new Set;
      let x = 0;
      while (current.size) {
        for (const node of current) {
          node.depth = x;
          for (const {target} of node.sourceLinks) {
            next.add(target);
          }
        }
        if (++x > n) throw new Error("circular link");
        current = next;
        next = new Set;
      }
    }

    function computeNodeHeights({nodes}) {
      const n = nodes.length;
      let current = new Set(nodes);
      let next = new Set;
      let x = 0;
      while (current.size) {
        for (const node of current) {
          node.height = x;
          for (const {source} of node.targetLinks) {
            next.add(source);
          }
        }
        if (++x > n) throw new Error("circular link");
        current = next;
        next = new Set;
      }
    }

    function computeNodeLayers({nodes}) {
      const x = max(nodes, d => d.depth) + 1;
      const kx = (x1 - x0 - dx) / (x - 1);
      const columns = new Array(x);
      for (const node of nodes) {
        const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
        node.layer = i;
        node.x0 = x0 + i * kx;
        node.x1 = node.x0 + dx;
        if (columns[i]) columns[i].push(node);
        else columns[i] = [node];
      }
      if (sort) for (const column of columns) {
        column.sort(sort);
      }
      return columns;
    }

    function initializeNodeBreadths(columns) {
      const ky = min(columns, c => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
      for (const nodes of columns) {
        let y = y0;
        for (const node of nodes) {
          node.y0 = y;
          node.y1 = y + node.value * ky;
          y = node.y1 + py;
          for (const link of node.sourceLinks) {
            link.width = link.value * ky;
          }
        }
        y = (y1 - y + py) / (nodes.length + 1);
        for (let i = 0; i < nodes.length; ++i) {
          const node = nodes[i];
          node.y0 += y * (i + 1);
          node.y1 += y * (i + 1);
        }
        reorderLinks(nodes);
      }
    }

    function computeNodeBreadths(graph) {
      const columns = computeNodeLayers(graph);
      py = Math.min(dy, (y1 - y0) / (max(columns, c => c.length) - 1));
      initializeNodeBreadths(columns);
      for (let i = 0; i < iterations; ++i) {
        const alpha = Math.pow(0.99, i);
        const beta = Math.max(1 - alpha, (i + 1) / iterations);
        relaxRightToLeft(columns, alpha, beta);
        relaxLeftToRight(columns, alpha, beta);
      }
    }

    // Reposition each node based on its incoming (target) links.
    function relaxLeftToRight(columns, alpha, beta) {
      for (let i = 1, n = columns.length; i < n; ++i) {
        const column = columns[i];
        for (const target of column) {
          let y = 0;
          let w = 0;
          for (const {source, value} of target.targetLinks) {
            let v = value * (target.layer - source.layer);
            y += targetTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) continue;
          let dy = (y / w - target.y0) * alpha;
          target.y0 += dy;
          target.y1 += dy;
          reorderNodeLinks(target);
        }
        if (sort === undefined) column.sort(ascendingBreadth);
        resolveCollisions(column, beta);
      }
    }

    // Reposition each node based on its outgoing (source) links.
    function relaxRightToLeft(columns, alpha, beta) {
      for (let n = columns.length, i = n - 2; i >= 0; --i) {
        const column = columns[i];
        for (const source of column) {
          let y = 0;
          let w = 0;
          for (const {target, value} of source.sourceLinks) {
            let v = value * (target.layer - source.layer);
            y += sourceTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) continue;
          let dy = (y / w - source.y0) * alpha;
          source.y0 += dy;
          source.y1 += dy;
          reorderNodeLinks(source);
        }
        if (sort === undefined) column.sort(ascendingBreadth);
        resolveCollisions(column, beta);
      }
    }

    function resolveCollisions(nodes, alpha) {
      const i = nodes.length >> 1;
      const subject = nodes[i];
      resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
      resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
      resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
      resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
    }

    // Push any overlapping nodes down.
    function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
      for (; i < nodes.length; ++i) {
        const node = nodes[i];
        const dy = (y - node.y0) * alpha;
        if (dy > 1e-6) node.y0 += dy, node.y1 += dy;
        y = node.y1 + py;
      }
    }

    // Push any overlapping nodes up.
    function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
      for (; i >= 0; --i) {
        const node = nodes[i];
        const dy = (node.y1 - y) * alpha;
        if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;
        y = node.y0 - py;
      }
    }

    function reorderNodeLinks({sourceLinks, targetLinks}) {
      if (linkSort === undefined) {
        for (const {source: {sourceLinks}} of targetLinks) {
          sourceLinks.sort(ascendingTargetBreadth);
        }
        for (const {target: {targetLinks}} of sourceLinks) {
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }

    function reorderLinks(nodes) {
      if (linkSort === undefined) {
        for (const {sourceLinks, targetLinks} of nodes) {
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }

    // Returns the target.y0 that would produce an ideal link from source to target.
    function targetTop(source, target) {
      let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
      for (const {target: node, width} of source.sourceLinks) {
        if (node === target) break;
        y += width + py;
      }
      for (const {source: node, width} of target.targetLinks) {
        if (node === source) break;
        y -= width;
      }
      return y;
    }

    // Returns the source.y0 that would produce an ideal link from source to target.
    function sourceTop(source, target) {
      let y = target.y0 - (target.targetLinks.length - 1) * py / 2;
      for (const {source: node, width} of target.targetLinks) {
        if (node === source) break;
        y += width + py;
      }
      for (const {target: node, width} of source.sourceLinks) {
        if (node === target) break;
        y -= width;
      }
      return y;
    }

    return sankey;
  }

  var pi$7 = Math.PI,
      tau$8 = 2 * pi$7,
      epsilon$8 = 1e-6,
      tauEpsilon$2 = tau$8 - epsilon$8;

  function Path$3() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path$2() {
    return new Path$3;
  }

  Path$3.prototype = path$2.prototype = {
    constructor: Path$3,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon$8));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$8) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi$7 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon$8) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon$8 || Math.abs(this._y1 - y0) > epsilon$8) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau$8 + tau$8;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon$2) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon$8) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi$7)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  function constant$n(x) {
    return function constant() {
      return x;
    };
  }

  function x$4(p) {
    return p[0];
  }

  function y$4(p) {
    return p[1];
  }

  var slice$9 = Array.prototype.slice;

  function linkSource$1(d) {
    return d.source;
  }

  function linkTarget$1(d) {
    return d.target;
  }

  function link$3(curve) {
    var source = linkSource$1,
        target = linkTarget$1,
        x = x$4,
        y = y$4,
        context = null;

    function link() {
      var buffer, argv = slice$9.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
      if (!context) context = buffer = path$2();
      curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
      if (buffer) return context = null, buffer + "" || null;
    }

    link.source = function(_) {
      return arguments.length ? (source = _, link) : source;
    };

    link.target = function(_) {
      return arguments.length ? (target = _, link) : target;
    };

    link.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$n(+_), link) : x;
    };

    link.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$n(+_), link) : y;
    };

    link.context = function(_) {
      return arguments.length ? ((context = _ == null ? null : _), link) : context;
    };

    return link;
  }

  function curveHorizontal$1(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
  }

  function linkHorizontal$1() {
    return link$3(curveHorizontal$1);
  }

  function horizontalSource(d) {
    return [d.source.x1, d.y0];
  }

  function horizontalTarget(d) {
    return [d.target.x0, d.y1];
  }

  function sankeyLinkHorizontal() {
    return linkHorizontal$1()
        .source(horizontalSource)
        .target(horizontalTarget);
  }

  var d3Sankey = /*#__PURE__*/Object.freeze({
    __proto__: null,
    sankey: Sankey,
    sankeyCenter: center$2,
    sankeyLeft: left$1,
    sankeyRight: right$1,
    sankeyJustify: justify,
    sankeyLinkHorizontal: sankeyLinkHorizontal
  });

  function render$5(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      nodesWidth,
      nodesPadding,
      alignment,
      iterations,
      //labels
      showValues,
      // color scale
      colorScale
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // links are a deep copy of the dataset, to avoid modification of origina data variable

    const links = data.map(d => Object.assign({}, d)); //get nodes from links

    const nodes = Array.from(new Set(links.flatMap(l => [l.source, l.target])), id => ({
      id
    })); // convert option with alignment function names

    const alignments = {
      Left: 'sankeyLeft',
      Right: 'sankeyRight',
      Center: 'sankeyCenter',
      Justify: 'sankeyJustify'
    };
    const sankey = Sankey().nodeId(d => d.id).nodeAlign(d3Sankey[alignments[alignment]]).nodeWidth(nodesWidth).nodePadding(nodesPadding).extent([[0, 0], [chartWidth, chartHeight]]).iterations(iterations);
    const network = sankey({
      nodes,
      links
    }); // add background

    select(svgNode).append('rect').attr('width', width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');
    svg.append('g').selectAll('rect').data(network.nodes).join('rect').attr('x', d => d.x0).attr('y', d => d.y0).attr('height', d => d.y1 - d.y0).attr('width', d => d.x1 - d.x0).attr('fill', 'black').append('title').text(d => `${d.id}: ${d.value}`);
    const link = svg.append('g').attr('fill', 'none').attr('stroke-opacity', 0.5).selectAll('g').data(network.links).join('g').style('mix-blend-mode', 'multiply');
    link.append('path').attr('d', sankeyLinkHorizontal()).attr('stroke', d => colorScale(d.source.id)).attr('stroke-width', d => Math.max(1, d.width));
    link.append('title').text(d => `${d.source.name} → ${d.target.name}: ${d.value}`);
    const nodesLabels = svg.append('g').selectAll('text').data(network.nodes).join('text').attr('x', d => d.x0 < width / 2 ? d.x1 + 4 : d.x0 - 4).attr('y', d => d.y0 + (d.y1 - d.y0) / 2).attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end');
    nodesLabels.append('tspan').attr('alignment-baseline', 'middle').text(d => d.id).styles(styles.labelPrimary);

    if (showValues) {
      nodesLabels.append('tspan').attr('alignment-baseline', 'middle').attr('x', d => d.x0 < width / 2 ? d.x1 + 4 : d.x0 - 4).attr('dy', parseFloat(styles.labelPrimary.fontSize) + 2).text(d => d.value).styles(styles.labelSecondary);
      nodesLabels.attr('transform', `translate(0,${-parseFloat(styles.labelSecondary.fontSize) / 2})`);
    }
  }

  const visualOptions$5 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    nodesWidth: {
      type: 'number',
      label: 'Nodes width',
      default: 5,
      group: 'chart'
    },
    nodesPadding: {
      type: 'number',
      label: 'Padding',
      default: 5,
      group: 'chart'
    },
    alignment: {
      type: 'text',
      label: 'Nodes alignment',
      group: 'chart',
      options: ['Left', 'Right', 'Center', 'Justify'],
      default: 'Left'
    },
    iterations: {
      type: 'number',
      label: 'Iterations (attempts to solve overlaps)',
      default: 6,
      group: 'chart'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'source',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    showValues: {
      type: 'boolean',
      label: 'Show nodes values',
      default: false,
      group: 'Labels'
    }
  };

  var sankeydiagram = {
    metadata: metadata$5,
    dimensions: dimensions$5,
    mapData: mapData$5,
    render: render$5,
    visualOptions: visualOptions$5,
    styles: styles$1
  };

  var img$a = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M11%2c22V10a20.9062%2c20.9062%2c0%2c0%2c0%2c6.5132-.8467A28.83%2c28.83%2c0%2c0%2c1%2c26%2c8V20a17.3874%2c17.3874%2c0%2c0%2c0-5.3887.7461A32.6927%2c32.6927%2c0%2c0%2c1%2c11%2c22Z'/%3e %3cpath class='cls-1' d='M26%2c31c-3.7344%2c0-5.6812-1.5605-7.563-3.0693C16.5571%2c26.4238%2c14.7822%2c25%2c11%2c25V23a12.3663%2c12.3663%2c0%2c0%2c1%2c8.688%2c3.37C21.4482%2c27.7812%2c22.9683%2c29%2c26%2c29Z'/%3e %3cpath class='cls-1' d='M26%2c48a23.5%2c23.5%2c0%2c0%2c1-7.0669-.9668A26.3491%2c26.3491%2c0%2c0%2c0%2c11%2c46V45a27.1771%2c27.1771%2c0%2c0%2c1%2c8.1914%2c1.0674A22.6573%2c22.6573%2c0%2c0%2c0%2c26%2c47Z'/%3e %3cpath class='cls-1' d='M21.2993%2c35.2588C19.2412%2c31.1338%2c16.68%2c26%2c11%2c26v5c2.4126%2c0%2c3.81%2c2.4521%2c5.8252%2c6.4912C18.8149%2c41.48%2c21.07%2c46%2c26%2c46V41C24.291%2c41%2c23.0293%2c38.7266%2c21.2993%2c35.2588Z'/%3e %3cpath class='cls-1' d='M12.5836%2c37.842c.1-.0185.198-.0409.296-.0628a6.124%2c6.124%2c0%2c0%2c0%2c2.342-1.2278%2c20.3684%2c20.3684%2c0%2c0%2c0-1.9436-3.2A4.2569%2c4.2569%2c0%2c0%2c1%2c11%2c34v4a8.8714%2c8.8714%2c0%2c0%2c0%2c1.108-.0754C12.2734%2c37.9028%2c12.43%2c37.8738%2c12.5836%2c37.842Z'/%3e %3cpath class='cls-1' d='M12.5836%2c37.842c-.1534.0318-.31.0608-.4756.0826C12.2714%2c37.9042%2c12.4261%2c37.8712%2c12.5836%2c37.842Z'/%3e %3cpath class='cls-1' d='M20.2266%2c31.1521q.1554-.2645.3068-.5248c-.38-.2127-.7429-.4356-1.0826-.6712C19.7243%2c30.347%2c19.98%2c30.7478%2c20.2266%2c31.1521Z'/%3e %3cpath class='cls-1' d='M22.6331%2c27.217C23.6544%2c25.8058%2c24.6485%2c25%2c26%2c25V21c-3.049%2c0-5.0381%2c1.722-6.6038%2c3.8708.3185.2433.626.4855.9177.7194A14.7276%2c14.7276%2c0%2c0%2c0%2c22.6331%2c27.217Z'/%3e %3cpath class='cls-1' d='M15.6867%2c37.4536A7.0944%2c7.0944%2c0%2c0%2c1%2c11%2c39v5a11.9758%2c11.9758%2c0%2c0%2c0%2c7.0875-2.1011A43.2363%2c43.2363%2c0%2c0%2c1%2c15.93%2c37.9376C15.8469%2c37.77%2c15.7673%2c37.6132%2c15.6867%2c37.4536Z'/%3e %3cpath class='cls-1' d='M22.1942%2c34.8124c.488.9783.9567%2c1.8891%2c1.4092%2c2.6751A5.5643%2c5.5643%2c0%2c0%2c1%2c26%2c37V32a10.382%2c10.382%2c0%2c0%2c0-4.6966%2c1.0617C21.6182%2c33.6611%2c21.9141%2c34.2512%2c22.1942%2c34.8124Z'/%3e %3cpath class='cls-1' d='M45%2c21a32.2725%2c32.2725%2c0%2c0%2c1-9.4824-1.2363A17.7621%2c17.7621%2c0%2c0%2c0%2c30%2c19V8a28.3864%2c28.3864%2c0%2c0%2c1%2c8.3574%2c1.1367A21.5746%2c21.5746%2c0%2c0%2c0%2c45%2c10Z'/%3e %3cpath class='cls-1' d='M30%2c33V29c2.5938%2c0%2c3.8428-1.168%2c5.5713-2.7852C37.5791%2c24.3369%2c40.0771%2c22%2c45%2c22v4c-3.3438%2c0-4.8232%2c1.3838-6.6963%2c3.1357C36.3672%2c30.9473%2c34.1729%2c33%2c30%2c33Z'/%3e %3cpath class='cls-1' d='M32.9%2c27.1582a15.8624%2c15.8624%2c0%2c0%2c0%2c1.9886-1.6743c.5388-.5039%2c1.1334-1.0568%2c1.8121-1.5978C35.1165%2c21.7252%2c33.05%2c20%2c30%2c20v5C31.0908%2c25%2c31.9682%2c25.7776%2c32.9%2c27.1582Z'/%3e %3cpath class='cls-1' d='M39.8439%2c37.2858A8.31%2c8.31%2c0%2c0%2c0%2c45%2c39V34a3.5994%2c3.5994%2c0%2c0%2c1-2.3789-.918A18.517%2c18.517%2c0%2c0%2c0%2c39.8439%2c37.2858Z'/%3e %3cpath class='cls-1' d='M30%2c48V46a22.2335%2c22.2335%2c0%2c0%2c0%2c6.68-.916A27.6268%2c27.6268%2c0%2c0%2c1%2c45%2c44v2a25.8976%2c25.8976%2c0%2c0%2c0-7.8037%2c1.0166A24.2237%2c24.2237%2c0%2c0%2c1%2c30%2c48Z'/%3e %3cpath class='cls-1' d='M30%2c45V41c2.0371%2c0%2c3.3135-2.1133%2c5.1738-5.5928C37.1758%2c31.6621%2c39.668%2c27%2c45%2c27v4c-2.7373%2c0-4.2051%2c2.3779-6.2988%2c6.293C36.7705%2c40.9053%2c34.582%2c45%2c30%2c45Z'/%3e %3cpath class='cls-1' d='M37.8054%2c40.8811A11.9848%2c11.9848%2c0%2c0%2c0%2c45%2c43V40a9.0475%2c9.0475%2c0%2c0%2c1-5.6929-1.721C38.8468%2c39.1355%2c38.3541%2c40.0225%2c37.8054%2c40.8811Z'/%3e %3cpath class='cls-1' d='M34.2919%2c34.9358l.0362-.0675A10.4945%2c10.4945%2c0%2c0%2c0%2c30%2c34v3a7.7192%2c7.7192%2c0%2c0%2c1%2c2.842.4883C33.2766%2c36.7889%2c33.7477%2c35.9537%2c34.2919%2c34.9358Z'/%3e %3c/g%3e %3cg id='primary'%3e %3crect class='cls-2' x='8' y='10' width='2' height='21'/%3e %3crect class='cls-2' x='8' y='34' width='2' height='12'/%3e %3crect class='cls-2' x='46' y='10' width='2' height='21'/%3e %3crect class='cls-2' x='46' y='34' width='2' height='12'/%3e %3crect class='cls-2' x='27' y='8' width='2' height='17'/%3e %3crect class='cls-2' x='27' y='29' width='2' height='8'/%3e %3crect class='cls-2' x='27' y='41' width='2' height='7'/%3e %3c/g%3e%3c/svg%3e";

  var img$b = "data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-15%2c .cls-16%2c .cls-17 %7b isolation: isolate%3b %7d .cls-2 %7b fill: white%3b %7d .cls-3 %7b fill: %23666%3b %7d .cls-4 %7b mix-blend-mode: multiply%3b %7d .cls-10%2c .cls-11%2c .cls-12%2c .cls-13%2c .cls-14%2c .cls-5%2c .cls-6%2c .cls-7%2c .cls-8%2c .cls-9 %7b fill: none%3b stroke: %23ccc%3b %7d .cls-5 %7b stroke-width: 9.2219px%3b %7d .cls-6 %7b stroke-width: 5.6715px%3b %7d .cls-7 %7b stroke-width: 14.5706px%3b %7d .cls-8 %7b stroke-width: 10.9741px%3b %7d .cls-9 %7b stroke-width: 73.0374px%3b %7d .cls-10 %7b stroke-width: 25.0374px%3b %7d .cls-11 %7b stroke-width: 29.7406px%3b %7d .cls-12 %7b stroke-width: 15.4928px%3b %7d .cls-13 %7b stroke-width: 16.5533px%3b %7d .cls-14 %7b stroke-width: 76.7261px%3b %7d .cls-15%2c .cls-16 %7b font-size: 9.4872px%3b font-family: Helvetica%3b %7d .cls-16 %7b letter-spacing: -0.0547em%3b %7d .cls-17 %7b font-size: 10px%3b font-family: Helvetica-Bold%2c Helvetica%3b font-weight: 700%3b %7d %3c/style%3e %3c/defs%3e %3cg class='cls-1'%3e %3cg id='Layer_1' data-name='Layer 1'%3e %3crect class='cls-2' x='0.5' y='0.5' width='320' height='160'/%3e %3cg%3e %3crect class='cls-3' x='308' y='14.3718' width='10' height='46.2939'/%3e %3crect class='cls-3' x='308' y='65.4093' width='10' height='92.2189'/%3e %3c/g%3e %3cg%3e %3crect class='cls-3' x='155' y='14.3718' width='10' height='45.2334'/%3e %3crect class='cls-3' x='155' y='64.3488' width='10' height='93.2794'/%3e %3c/g%3e %3cg%3e %3crect class='cls-3' x='2' y='10' width='10' height='14.8934'/%3e %3crect class='cls-3' x='2' y='29.6369' width='10' height='25.5446'/%3e %3crect class='cls-3' x='2' y='59.9252' width='10' height='98.0748'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-5' d='M12%2c14.6109c71.5%2c0%2c71.5%2c4.3718%2c143%2c4.3718'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-6' d='M12%2c22.0576c71.5%2c0%2c71.5%2c45.1269%2c143%2c45.1269'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-7' d='M12%2c36.9222c71.5%2c0%2c71.5%2c40.3833%2c143%2c40.3833'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-8' d='M12%2c49.6946c71.5%2c0%2c71.5-20.6139%2c143-20.6139'/%3e %3c/g%3e %3cpath class='cls-9' d='M12%2c96.4439c71.5%2c0%2c71.5%2c24.6656%2c143%2c24.6656'/%3e %3cg class='cls-4'%3e %3cpath class='cls-10' d='M12%2c145.4813c71.5%2c0%2c71.5-98.3948%2c143-98.3948'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-11' d='M165%2c29.2421H308'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-12' d='M165%2c51.8588c71.5%2c0%2c71.5%2c21.2969%2c143%2c21.2969'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-13' d='M165%2c72.6254c71.5%2c0%2c71.5-20.2364%2c143-20.2364'/%3e %3c/g%3e %3cg class='cls-4'%3e %3cpath class='cls-14' d='M165%2c119.2651H308'/%3e %3c/g%3e %3cg%3e %3ctext class='cls-15' transform='translate(298.8916 40.8394) scale(1.0541 1)'%3eF%3c/text%3e %3ctext class='cls-15' transform='translate(297.2217 114.8389) scale(1.0541 1)'%3eG%3c/text%3e %3c/g%3e %3cg%3e %3ctext class='cls-15' transform='translate(168 40.3091) scale(1.0541 1)'%3eD%3c/text%3e %3ctext class='cls-15' transform='translate(168 114.3086) scale(1.0541 1)'%3eE%3c/text%3e %3c/g%3e %3cg%3e %3ctext class='cls-16' transform='translate(15 20.7671) scale(1.0541 1)'%3eA%3c/text%3e %3ctext class='cls-15' transform='translate(15 45.73) scale(1.0541 1)'%3eB%3c/text%3e %3ctext class='cls-15' transform='translate(15 112.2832) scale(1.0541 1)'%3eC%3c/text%3e %3c/g%3e %3ctext class='cls-17' transform='translate(3.9409 8)'%3e%ce%b1%3c/text%3e %3ctext class='cls-17' transform='translate(156.98 8)'%3e%ce%b2%3c/text%3e %3ctext class='cls-17' transform='translate(310.2192 8)'%3e%ce%b3%3c/text%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$6 = {
    name: 'Alluvial Diagram',
    id: 'rawgraphs.alluvialdiagram',
    thumbnail: img$b,
    icon: img$a,
    categories: ['correlations', 'proportions'],
    description: 'It shows correlations between categorical dimensions representing them as flows, visually linking categories with shared items. Each rectangle represents a unique value in the selected dimension, its height is proportional to its value. Correlations are represented with curved lines whose width is proportional to their value.'
  };

  const dimensions$6 = [{
    id: 'steps',
    name: 'Steps',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true,
    minValues: 2
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }];

  const mapData$6 = function (data, mapping, dataTypes, dimensions) {
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const results = []; // compute the rollup for each couple of steps
    // @TODO move this as grouping function

    mapping.steps.value.slice(0, -1).forEach((step1, index) => {
      //get the second step
      const step2 = mapping.steps.value[index + 1];
      rollups(data, v => {
        const item = {
          sourceName: v[0][step1],
          sourceStep: step1,
          source: step1 + ' - ' + v[0][step1],
          targetName: v[0][step2],
          targetStep: step2,
          target: step2 + ' - ' + v[0][step2],
          value: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length
        };
        results.push(item);
        return item;
      }, d => d[step1] + '_' + d[step2]);
    });
    return results;
  };

  function render$6(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard
      width,
      height,
      background,
      // margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      nodesWidth,
      nodesPadding,
      linksOpacity,
      sortNodesBy,
      verticalAlignment,
      linksBlendMode,
      // color
      colorScale,
      // Labels
      showValues
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // links are a deep copy of the dataset, to avoid modification of origina data variable

    const links = data.map(d => Object.assign({}, d)); //get unique nodes from links. @TODO: probably it could be improved

    let nodes = links.flatMap(l => [{
      id: l.source,
      name: l.sourceName,
      step: l.sourceStep
    }, {
      id: l.target,
      name: l.targetName,
      step: l.targetStep
    }]).reduce((map, obj) => {
      map.set(obj.id, obj);
      return map;
    }, new Map());
    nodes = Array.from(nodes).map(d => d[1]); // convert option with alignment function names
    const sankey = Sankey().nodeId(d => d.id).nodeWidth(nodesWidth).nodePadding(nodesPadding).extent([[0, 0], [chartWidth, chartHeight]]).iterations(0); // no iterations since we compute all the positions
    // compute the sankey network (calculate size, define x and y positions.)

    const network = sankey({
      nodes,
      links
    }); // sort nodes according to options

    switch (sortNodesBy) {
      case 'sizeDescending':
        network.nodes.sort((a, b) => descending(a.value, b.value));
        break;

      case 'sizeAscending':
        network.nodes.sort((a, b) => ascending(a.value, b.value));
        break;

      case 'name':
        network.nodes //first sort by type
        .sort((a, b) => ascending(typeof a.name, typeof b.name)) // then by actual value
        .sort((a, b) => ascending(a.name, b.name));
        break;
    }

    console.log(network.nodes.map(d => d.name)); // compute x positions of groups
    // get the first node for each category
    // we don't use the sankey.nodeSort() and sankey.linkSort()
    // d3 functions since it doens't allow to center vertically the nodes

    const xScale = band().rangeRound([0, chartWidth - nodesWidth]).domain(mapping.steps.value).align(0).paddingInner(1); // update nodes vertical position

    groups(network.nodes, d => d.step) // for each group, compute position
    .forEach(group => {
      // compute the starting point.
      let yPos0 = 0;
      const totalSize = sum(group[1], d => d.y1 - d.y0) + (group[1].length - 1) * nodesPadding; // if top, do nothing.
      // if bottom, sum the size of nodes and required padding.
      // if center, the hal of the previous

      switch (verticalAlignment) {
        case 'Bottom':
          yPos0 = chartHeight - totalSize;
          break;

        case 'Center':
          yPos0 = (chartHeight - totalSize) / 2;
          break;
      } // take the list of nodes in the group, and recompute positions


      group[1].reduce((ypos, node) => {
        const nodeSize = node.y1 - node.y0;
        node.y0 = ypos;
        node.y1 = ypos + nodeSize;
        node.x0 = xScale(node.step);
        node.x1 = node.x0 + nodesWidth;
        return ypos + nodeSize + nodesPadding;
      }, yPos0);
    }); // sort edges to avoid overlaps

    network.nodes.forEach(node => {
      node.sourceLinks.sort((a, b) => ascending(a.target.y0, b.target.y0));
      node.targetLinks.sort((a, b) => ascending(a.source.y0, b.source.y0));
    }); // updates link position

    sankey.update(network); // draw background

    select(svgNode).append('rect').attr('width', width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    svg.append('g').selectAll('rect').data(network.nodes).join('rect').attr('x', d => d.x0).attr('y', d => d.y0).attr('height', d => d.y1 - d.y0).attr('width', d => d.x1 - d.x0).attr('fill', 'black').append('title').text(d => `${d.name}: ${d.value}`);
    const link = svg.append('g').attr('fill', 'none').attr('stroke-opacity', linksOpacity).selectAll('g').data(network.links).join('g').style('mix-blend-mode', linksBlendMode);
    link.append('path').attr('d', sankeyLinkHorizontal()).attr('stroke', d => colorScale(d.source.id)).attr('stroke-width', d => Math.max(1, d.width));
    link.append('title').text(d => `${d.source.name} → ${d.target.name}: ${d.value}`);
    const nodesLabels = svg.append('g').selectAll('text').data(network.nodes).join('text').attr('x', d => d.x0 < width / 2 ? d.x1 + 4 : d.x0 - 4).attr('y', d => d.y0 + (d.y1 - d.y0) / 2).attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end');
    nodesLabels.append('tspan').attr('alignment-baseline', 'middle').attr('x', d => d.x0 < width / 2 ? d.x1 + 4 : d.x0 - 4).text(d => d.name).styles(styles.labelPrimary);

    if (showValues) {
      nodesLabels.append('tspan').attr('alignment-baseline', 'middle').attr('x', d => d.x0 < width / 2 ? d.x1 + 4 : d.x0 - 4).attr('dy', parseFloat(styles.labelPrimary.fontSize) + 2).text(d => d.value).styles(styles.labelSecondary);
      nodesLabels.attr('transform', `translate(0,${-parseFloat(styles.labelSecondary.fontSize) / 2})`);
    } // add steps titles


    const firstNodes = groups(network.nodes, d => d.step).map(d => d[1][0]);
    svg.append('g').selectAll('text').data(firstNodes).join('text').attr('x', d => d.x0 + nodesWidth / 2).attr('y', d => d.y0 - 4).attr('text-anchor', 'middle').text(d => d.step).styles(styles.axisLabel);
  }

  const visualOptions$6 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    nodesWidth: {
      type: 'number',
      label: 'Nodes width',
      default: 5,
      group: 'chart'
    },
    nodesPadding: {
      type: 'number',
      label: 'Padding',
      default: 5,
      group: 'chart'
    },
    linksOpacity: {
      type: 'number',
      label: 'Links opacity (0-1)',
      default: 1,
      step: 0.1,
      min: 0,
      max: 1,
      group: 'chart'
    },
    linksBlendMode: {
      type: 'text',
      label: 'Links blend mode',
      group: 'chart',
      options: ['normal', 'multiply'],
      default: 'multiply'
    },
    sortNodesBy: {
      type: 'text',
      label: 'Sort nodes by',
      group: 'chart',
      options: [{
        label: 'Size (descending)',
        value: 'sizeDescending'
      }, {
        label: 'Size (ascending)',
        value: 'sizeAscending'
      }, {
        label: 'Name',
        value: 'name'
      }, {
        label: 'Minimize Overlaps',
        value: 'auto'
      }],
      default: 'sizeAscending'
    },
    verticalAlignment: {
      type: 'text',
      label: 'Flows alignment',
      group: 'chart',
      options: ['Top', 'Center', 'Bottom'],
      default: 'Center'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'source',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    showValues: {
      type: 'boolean',
      label: 'Show nodes values',
      default: false,
      group: 'Labels'
    }
  };

  var alluvialdiagram = {
    metadata: metadata$6,
    dimensions: dimensions$6,
    mapData: mapData$6,
    render: render$6,
    visualOptions: visualOptions$6,
    styles: styles$1
  };

  var img$c = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3ccircle class='cls-1' cx='37.5' cy='18' r='2'/%3e %3ccircle class='cls-1' cx='27.5' cy='37.5' r='2'/%3e %3ccircle class='cls-1' cx='13' cy='40' r='1.5'/%3e %3ccircle class='cls-1' cx='22.5' cy='42.5' r='1.4142'/%3e %3ccircle class='cls-1' cx='41.5' cy='13.5' r='2'/%3e %3ccircle class='cls-1' cx='44.5' cy='18' r='1.4142'/%3e %3ccircle class='cls-1' cx='46.4999' cy='14.5' r='1'/%3e %3ccircle class='cls-1' cx='31.9999' cy='38.5' r='1'/%3e %3ccircle class='cls-1' cx='22.4999' cy='46.5' r='1'/%3e %3ccircle class='cls-1' cx='26.4999' cy='42' r='1'/%3e %3ccircle class='cls-1' cx='46.4999' cy='45.9483' r='1'/%3e %3ccircle class='cls-1' cx='17' cy='44.5' r='3'/%3e %3c/g%3e %3cg id='primary'%3e %3ccircle class='cls-2' cx='31' cy='15.5' r='3'/%3e %3ccircle class='cls-2' cx='33.5' cy='10' r='1'/%3e %3ccircle class='cls-2' cx='41.5' cy='45.5' r='2'/%3e %3ccircle class='cls-2' cx='33.5' cy='21.5' r='1.4142'/%3e %3ccircle class='cls-2' cx='17.5' cy='30' r='1.5'/%3e %3ccircle class='cls-2' cx='37.4999' cy='23' r='1'/%3e %3ccircle class='cls-2' cx='19.5' cy='36.5' r='4'/%3e %3ccircle class='cls-2' cx='41.5' cy='21' r='1.4142'/%3e %3ccircle class='cls-2' cx='36.5' cy='13' r='1'/%3e %3ccircle class='cls-2' cx='38.5' cy='9.5' r='1'/%3e %3ccircle class='cls-2' cx='26' cy='18.5' r='1'/%3e %3ccircle class='cls-2' cx='28.9999' cy='21' r='1'/%3e %3ccircle class='cls-2' cx='13.9999' cy='32' r='1'/%3e %3ccircle class='cls-2' cx='27.9999' cy='30.5' r='1'/%3e %3ccircle class='cls-2' cx='30.4999' cy='34' r='1'/%3e %3ccircle class='cls-2' cx='34.4999' cy='35.5' r='1'/%3e %3ccircle class='cls-2' cx='12.4999' cy='35' r='1'/%3e %3ccircle class='cls-2' cx='9.4999' cy='37.5' r='1'/%3e %3ccircle class='cls-2' cx='25.4999' cy='33' r='1'/%3e %3ccircle class='cls-2' cx='36.4999' cy='45.9483' r='1'/%3e %3ccircle class='cls-2' cx='25' cy='15' r='1'/%3e %3ccircle class='cls-2' cx='22' cy='17.5' r='1'/%3e %3ccircle class='cls-2' cx='23' cy='28' r='3'/%3e %3c/g%3e%3c/svg%3e";

  var img$d = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2%2c .cls-3 %7b fill: none%3b %7d .cls-2 %7b stroke: black%3b %7d .cls-3 %7b stroke: %23ccc%3b %7d .cls-4 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-5 %7b fill: %23d5ee9f%3b %7d .cls-6 %7b fill: %234696b3%3b %7d .cls-7 %7b fill: %239e0142%3b %7d .cls-8 %7b fill: %23fed281%3b %7d .cls-9 %7b fill: %2389cfa5%3b %7d .cls-10 %7b fill: %23db494a%3b %7d .cls-11 %7b fill: %235e4fa2%3b %7d .cls-12 %7b fill: %23f88e53%3b %7d .cls-13 %7b fill: %23fbf8b0%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='visualization'%3e %3cg id='axis'%3e %3cg id='y_axis' data-name='y axis'%3e %3cpath class='cls-2' d='M10.5%2c10.5v131'/%3e %3cline class='cls-3' x1='10' y1='75.5' x2='293' y2='75.5'/%3e %3c/g%3e %3cg id='y_axis-2' data-name='y axis'%3e %3cpath class='cls-2' d='M10.5%2c141.5h283'/%3e %3cg%3e %3cline class='cls-2' x1='10.5' y1='141' x2='10.5' y2='147'/%3e %3ctext class='cls-4' transform='translate(-0.623 157.1)'%3e1930%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='41.9406' y1='141' x2='41.9406' y2='147'/%3e %3ctext class='cls-4' transform='translate(30.8176 157.1)'%3e1940%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='73.3898' y1='141' x2='73.3898' y2='147'/%3e %3ctext class='cls-4' transform='translate(62.2668 157.1)'%3e1950%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='104.8305' y1='141' x2='104.8305' y2='147'/%3e %3ctext class='cls-4' transform='translate(93.7074 157.1)'%3e1960%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='136.2797' y1='141' x2='136.2797' y2='147'/%3e %3ctext class='cls-4' transform='translate(125.1566 157.1)'%3e1970%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='167.7203' y1='141' x2='167.7203' y2='147'/%3e %3ctext class='cls-4' transform='translate(156.5973 157.1)'%3e1980%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='199.1695' y1='141' x2='199.1695' y2='147'/%3e %3ctext class='cls-4' transform='translate(188.0465 157.1)'%3e1990%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='230.6102' y1='141' x2='230.6102' y2='147'/%3e %3ctext class='cls-4' transform='translate(219.4871 157.1)'%3e2000%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='262.0594' y1='141' x2='262.0594' y2='147'/%3e %3ctext class='cls-4' transform='translate(250.9363 157.1)'%3e2010%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='293.5' y1='141' x2='293.5' y2='147'/%3e %3ctext class='cls-4' transform='translate(282.377 157.1)'%3e2020%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='viz'%3e %3ccircle class='cls-5' cx='42.2916' cy='76.0171' r='20'/%3e %3ccircle class='cls-6' cx='255.9086' cy='66.0735' r='17.3635'/%3e %3ccircle class='cls-5' cx='218.6223' cy='73.6218' r='16.6801'/%3e %3ccircle class='cls-7' cx='159.5505' cy='72.4357' r='14.5643'/%3e %3ccircle class='cls-6' cx='304.9922' cy='76.8797' r='14.2014'/%3e %3ccircle class='cls-8' cx='117.7509' cy='68.2744' r='10.7828'/%3e %3ccircle class='cls-9' cx='186.8852' cy='80.6577' r='9.9814'/%3e %3ccircle class='cls-10' cx='85.281' cy='70.8409' r='9.1628'/%3e %3ccircle class='cls-5' cx='117.2841' cy='91.7992' r='8.7467'/%3e %3ccircle class='cls-11' cx='243.3986' cy='101.7473' r='8.7467'/%3e %3ccircle class='cls-12' cx='9.7796' cy='74.7469' r='8.5368'/%3e %3ccircle class='cls-7' cx='193.3878' cy='59.3197' r='8.3258'/%3e %3ccircle class='cls-10' cx='138.1248' cy='88.6834' r='8.3258'/%3e %3ccircle class='cls-7' cx='278.1806' cy='47.3301' r='7.4691'/%3e %3ccircle class='cls-6' cx='137.5524' cy='60.2391' r='6.5912'/%3e %3ccircle class='cls-12' cx='101.4878' cy='81.4409' r='6.1439'/%3e %3ccircle class='cls-12' cx='201.6382' cy='94.6733' r='6.3683'/%3e %3ccircle class='cls-7' cx='281.1236' cy='75.8669' r='5.6905'/%3e %3ccircle class='cls-12' cx='150.1707' cy='50.3159' r='5.4616'/%3e %3ccircle class='cls-7' cx='259.1883' cy='92.6951' r='5.4616'/%3e %3ccircle class='cls-10' cx='87.9873' cy='89.2682' r='5.4616'/%3e %3ccircle class='cls-5' cx='291.813' cy='56.2823' r='4.7652'/%3e %3ccircle class='cls-10' cx='271.7587' cy='86.5523' r='4.5297'/%3e %3ccircle class='cls-7' cx='172.1142' cy='91.8134' r='4.5297'/%3e %3ccircle class='cls-7' cx='215.9835' cy='98.6933' r='4.5297'/%3e %3ccircle class='cls-12' cx='292.5688' cy='96.2223' r='4.5297'/%3e %3ccircle class='cls-5' cx='280.8091' cy='62.3755' r='3.813'/%3e %3ccircle class='cls-10' cx='239.2588' cy='47.5134' r='3.5704'/%3e %3ccircle class='cls-12' cx='70.4205' cy='77.9837' r='3.326'/%3e %3ccircle class='cls-10' cx='268.693' cy='100.8809' r='3.0797'/%3e %3ccircle class='cls-7' cx='134.7873' cy='73.6438' r='3.0797'/%3e %3ccircle class='cls-12' cx='68.1062' cy='67.8386' r='3.0797'/%3e %3ccircle class='cls-7' cx='234.0771' cy='56.243' r='2.5811'/%3e %3ccircle class='cls-7' cx='286.7199' cy='86.7768' r='2.5811'/%3e %3ccircle class='cls-7' cx='100.6623' cy='68.9963' r='2.3288'/%3e %3ccircle class='cls-11' cx='172.2784' cy='55.8678' r='2.3288'/%3e %3ccircle class='cls-5' cx='206.832' cy='54.1606' r='2.0743'/%3e %3ccircle class='cls-10' cx='232.7108' cy='91.4813' r='2.0743'/%3e %3ccircle class='cls-7' cx='225.646' cy='94.9954' r='1.8177'/%3e %3ccircle class='cls-12' cx='276.2464' cy='95.9923' r='1.9206'/%3e %3ccircle class='cls-12' cx='302.8993' cy='96.7888' r='1.8177'/%3e %3ccircle class='cls-12' cx='245.4185' cy='86.4539' r='1.5588'/%3e %3ccircle class='cls-10' cx='239.2818' cy='81.8512' r='1.5588'/%3e %3ccircle class='cls-12' cx='239.1319' cy='88.4425' r='1.0342'/%3e %3ccircle class='cls-7' cx='299.5432' cy='102.7626' r='1.0342'/%3e %3ccircle class='cls-7' cx='280.2787' cy='90.5216' r='0.875'/%3e %3ccircle class='cls-7' cx='162.8217' cy='91.4895' r='0.7684'/%3e %3ccircle class='cls-7' cx='287.7314' cy='67.6255' r='0.875'/%3e %3ccircle class='cls-7' cx='283.3192' cy='95.2758' r='0.7683'/%3e %3ccircle class='cls-13' cx='150.9283' cy='89.4385' r='0.5'/%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$7 = {
    name: 'Beeswarm plot',
    id: 'rawgraphs.beeswarm',
    thumbnail: img$d,
    icon: img$c,
    categories: ['distributions', 'Series temporelles', 'proportions'],
    description: 'It displays the distribution of items over a continuous dimensions. Each (line) is represented with a dot placed on the horizontal axis. The vertical dimension is used to avoid overlaps among circles, showing their distribution. The area of dots can be used to encode a further quantitative dimension and a quantitative or categorical dimension with color.'
  };

  const dimensions$7 = [{
    id: 'xValue',
    name: 'Axe X',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: false
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true
  }, {
    id: 'series',
    name: 'Groups',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$7 = function (data, mapping, dataTypes, dimensions) {
    // add the non-compulsory dimensions.
    'series' in mapping ? null : mapping.series = {
      value: undefined
    };
    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    return data.map(d => ({
      xValue: d[mapping.xValue.value],
      series: d[mapping.series.value],
      color: d[mapping.color.value],
      size: mapping.size.value ? d[mapping.size.value] : 1,
      label: mapping.label.value ? mapping.label.value.map(l => d[l]) : null
    }));
  };

  function render$7(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      // margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legends
      showLegend,
      legendWidth,
      // chart options
      minDiameter,
      maxDiameter,
      simulationStrength,
      nodePadding,
      sortSeriesBy,
      // colors
      colorScale,
      showLabelsOutline,
      autoHideLabels,
      //TODO add labels legends
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; // create nest structure

    const grouped = groups(data, d => d.series); // reduce them for sorting

    const reduced = grouped.reduce((map, d) => {
      map[d[0]] = sum(d[1], e => e.size);
      return map;
    }, {}); // define chart dimension

    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // sort series

    switch (sortSeriesBy) {
      case 'Total value (descending)':
        grouped.sort((a, b) => descending(reduced[a[0]], reduced[b[0]]));
        break;

      case 'Total value (ascending)':
        grouped.sort((a, b) => ascending(reduced[a[0]], reduced[b[0]]));
        break;

      case 'Name':
        grouped.sort((a, b) => ascending(a[0], b[0]));
    }

    mapping.xValue.dataType === 'number' ? mapping.xValue.dataType = {
      type: 'number'
    } : null; // @TODO it should be better to have always the same kind of object in mapping

    let xScale;
    const xDomain = extent(data, d => d.xValue);

    switch (mapping.xValue.dataType.type) {
      case 'number':
        xScale = linear$2().domain(xDomain).nice().range([0, chartWidth]);
        break;

      case 'date':
        xScale = time().domain(xDomain).nice().range([0, chartWidth]);
        break;
    } // create scale for sizes


    const sizeScale = sqrt$1().domain(extent(data, d => d.size)).range([minDiameter / 2, maxDiameter / 2]); // create y scale

    const yScale = band().rangeRound([0, chartHeight]).domain(grouped.map(d => d[0])).align(0.5).padding(0); // prepare data with initial vales, so the simulation won't start from 0,0

    data.forEach(d => {
      d.x = xScale(d.xValue);
      d.y = yScale(d.series) + yScale.bandwidth() / 2;
    }); // initialise simulation

    let simulation$1 = simulation(data).force('x', x$2().x(d => xScale(d.xValue))).force('y', y$2(d => yScale(d.series) + yScale.bandwidth() / 2)).force('collision', collide().radius(d => sizeScale(d.size) + nodePadding)); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // get svg node

    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(xScale)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['xValue'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(yScale).tickSize(Math.round(-chartWidth)).tickSizeOuter(0)).call(g => g.selectAll('line').styles(styles.axisLine)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['series'].value).styles(styles.axisLabel));
    }; // draw the scale and axes


    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis); // // draw y axis
    // axisLayer
    //   .append('g')
    //   .attr('id', 'y axis')
    //   .call(
    //     d3.axisLeft(yScale).tickSize(Math.round(-chartWidth)).tickSizeOuter(0)
    //   )
    // // draw x axis
    // axisLayer
    //   .append('g')
    //   .attr('id', 'y axis')
    //   .attr('transform', `translate(0,${chartHeight})`)
    //   .call(d3.axisBottom(xScale).tickSizeOuter(0))
    // draw the viz

    const vizLayer = svg.append('g').selectAll('g').data(grouped).join('g').attr('id', d => d[0]); // let the simulation run in background
    // @TODO move this to a web worker
    //console.log("---------------new simulation---------------")

    for (var i = 0, n = Math.ceil(Math.log(simulation$1.alphaMin()) / Math.log(1 - simulation$1.alphaDecay())); i < n; ++i) {
      //console.log(i+"/"+n+"("+ (i/n*100) + ")")
      simulation$1.tick();
    } //console.log("---------------end of simulation---------------")
    //add all the circles


    vizLayer.append('g').attr('id', 'cicles').selectAll('circle').data(d => d[1]).join('circle').attr('cx', d => d.x).attr('cy', d => d.y).attr('r', d => sizeScale(d.size)).style('fill', d => colorScale(d.color));
    const labelsLayer = vizLayer.append('g').attr('class', 'labels');
    labelsLayer.selectAll('g').data(d => mapping.label.value ? d[1] : []).join('g').attr('transform', d => `translate(${d.x},${d.y})`).append('text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => Array.isArray(d.label) ? d.label : [d.label]).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * 12).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats$1[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(labelsLayer.selectAll('text'), d => d.size);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      chartLegend.addSize(mapping.size.value ? mapping.size.value : 'Number of records', sizeScale, 'circle');
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$7 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    minDiameter: {
      type: 'number',
      label: 'Min diameter',
      default: 1,
      group: 'chart'
    },
    maxDiameter: {
      type: 'number',
      label: 'Diamètre maximum',
      default: 20,
      group: 'chart'
    },
    nodePadding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Sort groups by',
      group: 'series',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Original'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels'
    }
  }; // showLegend,
  // legendWidth,

  var beeswarm = {
    metadata: metadata$7,
    dimensions: dimensions$7,
    mapData: mapData$7,
    render: render$7,
    visualOptions: visualOptions$7,
    styles: styles$1
  };

  var img$e = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3crect class='cls-1' x='8' y='30' width='19' height='18'/%3e %3crect class='cls-1' x='35' y='8' width='13' height='4'/%3e %3crect class='cls-1' x='35' y='13' width='13' height='9'/%3e %3crect class='cls-1' x='42' y='42' width='6' height='6'/%3e %3crect class='cls-1' x='29' y='42' width='12' height='6'/%3e %3c/g%3e %3cg id='primary'%3e %3crect class='cls-2' x='8' y='8' width='19' height='21'/%3e %3crect class='cls-2' x='29' y='8' width='5' height='14'/%3e %3crect class='cls-2' x='29' y='24' width='19' height='17'/%3e %3c/g%3e%3c/svg%3e";

  var img$f = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: none%3b %7d .cls-2 %7b fill: white%3b %7d .cls-3 %7b fill: %23a0d9a3%3b %7d .cls-4 %7b clip-path: url(%23clip-path)%3b %7d .cls-5%2c .cls-6%2c .cls-9 %7b isolation: isolate%3b %7d .cls-6%2c .cls-9 %7b font-size: 12px%3b font-family: Helvetica%3b %7d .cls-7 %7b fill: %234ba0b1%3b %7d .cls-8 %7b clip-path: url(%23clip-path-2)%3b %7d .cls-9 %7b letter-spacing: -0.0366em%3b %7d .cls-10 %7b fill: %235e4fa2%3b %7d .cls-11 %7b clip-path: url(%23clip-path-3)%3b %7d .cls-12 %7b clip-path: url(%23clip-path-4)%3b %7d .cls-13 %7b clip-path: url(%23clip-path-5)%3b %7d .cls-14 %7b clip-path: url(%23clip-path-6)%3b %7d .cls-15 %7b fill: %239e0142%3b %7d .cls-16 %7b clip-path: url(%23clip-path-7)%3b %7d .cls-17 %7b clip-path: url(%23clip-path-8)%3b %7d .cls-18 %7b fill: %23e1524a%3b %7d .cls-19 %7b clip-path: url(%23clip-path-9)%3b %7d .cls-20 %7b fill: %23fba35e%3b %7d .cls-21 %7b clip-path: url(%23clip-path-10)%3b %7d .cls-22 %7b clip-path: url(%23clip-path-11)%3b %7d .cls-23 %7b clip-path: url(%23clip-path-12)%3b %7d .cls-24 %7b fill: %23fee89a%3b %7d .cls-25 %7b clip-path: url(%23clip-path-13)%3b %7d .cls-26 %7b clip-path: url(%23clip-path-14)%3b %7d .cls-27 %7b fill: %23ebf7a6%3b %7d .cls-28 %7b clip-path: url(%23clip-path-15)%3b %7d .cls-29 %7b clip-path: url(%23clip-path-16)%3b %7d .cls-30 %7b clip-path: url(%23clip-path-17)%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' x='5' y='5' width='38' height='74'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-2'%3e %3crect class='cls-1' x='44' y='5' width='52' height='74'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-3'%3e %3crect class='cls-1' x='5' y='80' width='91' height='31'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-4'%3e %3crect class='cls-1' x='5' y='114' width='20' height='41'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-5'%3e %3crect class='cls-1' x='28' y='114' width='44' height='41'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-6'%3e %3crect class='cls-1' x='75' y='114' width='21' height='41'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-7'%3e %3crect class='cls-1' x='101' y='5' width='6' height='110'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-8'%3e %3crect class='cls-1' x='110' y='5' width='89' height='21'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-9'%3e %3crect class='cls-1' x='110' y='27' width='89' height='88'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-10'%3e %3crect class='cls-1' x='200' y='5' width='26' height='110'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-11'%3e %3crect class='cls-1' x='101' y='118' width='74' height='37'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-12'%3e %3crect class='cls-1' x='178' y='118' width='48' height='37'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-13'%3e %3crect class='cls-1' x='231' y='5' width='84' height='32'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-14'%3e %3crect class='cls-1' x='231' y='40' width='35' height='80'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-15'%3e %3crect class='cls-1' x='267' y='40' width='48' height='80'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-16'%3e %3crect class='cls-1' x='231' y='123' width='26' height='32'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-17'%3e %3crect class='cls-1' x='260' y='123' width='55' height='32'/%3e %3c/clipPath%3e %3c/defs%3e %3crect id='backgorund' class='cls-2' width='320' height='160'/%3e %3crect id='backgorund-2' data-name='backgorund' class='cls-2' width='320' height='160'/%3e %3cg id='viz'%3e %3cg id='leaves'%3e %3cg%3e %3crect id='path0' class='cls-3' x='5' y='5' width='38' height='74'/%3e %3cg class='cls-4'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(8 17)'%3eI%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path1' class='cls-7' x='44' y='5' width='52' height='74'/%3e %3cg class='cls-8'%3e %3cg class='cls-5'%3e %3ctext class='cls-9' transform='translate(47 17)'%3eL%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path2' class='cls-10' x='5' y='80' width='91' height='31'/%3e %3cg class='cls-11'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(8 92)'%3eM%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path3' class='cls-7' x='5' y='114' width='20' height='41'/%3e %3cg class='cls-12'%3e %3cg class='cls-5'%3e %3ctext class='cls-9' transform='translate(8 126)'%3eL%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path4' class='cls-10' x='28' y='114' width='44' height='41'/%3e %3cg class='cls-13'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(31 126)'%3eM%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path5' class='cls-10' x='75' y='114' width='21' height='41'/%3e %3cg class='cls-14'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(78 126)'%3eM%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path6' class='cls-15' x='101' y='5' width='6' height='110'/%3e %3cg class='cls-16'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(104 17)'%3eD%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path7' class='cls-15' x='110' y='5' width='89' height='21'/%3e %3cg class='cls-17'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(113 17)'%3eD%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path8' class='cls-18' x='110' y='27' width='89' height='88'/%3e %3cg class='cls-19'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(113 39)'%3eE%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path9' class='cls-20' x='200' y='5' width='26' height='110'/%3e %3cg class='cls-21'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(203 17)'%3eF%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path10' class='cls-18' x='101' y='118' width='74' height='37'/%3e %3cg class='cls-22'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(104 130)'%3eE%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path11' class='cls-20' x='178' y='118' width='48' height='37'/%3e %3cg class='cls-23'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(181 130)'%3eF%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path12' class='cls-24' x='231' y='5' width='84' height='32'/%3e %3cg class='cls-25'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(234 17)'%3eG%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path13' class='cls-24' x='231' y='40' width='35' height='80'/%3e %3cg class='cls-26'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(234 52)'%3eG%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path14' class='cls-27' x='267' y='40' width='48' height='80'/%3e %3cg class='cls-28'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(270 52)'%3eH%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path15' class='cls-27' x='231' y='123' width='26' height='32'/%3e %3cg class='cls-29'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(234 135)'%3eH%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3crect id='path16' class='cls-27' x='260' y='123' width='55' height='32'/%3e %3cg class='cls-30'%3e %3cg class='cls-5'%3e %3ctext class='cls-6' transform='translate(263 135)'%3eH%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$8 = {
    name: 'Treemap',
    id: 'rawgraphs.treemap',
    thumbnail: img$f,
    icon: img$e,
    categories: ['hierarchies', 'proportions'],
    description: 'It displays hierarchically structured data and a related quantitative dimension. It is composed of an area divided into small rectangles, representing the last level of the tree structure. The rectangles’ size depends on the quantitative dimension.',
    code: 'https://observablehq.com/@d3/treemap' // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$8 = [{
    id: 'hierarchy',
    name: 'Hiérarchie',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: 'csvDistinct'
  }];

  const mapData$8 = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    const results = [];
    rollups(data, v => {
      const item = {
        hierarchy: new Map(mapping.hierarchy.value.map(d => [d, v[0][d]])),
        //get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'cells color',
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
      results.push(item);
      return item;
    }, ...mapping.hierarchy.value.map(level => d => d[level]) // create a grouping for each level of the hierarchy
    );
    return results;
  };

  function render$8(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard
      width,
      height,
      background,
      // margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legend
      showLegend,
      legendWidth,
      // colors
      colorScale,
      // chart options
      tiling,
      padding,
      // labels
      showLabelsOutline,
      showHierarchyLabels,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // create the hierarchical structure

    const nest = rollup(data, v => v[0], ...mapping.hierarchy.value.map(level => d => d.hierarchy.get(level)));
    const hierarchy$1 = hierarchy(nest).sum(d => d[1] instanceof Map ? 0 : d[1].size); // since maps have a .size porperty in native javascript, sum only values for leaves, and not for Maps
    //@TODO: understand how to handle empty values

    const treemap = index$4().tile(d3[tiling]).size([chartWidth, chartHeight]).padding(padding).round(true);

    if (showHierarchyLabels) {
      treemap.paddingTop(12);
    }

    const root = treemap(hierarchy$1); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz'); // if selected, draw a rectangle for each level in the hierarchy

    if (showHierarchyLabels) {
      const ancestorData = root.descendants().filter(d => d.children);
      const depthScale = linear$2().domain([0, root.leaves()[0].depth + 1]);
      const ancestors = svg.append('g').attr('id', 'ancestors').selectAll('rect').data(ancestorData).join('g').attr('transform', d => `translate(${d.x0},${d.y0})`);
      ancestors.append('rect').attr('width', d => d.x1 - d.x0).attr('height', d => d.y1 - d.y0).attr('id', (d, i) => 'path_ancestor' + i).attr('fill', '#ccc').attr('fill-opacity', d => depthScale(d.depth)).attr('stroke', '#ccc').attr('stroke-opacity', d => depthScale(d.depth) + 0.1);

      if (showHierarchyLabels) {
        ancestors.append('clipPath').attr('id', (d, i) => 'clip_ancestor' + i).append('use').attr('xlink:href', (d, i) => '#path_ancestor' + i);
        ancestors.append('text').attr('x', padding).attr('y', 2).attr('clip-path', (d, i) => 'url(#clip_ancestor' + i + ')').attr('font-family', 'Arial, sans-serif').attr('font-size', 8).attr('dominant-baseline', 'text-before-edge').attr('class', 'txt').text(d => {
          return d.depth === 0 && !d.data[0] ? 'Root' : d.data[0];
        });
      }
    }

    const leaves = svg.append('g').attr('id', 'leaves').selectAll('g').data(root.leaves()).join('g').attr('transform', d => `translate(${d.x0},${d.y0})`);
    leaves.append('rect').attr('id', (d, i) => 'path' + i).attr('fill', d => colorScale(d.data[1].color)).attr('width', d => d.x1 - d.x0).attr('height', d => d.y1 - d.y0);
    leaves.append('clipPath').attr('id', (d, i) => 'clip' + i).append('use').attr('xlink:href', (d, i) => '#path' + i);
    const texts = leaves.append('text').attr('clip-path', (d, i) => 'url(#clip' + i + ')').attr('font-family', 'Arial, sans-serif').attr('font-size', 10).attr('dominant-baseline', 'text-before-edge').attr('class', 'txt');
    texts.selectAll('tspan').data((d, i, a) => {
      return Array.isArray(d.data[1].label) ? d.data[1].label : [d.data[1].label];
    }).join('tspan').attr('x', 3).attr('y', (d, i) => i * 1.1 + 0.2 + 'em').text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      selectAll('.txt').styles(styles.labelOutline);
    }

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$8 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    tiling: {
      type: 'text',
      label: 'Tiling method',
      group: 'chart',
      options: [{
        label: 'Binary',
        value: 'treemapBinary'
      }, {
        label: 'Dice',
        value: 'treemapDice'
      }, {
        label: 'Slice',
        value: 'treemapSlice'
      }, {
        label: 'Slice and dice',
        value: 'treemapSliceDice'
      }, {
        label: 'Squarify',
        value: 'treemapSquarify'
      }],
      default: 'treemapSquarify'
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 2,
      group: 'chart'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    showHierarchyLabels: {
      type: 'boolean',
      label: 'Show hierarchy labels',
      default: false,
      group: 'labels'
    }
  };

  var treemap$1 = {
    metadata: metadata$8,
    dimensions: dimensions$8,
    mapData: mapData$8,
    render: render$8,
    visualOptions: visualOptions$8,
    styles: styles$1
  };

  var img$g = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M20.5%2c34.5A8.5%2c8.5%2c0%2c1%2c1%2c29%2c26%2c8.51%2c8.51%2c0%2c0%2c1%2c20.5%2c34.5Zm0-16A7.5%2c7.5%2c0%2c1%2c0%2c28%2c26%2c7.5083%2c7.5083%2c0%2c0%2c0%2c20.5%2c18.5Z'/%3e %3cpath class='cls-1' d='M34.5%2c30A4.5%2c4.5%2c0%2c1%2c1%2c39%2c25.5%2c4.505%2c4.505%2c0%2c0%2c1%2c34.5%2c30Zm0-8A3.5%2c3.5%2c0%2c1%2c0%2c38%2c25.5%2c3.5042%2c3.5042%2c0%2c0%2c0%2c34.5%2c22Z'/%3e %3cpath class='cls-1' d='M31.5%2c46A7.5%2c7.5%2c0%2c1%2c1%2c39%2c38.5%2c7.5083%2c7.5083%2c0%2c0%2c1%2c31.5%2c46Zm0-14A6.5%2c6.5%2c0%2c1%2c0%2c38%2c38.5%2c6.5075%2c6.5075%2c0%2c0%2c0%2c31.5%2c32Z'/%3e %3cpath class='cls-1' d='M31.5%2c21A4.5%2c4.5%2c0%2c1%2c1%2c36%2c16.5%2c4.505%2c4.505%2c0%2c0%2c1%2c31.5%2c21Zm0-8A3.5%2c3.5%2c0%2c1%2c0%2c35%2c16.5%2c3.5042%2c3.5042%2c0%2c0%2c0%2c31.5%2c13Z'/%3e %3cpath class='cls-1' d='M22.5%2c17A3.5%2c3.5%2c0%2c1%2c1%2c26%2c13.5%2c3.5042%2c3.5042%2c0%2c0%2c1%2c22.5%2c17Zm0-6A2.5%2c2.5%2c0%2c1%2c0%2c25%2c13.5%2c2.5026%2c2.5026%2c0%2c0%2c0%2c22.5%2c11Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M28.0933%2c47.9844a20.5%2c20.5%2c0%2c1%2c1%2c20.5-20.5A20.5233%2c20.5233%2c0%2c0%2c1%2c28.0933%2c47.9844Zm0-40a19.5%2c19.5%2c0%2c1%2c0%2c19.5%2c19.5A19.5222%2c19.5222%2c0%2c0%2c0%2c28.0933%2c7.9844Z'/%3e %3ccircle class='cls-2' cx='17.5' cy='25.5' r='3.5'/%3e %3ccircle class='cls-2' cx='24.5' cy='25.5' r='2.5'/%3e %3ccircle class='cls-2' cx='32.5' cy='25.5' r='0.5'/%3e %3ccircle class='cls-2' cx='35.5' cy='25.5' r='1.5'/%3e %3ccircle class='cls-2' cx='28' cy='38' r='2'/%3e %3ccircle class='cls-2' cx='34' cy='38' r='3'/%3e %3ccircle class='cls-2' cx='31.5' cy='16.5' r='2.5'/%3e %3ccircle class='cls-2' cx='22.5' cy='13.5' r='1.5'/%3e %3c/g%3e%3c/svg%3e";

  var img$h = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-4 %7b fill: none%3b %7d .cls-2 %7b fill: white%3b %7d .cls-3 %7b clip-path: url(%23clip-path)%3b %7d .cls-4 %7b stroke: %23ccc%3b %7d .cls-5 %7b fill: %23e1524a%3b %7d .cls-6 %7b fill: %23fba35e%3b %7d .cls-7 %7b fill: %239e0142%3b %7d .cls-8 %7b fill: %234ba0b1%3b %7d .cls-9 %7b fill: %23a0d9a3%3b %7d .cls-10 %7b fill: %235e4fa2%3b %7d .cls-11 %7b fill: %23ebf7a6%3b %7d .cls-12 %7b fill: %23fee89a%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' width='320' height='160'/%3e %3c/clipPath%3e %3c/defs%3e %3crect id='backgorund' class='cls-2' width='320' height='160'/%3e %3cg class='cls-3'%3e %3cg id='viz'%3e %3cg id='nodes'%3e %3ccircle class='cls-4' cx='160' cy='80' r='98'/%3e %3cg id='B'%3e %3ccircle class='cls-4' cx='119.8768' cy='53.5941' r='48.3404'/%3e %3c/g%3e %3cg id='A'%3e %3ccircle class='cls-4' cx='209.8263' cy='53.5941' r='39.9823'/%3e %3c/g%3e %3cg id='C'%3e %3ccircle class='cls-4' cx='173.1827' cy='130.8209' r='43.8703'/%3e %3c/g%3e %3cg id='E'%3e %3ccircle class='cls-4' cx='99.9155' cy='51.8186' r='26.6734'/%3e %3c/g%3e %3cg id='F'%3e %3ccircle class='cls-4' cx='147.3744' cy='51.8186' r='19.1587'/%3e %3c/g%3e %3cg id='D'%3e %3ccircle class='cls-4' cx='129.9488' cy='83.3822' r='15.2688'/%3e %3c/g%3e %3cg id='L'%3e %3ccircle class='cls-4' cx='197.544' cy='37.8428' r='18.3815'/%3e %3c/g%3e %3cg id='I'%3e %3ccircle class='cls-4' cx='228.3828' cy='37.8428' r='10.8305'/%3e %3c/g%3e %3cg id='M'%3e %3ccircle class='cls-4' cx='221.6296' cy='68.731' r='19.1605'/%3e %3c/g%3e %3cg id='H'%3e %3ccircle class='cls-4' cx='151.5217' cy='130.8209' r='20.5825'/%3e %3c/g%3e %3cg id='G'%3e %3ccircle class='cls-4' cx='194.5786' cy='130.8209' r='20.8476'/%3e %3c/g%3e %3ccircle id='path0' class='cls-5' cx='89.8984' cy='51.8186' r='15.0295'/%3e %3cg id='O'%3e %3ccircle id='path1' class='cls-5' cx='115.7584' cy='51.8186' r='9.2037'/%3e %3c/g%3e %3ccircle id='path2' class='cls-6' cx='139.0462' cy='51.8186' r='9.2037'/%3e %3cg id='P'%3e %3ccircle id='path3' class='cls-6' cx='157.3915' cy='51.8186' r='7.5148'/%3e %3c/g%3e %3ccircle id='path4' class='cls-7' cx='123.8217' cy='83.3822' r='7.5148'/%3e %3cg id='N'%3e %3ccircle id='path5' class='cls-7' cx='138.277' cy='83.3822' r='5.3137'/%3e %3c/g%3e %3ccircle id='path6' class='cls-8' cx='191.4168' cy='37.8428' r='10.6275'/%3e %3cg id='F-2' data-name='F'%3e %3ccircle id='path7' class='cls-8' cx='208.9849' cy='37.8428' r='5.3137'/%3e %3c/g%3e %3ccircle id='path8' class='cls-9' cx='228.3828' cy='37.8428' r='9.2037'/%3e %3ccircle id='path9' class='cls-10' cx='213.3016' cy='68.5482' r='9.2037'/%3e %3cg id='U'%3e %3ccircle id='path10' class='cls-10' cx='231.6468' cy='68.5482' r='7.5148'/%3e %3c/g%3e %3cg id='V'%3e %3ccircle id='path11' class='cls-10' cx='223.8827' cy='80.7414' r='5.3137'/%3e %3c/g%3e %3ccircle id='path12' class='cls-11' cx='143.1935' cy='130.8209' r='10.6275'/%3e %3cg id='S'%3e %3ccircle id='path13' class='cls-11' cx='162.9626' cy='130.8209' r='7.5148'/%3e %3c/g%3e %3cg id='R'%3e %3ccircle id='path14' class='cls-11' cx='155.5991' cy='143.2602' r='5.3137'/%3e %3c/g%3e %3cg id='Q'%3e %3ccircle id='path15' class='cls-12' cx='184.5615' cy='130.8209' r='9.2037'/%3e %3c/g%3e %3ccircle id='path16' class='cls-12' cx='204.5957' cy='130.8209' r='9.2037'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$9 = {
    name: 'Circle Packing',
    id: 'rawgraphs.circlepacking',
    thumbnail: img$h,
    icon: img$g,
    categories: ['hierarchies', 'proportions'],
    description: 'It displays values of leaf nodes of a hierarchical structure by using circles areas. The hierarchical structure is depicted using nested circles. A further quantitative dimension with size and a quantitative or categorical dimension with color.' // code:'https://github.com/rawgraphs/raw',
    // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$9 = [{
    id: 'hierarchy',
    name: 'Hiérarchie',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: 'csvDistinct'
  }];

  const mapData$9 = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    const results = [];
    rollups(data, v => {
      const item = {
        hierarchy: new Map(mapping.hierarchy.value.map(d => [d, v[0][d]])),
        //get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'cells color',
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
      results.push(item);
      return item;
    }, ...mapping.hierarchy.value.map(level => d => d[level]) // create a grouping for each level of the hierarchy
    );
    return results;
  };

  function render$9(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard
      width,
      height,
      background,
      // margin
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legend
      showLegend,
      legendWidth,
      // chart options
      padding,
      sortCirclesBy,
      // color
      colorScale,
      // labels
      showLabelsOutline,
      showHierarchyLabels,
      hierarchyLabelsStyle,
      autoHideLabels,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // create the hierarchical structure

    const nest = rollup(data, v => v[0], ...mapping.hierarchy.value.map(level => d => d.hierarchy.get(level)));
    const hierarchy$1 = hierarchy(nest).sum(d => d[1] instanceof Map ? 0 : d[1].size) // since maps have a .size porperty in native javascript, sum only values for leaves, and not for Maps
    .sort((a, b) => {
      if (sortCirclesBy !== 'original') {
        return d3[sortCirclesBy](a.value, b.value);
      }
    });

    const pack = data => index$3().size([chartWidth, chartHeight]).padding(showHierarchyLabels ? padding + 4 : padding)(hierarchy$1);

    const root = pack();
    const circle = arc().innerRadius(0).outerRadius(d => d).startAngle(-Math.PI).endAngle(Math.PI); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');
    const node = svg.append('g').attr('id', 'nodes').selectAll('g').data(root.descendants()).join('g').attr('transform', d => `translate(${d.x + 1},${d.y + 1})`).attr('id', d => d.data[0]);
    node.append('path').attr('id', d => 'p_' + (d.x + d.y + d.r + d.depth + d.height)).attr('d', d => circle(d.r)).attr('fill', d => d.children ? 'none' : colorScale(d.data[1].color)).attr('stroke', d => d.children ? '#ccc' : 'none');
    node.filter(d => !d.children);

    if (showHierarchyLabels) {
      const parents = node.filter(d => d.children);

      if (hierarchyLabelsStyle === 'onPath') {
        parents.append('text').attr('fill', 'black').attr('text-anchor', 'middle').attr('font-family', "'Arial', sans-serif").attr('font-size', 8).attr('dominant-baseline', 'middle').append('textPath').attr('href', d => '#p_' + (d.x + d.y + d.r + d.depth + d.height)).attr('startOffset', '50%').text(d => d.data[0]);
      }

      if (hierarchyLabelsStyle === 'onPoint') {
        parents.append('text').attr('fill', 'black').attr('text-anchor', 'middle').attr('font-family', "'Arial', sans-serif").attr('font-size', 8).attr('dominant-baseline', 'middle').attr('x', d => 0).attr('y', d => -d.r).text(d => d.data[0]);
      }
    }

    const labelsLayer = svg.append('g').attr('id', 'labels');
    labelsLayer.selectAll('g').data(mapping.label.value ? root.leaves() : []).join('g').attr('transform', d => `translate(${d.x + 1},${d.y + 1})`).append('text').attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data((d, i, a) => {
      return Array.isArray(d.data[1].label) ? d.data[1].label : [d.data[1].label];
    }).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * 12).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      //labelsOcclusion(texts, (d) => d.r)
      labelsOcclusion(labelsLayer.selectAll('text'), d => d.r);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value + ` [${mapping.color.config.aggregation}]`, colorScale);
      } // calculate the scale


      let sizeScale = sqrt$1().domain(extent(hierarchy$1.leaves(), d => d.value)).rangeRound(extent(hierarchy$1.leaves(), d => d.r)); // if the maximum radius is bigger than a quarter of the legend width,
      // we must rescale it to fit in it. In this way, the maximum diameter in the legend
      // will be the half of legend width

      if (sizeScale.range()[1] > legendWidth / 4) {
        sizeScale.domain([sizeScale.invert(legendWidth / 8), sizeScale.invert(legendWidth / 4)]).rangeRound([legendWidth / 8, legendWidth / 4]);
      }

      chartLegend.addSize(mapping.size.value ? mapping.size.value + ` [${mapping.size.config.aggregation}]` : 'Number of records', sizeScale, 'circle');
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$9 = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 20,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 20,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 2,
      group: 'chart'
    },
    sortCirclesBy: {
      type: 'text',
      label: 'Sort circles by',
      group: 'chart',
      options: [{
        label: 'Size (descending)',
        value: 'descending'
      }, {
        label: 'Size (ascending)',
        value: 'ascending'
      }, {
        label: 'Original',
        value: 'original'
      }],
      default: 'descending'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    showHierarchyLabels: {
      type: 'boolean',
      label: 'Show hierarchy labels',
      default: false,
      group: 'labels'
    },
    hierarchyLabelsStyle: {
      type: 'text',
      label: 'Hierarchy labels position',
      group: 'labels',
      options: [{
        label: 'On path',
        value: 'onPath'
      }, {
        label: 'On point',
        value: 'onPoint'
      }],
      default: 'onPoint',
      disabled: {
        showHierarchyLabels: false
      }
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels'
    }
  };

  var circlepacking = {
    metadata: metadata$9,
    dimensions: dimensions$9,
    mapData: mapData$9,
    render: render$9,
    visualOptions: visualOptions$9,
    styles: styles$1
  };

  var img$i = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M46.5%2c11V10a16.5921%2c16.5921%2c0%2c0%2c0-9.2656%2c2.5674A15.49%2c15.49%2c0%2c0%2c1%2c28.5%2c15v.5l-.0107-.5c-4.7373.1006-7.0948%2c3.48-9.3741%2c6.75C16.873%2c24.9639%2c14.7559%2c28%2c10.5%2c28v1c4.1914%2c0%2c6.31%2c4.2373%2c8.5527%2c8.7236C21.333%2c42.2842%2c23.6914%2c47%2c28.5%2c47h18V46h-18c-4.1914%2c0-6.31-4.2373-8.5527-8.7236C18.6091%2c34.6%2c17.24%2c31.8778%2c15.3685%2c30.079a17.68%2c17.68%2c0%2c0%2c1%2c3.8%2c2.7945C21.45%2c34.9023%2c23.81%2c37%2c28.5%2c37a23.7614%2c23.7614%2c0%2c0%2c1%2c8.8193%2c1.4717A25.01%2c25.01%2c0%2c0%2c0%2c46.5%2c40V39a23.88%2c23.88%2c0%2c0%2c1-8.8643-1.4766%2c31.9956%2c31.9956%2c0%2c0%2c0-3.1731-.9251c1.1684-.1783%2c2.159-.3938%2c3.1233-.6086A35.3274%2c35.3274%2c0%2c0%2c1%2c46.5%2c35V34a36.1757%2c36.1757%2c0%2c0%2c0-9.1309%2c1.0137A34.7618%2c34.7618%2c0%2c0%2c1%2c28.5%2c36c-4.31%2c0-6.4268-1.8818-8.668-3.8735A16.691%2c16.691%2c0%2c0%2c0%2c15.13%2c28.8706c1.6782-.1031%2c2.9668-.2536%2c4.2171-.4028A57.2912%2c57.2912%2c0%2c0%2c1%2c28.4922%2c28l.0078-.5V28h18V27H28.5078a59.012%2c59.012%2c0%2c0%2c0-9.28.4746c-1.3172.1573-2.6679.317-4.4952.4185%2c2.1915-1.266%2c3.7161-3.4392%2c5.2032-5.5713C22.1693%2c19.1177%2c24.28%2c16.0919%2c28.507%2c16a15.4916%2c15.4916%2c0%2c0%2c1%2c8.7274%2c2.4324A16.5921%2c16.5921%2c0%2c0%2c0%2c46.5%2c21V20a15.5584%2c15.5584%2c0%2c0%2c1-8.7793-2.4409A23.5%2c23.5%2c0%2c0%2c0%2c34.5081%2c16H46.5V15H34.5081a23.5%2c23.5%2c0%2c0%2c0%2c3.2126-1.5591A15.5584%2c15.5584%2c0%2c0%2c1%2c46.5%2c11Z'/%3e %3c/g%3e %3cg id='primary'%3e %3ccircle class='cls-2' cx='10.5' cy='28.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='10.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='15.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='20.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='27.5' r='1.5'/%3e %3ccircle class='cls-2' cx='28.5' cy='27.5' r='1.5'/%3e %3ccircle class='cls-2' cx='28.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='28.5' cy='46.5' r='1.5'/%3e %3ccircle class='cls-2' cx='28.5' cy='15.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='34.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='39.5' r='1.5'/%3e %3ccircle class='cls-2' cx='46.5' cy='46.5' r='1.5'/%3e %3c/g%3e%3c/svg%3e";

  var img$j = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: none%3b stroke: %23ccc%3b %7d .cls-3 %7b fill: %23ccc%3b %7d .cls-11%2c .cls-16%2c .cls-4%2c .cls-5%2c .cls-6 %7b isolation: isolate%3b %7d .cls-11%2c .cls-16%2c .cls-5%2c .cls-6 %7b font-size: 12px%3b font-family: Helvetica%3b %7d .cls-6 %7b letter-spacing: -0.0547em%3b %7d .cls-7 %7b fill: %23fee89a%3b %7d .cls-8 %7b fill: %23ebf7a6%3b %7d .cls-9 %7b fill: %23a0d9a3%3b %7d .cls-10 %7b fill: %234ba0b1%3b %7d .cls-11 %7b letter-spacing: -0.0366em%3b %7d .cls-12 %7b fill: %235e4fa2%3b %7d .cls-13 %7b fill: %239e0142%3b %7d .cls-14 %7b fill: %23fba35e%3b %7d .cls-15 %7b fill: %23e1524a%3b %7d .cls-16 %7b letter-spacing: -0.0176em%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg id='links'%3e %3cpath class='cls-2' d='M5%2c77.1025c48.6667%2c0%2c48.6667-55.1349%2c97.3333-55.1349'/%3e %3cpath class='cls-2' d='M5%2c77.1025c48.6667%2c0%2c48.6667-.2946%2c97.3333-.2946'/%3e %3cpath class='cls-2' d='M5%2c77.1025c48.6667%2c0%2c48.6667%2c55.43%2c97.3333%2c55.43'/%3e %3cpath class='cls-2' d='M102.3333%2c21.9676c48.6667%2c0%2c48.6667-11.734%2c97.3334-11.734'/%3e %3cpath class='cls-2' d='M102.3333%2c21.9676C151%2c21.9676%2c151%2c33.7015%2c199.6667%2c33.7015'/%3e %3cpath class='cls-2' d='M102.3333%2c76.8079C151%2c76.8079%2c151%2c59.5528%2c199.6667%2c59.5528'/%3e %3cpath class='cls-2' d='M102.3333%2c76.8079c48.6667%2c0%2c48.6667-1%2c97.3334-1'/%3e %3cpath class='cls-2' d='M102.3333%2c76.8079C151%2c76.8079%2c151%2c95.0631%2c199.6667%2c95.0631'/%3e %3cpath class='cls-2' d='M102.3333%2c132.5322c48.6667%2c0%2c48.6667-15.83%2c97.3334-15.83'/%3e %3cpath class='cls-2' d='M102.3333%2c132.5322c48.6667%2c0%2c48.6667-1.4042%2c97.3334-1.4042'/%3e %3cpath class='cls-2' d='M102.3333%2c132.5322c48.6667%2c0%2c48.6667%2c17.2342%2c97.3334%2c17.2342'/%3e %3cpath class='cls-2' d='M199.6667%2c10.2336H297'/%3e %3cpath class='cls-2' d='M199.6667%2c33.7015c48.6666%2c0%2c48.6666-7.213%2c97.3333-7.213'/%3e %3cpath class='cls-2' d='M199.6667%2c33.7015c48.6666%2c0%2c48.6666%2c7.213%2c97.3333%2c7.213'/%3e %3cpath class='cls-2' d='M199.6667%2c75.8077H297'/%3e %3cpath class='cls-2' d='M199.6667%2c95.0631c48.6666%2c0%2c48.6666-7.2129%2c97.3333-7.2129'/%3e %3cpath class='cls-2' d='M199.6667%2c95.0631c48.6666%2c0%2c48.6666%2c7.213%2c97.3333%2c7.213'/%3e %3cpath class='cls-2' d='M199.6667%2c116.7021H297'/%3e %3cpath class='cls-2' d='M199.6667%2c131.128H297'/%3e %3cpath class='cls-2' d='M199.6667%2c149.7664H297'/%3e %3c/g%3e %3cg id='nodes'%3e %3ccircle class='cls-3' cx='5' cy='77.1025' r='5'/%3e %3cg id='C'%3e %3ccircle class='cls-3' cx='102.3333' cy='21.9676' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(85.3344 25.9676)'%3eC%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='A'%3e %3ccircle class='cls-3' cx='102.3333' cy='76.8079' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-6' transform='translate(85.9935 80.8079)'%3eA%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='B'%3e %3ccircle class='cls-3' cx='102.3333' cy='132.5322' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(85.6654 136.5322)'%3eB%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='G'%3e %3ccircle class='cls-7' cx='199.6667' cy='10.2336' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(182.1656 14.2336)'%3eG%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='H'%3e %3ccircle class='cls-8' cx='199.6667' cy='33.7015' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(182.4996 37.7015)'%3eH%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='I'%3e %3ccircle class='cls-9' cx='199.6667' cy='59.5528' r='10'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(212.6664 63.5528)'%3eI%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='L'%3e %3ccircle class='cls-10' cx='199.6667' cy='75.8077' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-11' transform='translate(183.7155 79.8077)'%3eL%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='M'%3e %3ccircle class='cls-12' cx='199.6667' cy='95.0631' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(181.8346 99.0631)'%3eM%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='D'%3e %3ccircle class='cls-13' cx='199.6667' cy='116.7021' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(182.4996 120.7021)'%3eD%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='F'%3e %3ccircle class='cls-14' cx='199.6667' cy='131.128' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(183.1676 135.128)'%3eF%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='E'%3e %3ccircle class='cls-15' cx='199.6667' cy='149.7664' r='5'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(182.8307 153.7664)'%3eE%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='Q'%3e %3ccircle class='cls-7' cx='297' cy='10.2336' r='10'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.333 14.2336)'%3eQ%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='R'%3e %3ccircle class='cls-8' cx='297' cy='26.4885' r='5.7735'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.667 30.4885)'%3eR%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='S'%3e %3ccircle class='cls-8' cx='297' cy='40.9145' r='8.165'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.998 44.9145)'%3eS%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='F-2' data-name='F'%3e %3ccircle class='cls-10' cx='297' cy='75.8077' r='5.7735'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(309.335 79.8077)'%3eF%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='V'%3e %3ccircle class='cls-12' cx='297' cy='87.8502' r='5.7735'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.998 91.8502)'%3eV%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='U'%3e %3ccircle class='cls-12' cx='297' cy='102.2761' r='8.165'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.667 106.2761)'%3eU%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='N'%3e %3ccircle class='cls-13' cx='297' cy='116.7021' r='5.7735'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.667 120.7021)'%3eN%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='P'%3e %3ccircle class='cls-14' cx='297' cy='131.128' r='8.165'/%3e %3cg class='cls-4'%3e %3ctext class='cls-16' transform='translate(309.1035 135.128)'%3eP%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='O'%3e %3ccircle class='cls-15' cx='297' cy='149.7664' r='10'/%3e %3cg class='cls-4'%3e %3ctext class='cls-5' transform='translate(308.333 153.7664)'%3eO%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$a = {
    name: 'Dendrogramme en ligne',
    id: 'rawgraphs.lineardendrogram',
    thumbnail: img$j,
    icon: img$i,
    categories: ['hierarchies', 'proportions'],
    description: 'Il affiche des données structurées hiérarchiquement avec une structure arborescente, où le nœud racine est à gauche et les feuilles à droite. La taille des nœuds peut être utilisée pour associer une dimension quantitative supplémentaire avec la taille et une dimension quantitative ou catégorielle avec la couleur.' // code:'https://github.com/rawgraphs/raw',
    // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$a = [{
    id: 'hierarchy',
    name: 'Hiérarchie',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: 'csvDistinct'
  }];

  const mapData$a = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    'label' in mapping ? null : mapping.label = {
      value: undefined
    };
    const results = [];
    rollups(data, v => {
      const item = {
        hierarchy: new Map(mapping.hierarchy.value.map(d => [d, v[0][d]])),
        //get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'cells color',
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
      results.push(item);
      return item;
    }, ...mapping.hierarchy.value.map(level => d => d[level]) // create a grouping for each level of the hierarchy
    );
    return results;
  };

  function render$a(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      // margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legend
      showLegend,
      legendWidth,
      // colors
      colorScale,
      maxDiameter,
      layout,
      sizeOnlyLeaves,
      sortBy,
      // labels
      showHierarchyLabels,
      showLabelsOutline,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // create the hierarchical structure

    const nest = rollup(data, v => v[0], ...mapping.hierarchy.value.map(level => d => d.hierarchy.get(level)));
    const hierarchy$1 = hierarchy(nest) // since maps have also a .size porperty, sum only values for leaves, and not for Maps
    .sum(d => d[1] instanceof Map ? 0 : d[1].size) // sort nodes according to options
    .sort((a, b) => {
      switch (sortBy) {
        case 'Size (descending)':
          return descending(a.value, b.value);

        case 'Size (ascending)':
          return ascending(a.value, b.value);

        case 'Name':
          return ascending(a.data[0], b.data[0]);

        default:
          return 0;
      }
    }); // filter nodes with empty values in the hierarchy
    // @TODO check if this works also with empty values in non-leaf nodes

    hierarchy$1.descendants().filter(d => d.data[0] === '') // select nodes with empty key
    .forEach(d => {
      const index = d.parent.children.indexOf(d); // get its index in parent's children array

      d.parent.children.splice(index, 1); // remove it

      if (d.parent.children.length == 0) {
        // if it was the only children
        d.parent.data[1] = d.data[1]; // move its values to parent

        delete d.parent.children; // and remove the empty children array
      }
    }); // size scale

    const sizeScale = sqrt$1().domain([0, max(hierarchy$1.leaves(), d => d.value)]).range([0, maxDiameter / 2]); // get the total size

    const totalValue = sum(hierarchy$1.leaves(), d => sizeScale(d.value) * 2); // compute padding

    const padding = (chartHeight - totalValue) / (hierarchy$1.leaves().length - 1); // dictionary to choose algorythm according to options

    const layouts = {
      'Cluster Dendogram': cluster(),
      Tree: tree()
    }; // compute the layout

    const tree$1 = nest => {
      return layouts[layout] // compute according to the options
      .size([chartHeight, chartWidth]).separation((a, b) => sizeScale(a.value) + sizeScale(b.value) + padding)(hierarchy$1);
    };

    const root = tree$1(); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');
    svg.append('g').attr('id', 'links').selectAll('path').data(root.links()).join('path').attr('d', linkHorizontal().x(d => d.y).y(d => d.x)).attr('fill', 'none').attr('stroke', '#ccc');
    const node = svg.append('g').attr('id', 'nodes').selectAll('g').data(root.descendants()).join('g').attr('id', d => d.data[0]).attr('transform', d => `translate(${d.y},${d.x})`);
    node.append('circle').attr('fill', function (d) {
      if ('children' in d) {
        // if not leaf, check if leaves has the same value
        const childrenColors = [...new Set(d.leaves().map(l => l.data[1].color))];
        return childrenColors.length == 1 ? colorScale(childrenColors[0]) : '#ccc';
      } else {
        // otherwise, if it's a leaf use its own color
        return colorScale(d.data[1].color);
      }
    }).attr('r', d => {
      if (sizeOnlyLeaves) {
        return d.children ? 5 : sizeScale(d.value);
      } else {
        return sizeScale(d.value);
      }
    });
    node.filter(d => showHierarchyLabels ? true : !d.children).append('text').attr('text-anchor', d => d.children ? 'end' : 'start').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => {
      if (d.children) {
        return [{
          string: d.data[0],
          x: sizeOnlyLeaves ? -6 - 2 : -sizeScale(d.value) - 2,
          children: true
        }];
      } else {
        const xpos = sizeScale(d.value); // [d.data[0]]
        // .concat(d.data[1].label)
        // .map((d) => ({ string: d, x: xpos }))

        return d.data[1].label.map(d => ({
          string: d,
          x: xpos + 2
        }));
      }
    }).join('tspan').attr('x', d => d.x).attr('y', 0).attr('dy', (d, i) => i * 12).text(d => d.string).styles((d, i) => {
      if (d.children) {
        return styles['labelSecondary'];
      } else {
        return styles[labelStyles[i]];
      }
    });
    node.selectAll('text').each(function () {
      const sel = select(this);
      sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      node.selectAll('text').styles(styles.labelOutline);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      chartLegend.addSize(mapping.size.value ? mapping.size.value : 'Number of records', sizeScale, 'circle');
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$a = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 150,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    maxDiameter: {
      type: 'number',
      label: 'Diamètre maximum',
      default: 20,
      group: 'chart'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    layout: {
      type: 'text',
      label: 'Layout algorythm',
      group: 'chart',
      options: ['Cluster Dendogram', 'Tree'],
      default: 'Tree'
    },
    sortBy: {
      type: 'text',
      label: 'Sort nodes by',
      group: 'chart',
      options: ['Size (descending)', 'Size (ascending)', 'Name', 'Original'],
      default: 'Size (descending)'
    },
    sizeOnlyLeaves: {
      type: 'boolean',
      label: 'Size only leaf nodes',
      default: true,
      group: 'chart'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'color'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showHierarchyLabels: {
      type: 'boolean',
      label: 'Show hierarchy labels',
      default: true,
      group: 'labels'
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    }
  };

  var dendrogram = {
    metadata: metadata$a,
    dimensions: dimensions$a,
    mapData: mapData$a,
    render: render$a,
    visualOptions: visualOptions$a,
    styles: styles$1
  };

  var img$k = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M41.6516%2c28.2064a14.3768%2c14.3768%2c0%2c0%2c0%2c1.8318-.5658%2c13.8021%2c13.8021%2c0%2c0%2c1%2c3.9648-.9111l-.0918-.9961a14.8546%2c14.8546%2c0%2c0%2c0-4.2148.9673%2c11.1656%2c11.1656%2c0%2c0%2c1-4.5439.7993H28.9244l5.2383-8.0153c1.3173-2.0138%2c2.9708-2.1361%2c4.8861-2.2772A8.6119%2c8.6119%2c0%2c0%2c0%2c43.2666%2c16.13l-.5332-.8467a7.7182%2c7.7182%2c0%2c0%2c1-3.7578.9267%2c10.4839%2c10.4839%2c0%2c0%2c0-3.0164.5256l3.1238-4.78-.8379-.5469-3.0542%2c4.6734a10.2981%2c10.2981%2c0%2c0%2c0-.4975-2.4483%2c9.2067%2c9.2067%2c0%2c0%2c1-.4922-4.21l-.99-.1435a10.1532%2c10.1532%2c0%2c0%2c0%2c.5235%2c4.6352c.497%2c1.6958.89%2c3.0347-.4112%2c5.0244l0%2c0-5.1576%2c7.8916L22.7725%2c9.2065l-.9571.293%2c5.2226%2c17.067L13.2354%2c15.2651l-.6329.7735L26.4212%2c27.3531l-17.68-1.62-.0918.9961%2c17.6881%2c1.62L10.7061%2c37.0161l.4843.875%2c15.6851-8.6959L19.1494%2c45.3813l.9024.4307%2c7.7036-16.139%2c2.7632%2c17.6708.9882-.1543L28.7445%2c29.5241%2c40.9707%2c42.5557l.7285-.6846L29.1545%2c28.5H38.5a5.5617%2c5.5617%2c0%2c0%2c1%2c4.2354%2c1.7256%2c8.5877%2c8.5877%2c0%2c0%2c0%2c4.2519%2c2.2495l.2051-.9785a7.6392%2c7.6392%2c0%2c0%2c1-3.8037-2.0283A9.3688%2c9.3688%2c0%2c0%2c0%2c41.6516%2c28.2064Z'/%3e %3c/g%3e %3cg id='primary'%3e %3ccircle class='cls-2' cx='28' cy='28' r='1.5'/%3e %3ccircle class='cls-2' cx='38.5' cy='28' r='1.5'/%3e %3ccircle class='cls-2' cx='47.305' cy='26.2314' r='1.5'/%3e %3ccircle class='cls-2' cx='47.0898' cy='31.986' r='1.5'/%3e %3ccircle class='cls-2' cx='43.1356' cy='15.6079' r='1.5'/%3e %3ccircle class='cls-2' cx='38.6642' cy='11.6828' r='1.5'/%3e %3ccircle class='cls-2' cx='33.7062' cy='9.352' r='1.5'/%3e %3ccircle class='cls-2' cx='22.2938' cy='9.353' r='1.5'/%3e %3ccircle class='cls-2' cx='12.9193' cy='15.6517' r='1.5'/%3e %3ccircle class='cls-2' cx='8.6949' cy='26.2314' r='1.5'/%3e %3ccircle class='cls-2' cx='10.9487' cy='37.4537' r='1.5'/%3e %3ccircle class='cls-2' cx='19.6004' cy='45.5965' r='1.5'/%3e %3ccircle class='cls-2' cx='31.0127' cy='47.2664' r='1.5'/%3e %3ccircle class='cls-2' cx='41.3348' cy='42.2132' r='1.5'/%3e %3ccircle class='cls-2' cx='33.7624' cy='19.2262' r='1.5'/%3e %3ccircle class='cls-2' cx='29.6124' cy='38.376' r='1.5'/%3e %3ccircle class='cls-2' cx='35.2974' cy='35.5428' r='1.5'/%3e %3ccircle class='cls-2' cx='23.4611' cy='37.5086' r='1.5'/%3e %3ccircle class='cls-2' cx='18.7725' cy='33.0056' r='1.5'/%3e %3ccircle class='cls-2' cx='17.5583' cy='27.0434' r='1.5'/%3e %3ccircle class='cls-2' cx='19.8824' cy='21.3532' r='1.5'/%3e %3ccircle class='cls-2' cx='24.9211' cy='17.9385' r='1.5'/%3e %3c/g%3e%3c/svg%3e";

  var img$l = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-4 %7b fill: none%3b %7d .cls-2 %7b fill: white%3b %7d .cls-3 %7b clip-path: url(%23clip-path)%3b %7d .cls-4 %7b stroke: %23ccc%3b %7d .cls-5 %7b fill: %23ccc%3b %7d .cls-6 %7b fill: %23e1524a%3b %7d .cls-7 %7b fill: %23fba35e%3b %7d .cls-8 %7b fill: %239e0142%3b %7d .cls-9 %7b fill: %234ba0b1%3b %7d .cls-10 %7b fill: %235e4fa2%3b %7d .cls-11 %7b fill: %23a0d9a3%3b %7d .cls-12 %7b fill: %23ebf7a6%3b %7d .cls-13 %7b fill: %23fee89a%3b %7d .cls-14%2c .cls-15%2c .cls-16%2c .cls-17 %7b isolation: isolate%3b font-size: 12px%3b font-family: Helvetica%3b %7d .cls-15 %7b letter-spacing: -0.0547em%3b %7d .cls-16 %7b letter-spacing: -0.0366em%3b %7d .cls-17 %7b letter-spacing: -0.0176em%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' width='320' height='160'/%3e %3c/clipPath%3e %3c/defs%3e %3crect class='cls-2' width='320' height='160'/%3e %3cg class='cls-3'%3e %3cg id='viz'%3e %3cg id='links'%3e %3cpath class='cls-4' d='M160.6626%2c79.527c-2.0278%2c12.3344%2c11.7336-4.31%2c23.4672-8.6193'/%3e %3cpath class='cls-4' d='M160.6626%2c79.527c-2.0278%2c12.3344-3.76%2c11.9213-7.519%2c23.8425'/%3e %3cpath class='cls-4' d='M160.6626%2c79.527c-2.0278%2c12.3344-9.7362-7.8393-19.4725-15.6787'/%3e %3cpath class='cls-4' d='M184.13%2c70.9077c11.7336-4.31-7.21-25.1733-1.79-36.4375'/%3e %3cpath class='cls-4' d='M184.13%2c70.9077c11.7336-4.31%2c12.8965-.5422%2c25.0177-3.5961'/%3e %3cpath class='cls-4' d='M184.13%2c70.9077c11.7336-4.31%2c10.7982%2c23.8553%2c22.22%2c28.934'/%3e %3cpath class='cls-4' d='M153.1436%2c103.37c-3.76%2c11.9213%2c24.5%2c9.5923%2c30.1607%2c20.7373'/%3e %3cpath class='cls-4' d='M153.1436%2c103.37c-3.76%2c11.9213-6.5889%2c10.9025-11.2915%2c22.4842'/%3e %3cpath class='cls-4' d='M153.1436%2c103.37c-3.76%2c11.9213-25.5707-6.1981-36.6006-.3167'/%3e %3cpath class='cls-4' d='M141.19%2c63.8483c-9.7362-7.8393-17.0108%2c7.0059-29.1719%2c4.1149'/%3e %3cpath class='cls-4' d='M141.19%2c63.8483c-9.7362-7.8393%2c3.2149-18.1139-2.2043-29.3781'/%3e %3cpath class='cls-4' d='M182.3394%2c34.47l10.8384-22.5284'/%3e %3cpath class='cls-4' d='M209.1475%2c67.3116%2c233.39%2c61.2039'/%3e %3cpath class='cls-4' d='M206.35%2c99.8417l22.8435%2c10.1574'/%3e %3cpath class='cls-4' d='M183.3043%2c124.1068l11.3208%2c22.29'/%3e %3cpath class='cls-4' d='M141.8521%2c125.8537c-4.7027%2c11.5817%2c12.54%2c15.858%2c11.2865%2c28.295'/%3e %3cpath class='cls-4' d='M141.8521%2c125.8537c-4.7027%2c11.5817-20.0461%2c2.6265-27.8174%2c12.4172'/%3e %3cpath class='cls-4' d='M112.0182%2c67.9632c-12.1611-2.8909-13.7717%2c14.8015-26.2549%2c15.449'/%3e %3cpath class='cls-4' d='M112.0182%2c67.9632c-12.1611-2.8909-5.6376-19.4154-16.494-25.6113'/%3e %3cpath class='cls-4' d='M138.9858%2c34.47c-5.4191-11.2642-5.4191-11.2642-10.8383-22.5284'/%3e %3c/g%3e %3cg%3e %3ccircle class='cls-5' cx='160.6626' cy='79.527' r='5'/%3e %3ccircle class='cls-5' cx='184.1298' cy='70.9077' r='5'/%3e %3ccircle class='cls-5' cx='153.1436' cy='103.3695' r='5'/%3e %3ccircle class='cls-5' cx='141.1901' cy='63.8483' r='5'/%3e %3ccircle class='cls-6' cx='182.3394' cy='34.4702' r='5'/%3e %3ccircle class='cls-7' cx='209.1475' cy='67.3116' r='5'/%3e %3ccircle class='cls-8' cx='206.3498' cy='99.8417' r='5'/%3e %3ccircle class='cls-9' cx='183.3043' cy='124.1068' r='5'/%3e %3ccircle class='cls-10' cx='141.8521' cy='125.8537' r='5'/%3e %3ccircle class='cls-11' cx='116.543' cy='103.0528' r='20'/%3e %3ccircle class='cls-12' cx='112.0182' cy='67.9632' r='5'/%3e %3ccircle class='cls-13' cx='138.9858' cy='34.4702' r='5'/%3e %3ccircle class='cls-6' cx='193.1778' cy='11.9418' r='20'/%3e %3ccircle class='cls-7' cx='233.39' cy='61.2039' r='13.3333'/%3e %3ccircle class='cls-8' cx='229.1933' cy='109.9991' r='6.6667'/%3e %3ccircle class='cls-9' cx='194.6251' cy='146.3967' r='6.6667'/%3e %3ccircle class='cls-10' cx='153.1386' cy='154.1487' r='13.3333'/%3e %3ccircle class='cls-10' cx='114.0347' cy='138.2709' r='6.6667'/%3e %3ccircle class='cls-12' cx='85.7633' cy='83.4122' r='13.3333'/%3e %3ccircle class='cls-12' cx='95.5242' cy='42.352' r='6.6667'/%3e %3ccircle class='cls-13' cx='128.1474' cy='11.9418' r='20'/%3e %3c/g%3e %3cg%3e %3ctext class='cls-14' transform='translate(172.3809 79.5233) rotate(-20.1677)'%3eB%3c/text%3e %3ctext class='cls-15' transform='matrix(0.3008%2c -0.9537%2c 0.9537%2c 0.3008%2c 158.7581%2c 98.8386)'%3eA%3c/text%3e %3ctext class='cls-14' transform='matrix(0.7789%2c 0.6272%2c -0.6272%2c 0.7789%2c 143.3358%2c 70.7422)'%3eC%3c/text%3e %3ctext class='cls-14' transform='translate(179.9372 48.8317) rotate(-64.3077)'%3eE%3c/text%3e %3ctext class='cls-14' transform='translate(197.2319 74.452) rotate(-14.141)'%3eF%3c/text%3e %3ctext class='cls-14' transform='matrix(0.9137%2c 0.4063%2c -0.4063%2c 0.9137%2c 191.3355%2c 97.4866)'%3eD%3c/text%3e %3ctext class='cls-16' transform='translate(173.9365 114.6304) rotate(63.0747)'%3eL%3c/text%3e %3ctext class='cls-14' transform='translate(147.7733 121.8223) rotate(-67.9008)'%3eM%3c/text%3e %3ctext class='cls-14' transform='matrix(0.8824%2c -0.4705%2c 0.4705%2c 0.8824%2c 93.446%2c 119.8627)'%3eI%3c/text%3e %3ctext class='cls-14' transform='translate(116.9062 73.2923) rotate(13.3724)'%3eH%3c/text%3e %3ctext class='cls-14' transform='translate(137.9879 41.6753) rotate(64.3077)'%3eG%3c/text%3e %3ctext class='cls-17' transform='translate(252.1783 60.6085) rotate(-14.141)'%3eP%3c/text%3e %3ctext class='cls-14' transform='matrix(0.9137%2c 0.4063%2c -0.4063%2c 0.9137%2c 238.2403%2c 118.3428)'%3eN%3c/text%3e %3ctext class='cls-14' transform='translate(196.2792 158.6221) rotate(63.0747)'%3eF%3c/text%3e %3ctext class='cls-14' transform='matrix(0.6217%2c -0.7833%2c 0.7833%2c 0.6217%2c 104.9654%2c 156.2111)'%3eV%3c/text%3e %3ctext class='cls-14' transform='matrix(0.9987%2c -0.0518%2c 0.0518%2c 0.9987%2c 59.6675%2c 88.8149)'%3eS%3c/text%3e %3ctext class='cls-14' transform='matrix(0.8685%2c 0.4957%2c -0.4957%2c 0.8685%2c 75.843%2c 35.7488)'%3eR%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$b = {
    name: 'Dendrogramme circulaire',
    id: 'rawgraphs.circulardendrogram',
    thumbnail: img$l,
    icon: img$k,
    categories: ['hierarchies', 'proportions'],
    description: 'Il affiche des données structurées hiérarchiquement avec une structure arborescente radiale, où le nœud racine est au centre avec les hiérarchies se déplaçant vers l\'extérieur. La zone de nœuds peut être utilisée pour associer une dimension quantitative supplémentaire et une dimension quantitative ou catégorielle avec la couleur.',
    code: 'https://observablehq.com/@d3/radial-dendrogram' // tutorial:'https://rawgraphs.io/learning/'

  };

  const dimensions$b = [{
    id: 'hierarchy',
    name: 'Hiérarchie',
    validTypes: ['number', 'date', 'string'],
    required: true,
    multiple: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }];

  const mapData$b = function (data, mapping, dataTypes, dimensions) {
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const labelAggregators = getDimensionAggregator('label', mapping, dataTypes, dimensions);
    const results = [];
    rollups(data, v => {
      const item = {
        hierarchy: new Map(mapping.hierarchy.value.map(d => [d, v[0][d]])),
        //get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'cells color',
        label: mapping.label.value ? mapping.label.value.map((label, i) => {
          return labelAggregators[i](v.map(d => d[label]));
        }) : undefined // create array of strings

      };
      results.push(item);
      return item;
    }, ...mapping.hierarchy.value.map(level => d => d[level]) // create a grouping for each level of the hierarchy
    );
    return results;
  };

  function render$b(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      // margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // legend
      showLegend,
      legendWidth,
      // colors
      colorScale,
      maxDiameter,
      layout,
      sizeOnlyLeaves,
      label1Style,
      label2Style,
      label3Style,
      sortBy,
      // labels
      showHierarchyLabels,
      hierarchyStyle,
      labelStyles,
      showLabelsOutline
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const radius = min([chartWidth, chartHeight]) / 2;
    const circumference = radius * 2 * Math.PI; // create the hierarchical structure

    const nest = rollup(data, v => v[0], ...mapping.hierarchy.value.map(level => d => d.hierarchy.get(level)));
    const hierarchy$1 = hierarchy(nest) // since maps have also a .size porperty, sum only values for leaves, and not for Maps
    .sum(d => d[1] instanceof Map ? 0 : d[1].size) // sort nodes according to options
    .sort((a, b) => {
      switch (sortBy) {
        case 'Size (descending)':
          return descending(a.value, b.value);

        case 'Size (ascending)':
          return ascending(a.value, b.value);

        case 'Name':
          return ascending(a.data[0], b.data[0]);

        default:
          return 0;
      }
    }); // filter nodes with empty values in the hierarchy
    // @TODO check if this works also with empty values in non-leaf nodes

    hierarchy$1.descendants().filter(d => d.data[0] === '') // select nodes with empty key
    .forEach(d => {
      const index = d.parent.children.indexOf(d); // get its index in parent's children array

      d.parent.children.splice(index, 1); // remove it

      if (d.parent.children.length == 0) {
        // if it was the only children
        d.parent.data[1] = d.data[1]; // move its values to parent

        delete d.parent.children; // and remove the empty children array
      }
    }); // size scale

    const sizeScale = sqrt$1().domain([0, max(hierarchy$1.leaves(), d => d.value)]).range([0, maxDiameter / 2]); // get the total size

    const totalValue = sum(hierarchy$1.leaves(), d => sizeScale(d.value) * 2); // compute padding

    const padding = (circumference - totalValue) / (hierarchy$1.leaves().length - 1); // dictionary to choose algorythm according to options

    const layouts = {
      'Cluster Dendogram': cluster(),
      Tree: tree()
    }; // compute the layout

    const tree$1 = nest => {
      return layouts[layout] // compute according to the options
      .size([2 * Math.PI, radius - 100]).separation((a, b) => sizeScale(a.value) + sizeScale(b.value) + padding)(hierarchy$1);
    };

    const root = tree$1(); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')').attr('id', 'viz');
    svg.append('g').attr('id', 'links').selectAll('path').data(root.links()).join('path').attr('d', linkRadial().angle(d => d.x).radius(d => d.y)).attr('fill', 'none').attr('stroke', '#ccc');
    svg.append('g').selectAll('circle').data(root.descendants()).join('circle').attr('transform', d => `
	        rotate(${d.x * 180 / Math.PI - 90})
	        translate(${d.y},0)
	      `).attr('fill', function (d) {
      if ('children' in d) {
        // if not leaf, check if leaves has the same value
        const childrenColors = [...new Set(d.leaves().map(l => l.data[1].color))];
        return childrenColors.length == 1 ? colorScale(childrenColors[0]) : '#ccc';
      } else {
        // otherwise, if it's a leaf use its own color
        return colorScale(d.data[1].color);
      }
    }).attr('r', d => {
      if (sizeOnlyLeaves) {
        return d.children ? 5 : sizeScale(d.value);
      } else {
        return sizeScale(d.value);
      }
    }); // add labels

    const textGroups = svg.append('g').attr('id', 'labels');
    textGroups.selectAll('g').data(root.descendants()).join('g').filter(d => showHierarchyLabels ? true : !d.children) // if showHierarchyLabels is false, hide non-leaf nodes
    .attr('transform', d => `
	        rotate(${d.x * 180 / Math.PI - 90})
	        translate(${d.y},0)
	        rotate(${d.x >= Math.PI ? 180 : 0})
	      `).append('text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => {
      // if the node has children
      // pass just its name in hierarhcy
      if (d.children) {
        return [{
          string: d.data[0],
          x: d.x < Math.PI === !d.children ? 6 : -6,
          align: d.x < Math.PI === !d.children ? 'start' : 'end',
          style: styles['labelSecondary'],
          hierarchy: true
        }];
      } // else pass the mapped labels
      else {
          const xpos = sizeScale(d.value) + 5;
          return d.data[1].label.map((e, i) => ({
            string: e,
            x: d.x < Math.PI === !d.children ? xpos : -xpos,
            align: d.x < Math.PI === !d.children ? 'start' : 'end',
            style: styles[labelStyles[i]]
          }));
        }
    }).join('tspan').attr('x', d => d.x).attr('y', 0).attr('dy', (d, i) => i * 12).attr('text-anchor', d => d.align) // .styles((d, i) => styles[labelStyles[i]])
    .styles(d => d.style).text(d => d.string);
    textGroups.selectAll('text').each(function () {
      const sel = select(this);
      sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      textGroups.selectAll('text').styles(styles.labelOutline);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      chartLegend.addSize(mapping.size.value ? mapping.size.value : 'Number of records', sizeScale, 'circle');
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$b = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    maxDiameter: {
      type: 'number',
      label: 'Maximum diameter',
      default: 20,
      group: 'chart'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    layout: {
      type: 'text',
      label: 'Layout algorythm',
      group: 'chart',
      options: ['Cluster Dendogram', 'Tree'],
      default: 'Tree'
    },
    sortBy: {
      type: 'text',
      label: 'Sort nodes by',
      group: 'chart',
      options: ['Size (descending)', 'Size (ascending)', 'Name', 'Original'],
      default: 'Size (descending)'
    },
    sizeOnlyLeaves: {
      type: 'boolean',
      label: 'Size only leaf nodes',
      default: true,
      group: 'chart'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'color'
    },
    showHierarchyLabels: {
      type: 'boolean',
      label: 'Show hierarchy labels',
      default: true,
      group: 'labels'
    },
    hierarchyStyle: {
      type: 'text',
      label: 'Hierarchy labels',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    }
  };

  var circularDendrogram = {
    metadata: metadata$b,
    dimensions: dimensions$b,
    mapData: mapData$b,
    render: render$b,
    visualOptions: visualOptions$b,
    styles: styles$1
  };

  var img$m = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3crect class='cls-1' x='21' y='29' width='7' height='19'/%3e %3crect class='cls-1' x='41' y='34' width='7' height='14'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='9.185 9.685 7.5 8 5.815 9.685 5.815 11.115 7.003 9.927 7.003 48 7.997 48 7.997 9.927 9.185 11.115 9.185 9.685'/%3e %3crect class='cls-2' x='31' y='22.9517' width='7' height='25.0483'/%3e %3crect class='cls-2' x='11' y='36' width='7' height='12'/%3e %3c/g%3e%3c/svg%3e";

  var img$n = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: %23bee5a0%3b %7d .cls-3 %7b fill: %235e4fa2%3b %7d .cls-4 %7b fill: %23fdbe70%3b %7d .cls-5 %7b fill: %239e0142%3b %7d .cls-6 %7b fill: none%3b stroke: black%3b %7d .cls-7%2c .cls-8 %7b isolation: isolate%3b font-family: Helvetica%3b %7d .cls-7 %7b font-size: 12px%3b %7d .cls-8 %7b font-size: 10px%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg%3e %3cg%3e %3crect id='undefined_-_a' data-name='undefined - a' class='cls-2' x='28.9863' y='18.3333' width='46.1826' height='70'/%3e %3crect id='undefined_-_b' data-name='undefined - b' class='cls-3' x='77.1553' y='78.3333' width='46.1826' height='10'/%3e %3crect id='undefined_-_c' data-name='undefined - c' class='cls-4' x='125.3242' y='88.3333' width='46.1826' height='10'/%3e %3crect id='undefined_-_d' data-name='undefined - d' class='cls-5' x='173.4932' y='88.3333' width='46.1826' height='56.6667'/%3e %3crect id='undefined_-_e' data-name='undefined - e' class='cls-4' x='221.6621' y='88.3333' width='46.1826' height='40'/%3e %3crect id='undefined_-_f' data-name='undefined - f' class='cls-3' x='269.8311' y='58.3333' width='46.1826' height='30'/%3e %3c/g%3e %3cg id='xAxis'%3e %3cpath class='cls-6' d='M27.5%2c88.8333h291'/%3e %3cg%3e %3cline class='cls-6' x1='52.0776' y1='88.3333' x2='52.0776' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(49.2969 104.4333)'%3ea%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='100.2466' y1='88.3333' x2='100.2466' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(97.4658 104.4333)'%3eb%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='148.4155' y1='88.3333' x2='148.4155' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(145.9155 104.4333)'%3ec%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='196.5845' y1='88.3333' x2='196.5845' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(193.8037 104.4333)'%3ed%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='244.7534' y1='88.3333' x2='244.7534' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(241.9727 104.4333)'%3ee%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='292.9224' y1='88.3333' x2='292.9224' y2='94.3333'/%3e %3ctext class='cls-7' transform='translate(291.5332 104.4333)'%3ef%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='yAxis'%3e %3cpath class='cls-6' d='M27.5%2c155.5V5.5'/%3e %3cg%3e %3cline class='cls-6' x1='27' y1='155.5' x2='21' y2='155.5'/%3e %3ctext class='cls-8' transform='translate(1.0371 158.7)'%3e%e2%88%9220%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='138.8333' x2='21' y2='138.8333'/%3e %3ctext class='cls-8' transform='translate(1.0371 142.0333)'%3e%e2%88%9215%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='122.1667' x2='21' y2='122.1667'/%3e %3ctext class='cls-8' transform='translate(1.0371 125.3667)'%3e%e2%88%9210%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='105.5' x2='21' y2='105.5'/%3e %3ctext class='cls-8' transform='translate(6.5986 108.7)'%3e%e2%88%925%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='88.8333' x2='21' y2='88.8333'/%3e %3ctext class='cls-8' transform='translate(12.4385 92.0333)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='72.1667' x2='21' y2='72.1667'/%3e %3ctext class='cls-8' transform='translate(12.4385 75.3667)'%3e5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='55.5' x2='21' y2='55.5'/%3e %3ctext class='cls-8' transform='translate(6.877 58.7)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='38.8333' x2='21' y2='38.8333'/%3e %3ctext class='cls-8' transform='translate(6.877 42.0333)'%3e15%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='22.1667' x2='21' y2='22.1667'/%3e %3ctext class='cls-8' transform='translate(6.877 25.3666)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-6' x1='27' y1='5.5' x2='21' y2='5.5'/%3e %3ctext class='cls-8' transform='translate(6.877 8.7)'%3e25%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$c = {
    name: 'Histogramme',
    thumbnail: img$n,
    icon: img$m,
    id: 'rawgraphs.barchart',
    categories: ['correlations'],
    description: 'Il affiche une dimension catégorielle et les montants associés. Chaque barre représente une catégorie, la largeur est proportionnelle à la dimension quantitative.' // code: "https://github.com/rawgraphs/raw",
    // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$c = [{
    id: 'bars',
    name: 'Barres',
    validTypes: ['number', 'string', 'date'],
    required: true,
    operation: 'get'
  }, {
    id: 'size',
    name: 'Taille',
    operation: 'get',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$c = function (data, mapping, dataTypes, dimensions) {
    // define aggregators
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions);
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'color' in mapping ? null : mapping.color = {
      value: undefined
    };
    'series' in mapping ? null : mapping.series = {
      value: undefined
    };
    'size' in mapping ? null : mapping.size = {
      value: undefined
    };
    let results = [];
    rollups(data, v => {
      const item = {
        series: v[0][mapping.series.value],
        // get the first one since it's grouped
        bars: v[0][mapping.bars.value],
        // get the first one since it's grouped
        size: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : v.length,
        // aggregate. If not mapped, give 1 as size
        color: mapping.color.value ? colorAggregator(v.map(d => d[mapping.color.value])) : 'default' // aggregate, by default single color.

      };
      results.push(item);
      return item;
    }, d => d[mapping.series.value], // series grouping
    d => d[mapping.bars.value].toString() // bars grouping. toString() to enable grouping on dates
    );
    return results;
  };

  function render$c(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      padding,
      barsOrientation,
      sortBarsBy,
      // series options
      columnsNumber,
      useSameScale,
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const horizontalBars = {
      horizontal: true,
      vertical: false
    }[barsOrientation]; // create nest structure

    const nestedData = groups(data, d => d.series).map(d => ({
      data: d,
      totalSize: sum(d[1], d => d.size)
    })); // series sorting functions

    const seriesSortings = {
      totalDescending: function (a, b) {
        return descending(a.totalSize, b.totalSize);
      },
      totalAscending: function (a, b) {
        return ascending(a.totalSize, b.totalSize);
      },
      name: function (a, b) {
        return ascending(a.data[0], b.data[0]);
      }
    }; // sort series

    nestedData.sort(seriesSortings[sortSeriesBy]); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(mapping.series.value ? columnsNumber : 1);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz');
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d.data[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')'); // value domain

    let originalDomain = extent(data, d => d.size);
    let sizeDomain = originalDomain[0] > 0 ? [0, originalDomain[1]] : originalDomain; // bars sorting functions

    const barsSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a[1], b[1]);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a[1], b[1]);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      },
      Original: function (a, b) {
        return true;
      }
    }; // bars domain

    const barsDomain = rollups(data, v => sum(v, d => d.size), d => d.bars).sort(barsSortings[sortBarsBy]).map(d => d[0]); // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }

    series.each(function (d, seriesIndex) {
      // make a local selection for each serie
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // compute each serie width and height

      const seriesWidth = d.width - margin.right - margin.left;
      const seriesHeight = d.height - margin.top - margin.bottom; // check if padding is too high and leave no space for bars

      if (padding * barsDomain.length > (horizontalBars ? seriesHeight : seriesWidth)) {
        throw new Error('Padding is too high, decrase it in the panel "chart" > "Padding"');
      } // scales


      const barScale = band().range([0, horizontalBars ? seriesHeight : seriesWidth]).domain(barsDomain) //convert padding from px to percentage
      .padding(padding / (horizontalBars ? seriesHeight : seriesWidth / barsDomain.length));
      const seriesDomain = extent(d.data[1], d => d.size);
      const sizeScale = linear$2().domain(useSameScale ? sizeDomain : seriesDomain).nice().range(horizontalBars ? [0, seriesWidth] : [seriesHeight, 0]);
      selection.append('g').attr('class', 'bars').selectAll('rect').data(d => d.data[1]).join('rect').attr('id', d => d.series + ' - ' + d.bars).attr('x', d => {
        return horizontalBars ? sizeScale(Math.min(0, d.size)) : barScale(d.bars);
      }).attr('y', d => {
        return horizontalBars ? barScale(d.bars) : sizeScale(Math.max(0, d.size));
      }).attr('height', d => {
        return horizontalBars ? barScale.bandwidth() : Math.abs(sizeScale(d.size) - sizeScale(0));
      }).attr('width', d => {
        return horizontalBars ? Math.abs(sizeScale(d.size) - sizeScale(0)) : barScale.bandwidth();
      }).attr('fill', d => colorScale(d.color));

      if (horizontalBars) {
        selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + seriesHeight + ')').call(axisBottom(sizeScale)).call(g => g.append('text').attr('font-family', 'Arial, sans-serif').attr('font-size', 10).attr('x', seriesWidth).attr('dy', -5).attr('fill', 'black').attr('font-weight', 'bold').attr('text-anchor', 'end').attr('display', seriesIndex === 0 || repeatAxesLabels ? null : 'none').text(d => {
          return mapping['size'].value ? `${mapping['size'].value} [${mapping.size.config.aggregation}]` : '';
        }));
        selection.append('g').attr('id', 'yAxis').attr('transform', 'translate(' + sizeScale(0) + ',0)').call(axisLeft(barScale).tickSizeOuter(0)).call(g => g.append('text').attr('font-family', 'Arial, sans-serif').attr('font-size', 10).attr('x', 4).attr('fill', 'black').attr('font-weight', 'bold').attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').attr('display', seriesIndex === 0 || repeatAxesLabels ? null : 'none').text(mapping['bars'].value));
      } else {
        selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + sizeScale(0) + ')').call(axisBottom(barScale).tickSizeOuter(0)).call(g => g.append('text').attr('x', seriesWidth).attr('y', -4).attr('text-anchor', 'end').attr('display', seriesIndex === 0 || repeatAxesLabels ? null : 'none').text(mapping['bars'].value).styles(styles.axisLabel));
        selection.append('g').attr('id', 'yAxis').call(axisLeft(sizeScale)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').attr('display', seriesIndex === 0 || repeatAxesLabels ? null : 'none').text(d => {
          return mapping['size'].value ? `${mapping['size'].value} [${mapping.size.config.aggregation}]` : '';
        }).styles(styles.axisLabel));
      }

      if (showSeriesLabels) {
        select(this).append('text').text(d => d.data[0]).attr('y', 4).attr('x', 4).styles(styles.seriesLabel);
      }
    }); // add legend

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$c = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    barsOrientation: {
      type: 'text',
      label: 'Orientation des barres',
      group: 'chart',
      options: [{
        label: 'Vertically',
        value: 'vertical'
      }, {
        label: 'Horizontally',
        value: 'horizontal'
      }],
      default: 'vertical'
    },
    sortBarsBy: {
      type: 'text',
      label: 'Trier les barres par',
      group: 'chart',
      options: [{
        label: 'Size (descending)',
        value: 'totalDescending'
      }, {
        label: 'Size (ascending)',
        value: 'totalAscending'
      }, {
        label: 'Name',
        value: 'name'
      }, {
        label: 'Original',
        value: 'original'
      }],
      default: 'name'
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Total value (descending)'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    repeatAxesLabels: {
      type: 'boolean',
      label: 'Repeat axis labels for each series',
      default: false,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: false,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var barchart = {
    metadata: metadata$c,
    dimensions: dimensions$c,
    mapData: mapData$c,
    render: render$c,
    visualOptions: visualOptions$c,
    styles: styles$1
  };

  var img$o = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2306c26c%3b %7d .cls-2 %7b fill: %2395e5c0%3b %7d %3c/style%3e %3c/defs%3e %3cpolygon class='cls-1' points='9.185 9.685 7.5 8 5.815 9.685 5.815 11.115 7.003 9.927 7.003 48 7.997 48 7.997 9.927 9.185 11.115 9.185 9.685'/%3e %3crect class='cls-2' x='21' y='29' width='3' height='19'/%3e %3crect class='cls-2' x='31' y='22.9521' width='3' height='25.0479'/%3e %3crect class='cls-2' x='41' y='34' width='3' height='14'/%3e %3crect class='cls-2' x='11' y='36' width='3' height='12'/%3e %3crect class='cls-1' x='15' y='31' width='3' height='17'/%3e %3crect class='cls-1' x='24.9219' y='35.9219' width='3.1563' height='12.1563'/%3e %3crect class='cls-1' x='34.9219' y='20.9219' width='3.1563' height='27.1563'/%3e %3crect class='cls-1' x='44.9219' y='30.9219' width='3.1563' height='17.1563'/%3e%3c/svg%3e";

  var img$p = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: %234696b3%3b %7d .cls-3 %7b fill: %23f88e53%3b %7d .cls-4 %7b fill: %23d5ee9f%3b %7d .cls-5 %7b fill: none%3b stroke: black%3b %7d .cls-6 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-7 %7b letter-spacing: -0.0737em%3b %7d %3c/style%3e %3c/defs%3e %3crect id='backgorund' class='cls-1' width='320' height='160'/%3e %3cg id='viz'%3e %3cg%3e %3cg%3e %3crect id='undefined_-_Czech' data-name='undefined - Czech' class='cls-2' x='25.9251' y='53.6185' width='13.6608' height='89.3815'/%3e %3crect id='undefined_-_English' data-name='undefined - English' class='cls-3' x='40.5641' y='56.2723' width='13.6608' height='86.7277'/%3e %3crect id='undefined_-_Italian' data-name='undefined - Italian' class='cls-4' x='55.2031' y='18.2692' width='13.6608' height='124.7308'/%3e %3crect id='undefined_-_Czech-2' data-name='undefined - Czech' class='cls-2' x='74.7672' y='62.7477' width='13.6608' height='80.2523'/%3e %3crect id='undefined_-_English-2' data-name='undefined - English' class='cls-3' x='89.4063' y='8.1846' width='13.6608' height='134.8154'/%3e %3crect id='undefined_-_Italian-2' data-name='undefined - Italian' class='cls-4' x='104.0453' y='17.8446' width='13.6608' height='125.1554'/%3e %3crect id='undefined_-_Czech-3' data-name='undefined - Czech' class='cls-2' x='123.6094' y='106.0585' width='13.6608' height='36.9415'/%3e %3crect id='undefined_-_English-3' data-name='undefined - English' class='cls-3' x='138.2485' y='97.8846' width='13.6608' height='45.1154'/%3e %3crect id='undefined_-_Italian-3' data-name='undefined - Italian' class='cls-4' x='152.8875' y='103.2985' width='13.6608' height='39.7015'/%3e %3crect id='undefined_-_Czech-4' data-name='undefined - Czech' class='cls-2' x='172.4516' y='134.2954' width='13.6608' height='8.7046'/%3e %3crect id='undefined_-_English-4' data-name='undefined - English' class='cls-3' x='187.0907' y='127.1831' width='13.6608' height='15.8169'/%3e %3crect id='undefined_-_Italian-4' data-name='undefined - Italian' class='cls-4' x='201.7297' y='133.1277' width='13.6608' height='9.8723'/%3e %3crect id='undefined_-_Czech-5' data-name='undefined - Czech' class='cls-2' x='221.2938' y='135.1446' width='13.6608' height='7.8554'/%3e %3crect id='undefined_-_English-5' data-name='undefined - English' class='cls-3' x='235.9329' y='113.4892' width='13.6608' height='29.5108'/%3e %3crect id='undefined_-_Italian-5' data-name='undefined - Italian' class='cls-4' x='250.5719' y='95.2308' width='13.6608' height='47.7692'/%3e %3crect id='undefined_-_Czech-6' data-name='undefined - Czech' class='cls-2' x='270.136' y='142.1508' width='13.6608' height='0.8492'/%3e %3crect id='undefined_-_English-6' data-name='undefined - English' class='cls-3' x='284.7751' y='119.3277' width='13.6608' height='23.6723'/%3e %3crect id='undefined_-_Italian-6' data-name='undefined - Italian' class='cls-4' x='299.4141' y='130.7923' width='13.6608' height='12.2077'/%3e %3c/g%3e %3cg id='xAxis'%3e %3cpath class='cls-5' d='M21.5%2c143.5h297'/%3e %3cg%3e %3cline class='cls-5' x1='47.3945' y1='143' x2='47.3945' y2='149'/%3e %3ctext class='cls-6' transform='translate(44.6138 159.1)'%3ea%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='96.2367' y1='143' x2='96.2367' y2='149'/%3e %3ctext class='cls-6' transform='translate(93.4559 159.1)'%3ee%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='145.0789' y1='143' x2='145.0789' y2='149'/%3e %3ctext class='cls-6' transform='translate(142.2982 159.1)'%3ed%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='193.9211' y1='143' x2='193.9211' y2='149'/%3e %3ctext class='cls-6' transform='translate(191.1403 159.1)'%3eb%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='242.7633' y1='143' x2='242.7633' y2='149'/%3e %3ctext class='cls-6' transform='translate(240.2633 159.1)'%3ec%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='291.6055' y1='143' x2='291.6055' y2='149'/%3e %3ctext class='cls-6' transform='translate(290.2163 159.1)'%3ef%3c/text%3e %3c/g%3e %3c/g%3e %3cg id='yAxis'%3e %3cpath class='cls-5' d='M21.5%2c143.5V5.5'/%3e %3cg%3e %3cline class='cls-5' x1='21' y1='143.5' x2='15' y2='143.5'/%3e %3ctext class='cls-6' transform='translate(6.4385 146.7)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='132.8846' x2='15' y2='132.8846'/%3e %3ctext class='cls-6' transform='translate(6.4385 136.0846)'%3e1%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='111.6538' x2='15' y2='111.6538'/%3e %3ctext class='cls-6' transform='translate(6.4385 114.8539)'%3e3%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='90.4231' x2='15' y2='90.4231'/%3e %3ctext class='cls-6' transform='translate(6.4385 93.6231)'%3e5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='69.1923' x2='15' y2='69.1923'/%3e %3ctext class='cls-6' transform='translate(6.4385 72.3923)'%3e7%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='47.9615' x2='15' y2='47.9615'/%3e %3ctext class='cls-6' transform='translate(6.4385 51.1615)'%3e9%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='26.7308' x2='15' y2='26.7308'/%3e %3ctext class='cls-6' transform='translate(1.6143 29.9308)'%3e%3ctspan class='cls-7'%3e1%3c/tspan%3e%3ctspan x='4.8242' y='0'%3e1%3c/tspan%3e%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-5' x1='21' y1='5.5' x2='15' y2='5.5'/%3e %3ctext class='cls-6' transform='translate(0.877 8.7)'%3e13%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$d = {
    name: 'Histogramme groupées',
    thumbnail: img$p,
    icon: img$o,
    id: 'rawgraphs.barchartmultiset',
    categories: ['correlations', 'proportions'],
    description: 'Il affiche plusieurs dimensions quantitatives liées aux catégories. les barres sont regroupées visuellement en ensembles selon la dimension catégorielle, chaque barre représente une dimension quantitative, représentée sur sa hauteur.' // code: "https://github.com/rawgraphs/raw",
    // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$d = [{
    id: 'groups',
    name: 'Ensembles',
    validTypes: ['number', 'string', 'date'],
    required: true,
    operation: 'get'
  }, {
    id: 'bars',
    name: 'Taille',
    validTypes: ['number'],
    required: true,
    multiple: true,
    operation: 'get',
    aggregation: true,
    aggregationDefault: {
      number: 'sum'
    }
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$d = function (data, mapping, dataTypes, dimensions) {
    // as we are working on a multiple dimension (bars), `getDimensionAggregator` will return an array of aggregator functions
    // the order of aggregators is the same as the value of the mapping
    const barsAggregators = getDimensionAggregator('bars', mapping, dataTypes, dimensions);
    let results = [];
    rollups(data, v => {
      // @TODO use the spread operator to creat groups on mapping values
      // for every dimension in the bars field, create an item
      mapping.bars.value.forEach((barName, i) => {
        //getting values for aggregation
        const valuesForSize = v.map(x => x[barName]); //getting i-th aggregator

        const aggregator = barsAggregators[i]; // create the item

        const item = {
          series: v[0][mapping.series.value],
          // get the first one since it's grouped
          groups: v[0][mapping.groups.value],
          // get the first one since it's grouped
          bars: barName,
          size: aggregator(valuesForSize)
        };
        results.push(item);
      });
    }, d => d[mapping.series.value], // series grouping
    d => d[mapping.groups.value].toString() // stacks grouping. toString() to enable grouping on dates
    );
    return results;
  };

  function render$d(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      barsPadding,
      setsPadding,
      SortXAxisBy,
      // series options
      columnsNumber,
      useSameScale,
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; // create nest structure

    const nestedData = rollups(data, v => v, d => d.series).map(d => ({
      data: d,
      totalSize: sum(d[1], d => d.size)
    })); // sort series

    nestedData.sort((a, b) => {
      return {
        valueDescending: descending(a.totalSize, b.totalSize),
        valueAscending: ascending(a.totalSize, b.totalSize),
        name: ascending(a.data[0], b.data[0])
      }[sortSeriesBy];
    }); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(columnsNumber);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz');
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')'); // domains

    let originalDomain = extent(data, d => d.size);
    let sizeDomain = originalDomain[0] > 0 ? [0, originalDomain[1]] : originalDomain; // sets (x axis) sorting functions

    const stacksSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a[1], b[1]);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a[1], b[1]);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      },
      Original: function (a, b) {
        return true;
      }
    }; // sets (x axis) domain

    const setsDomain = rollups(data, v => sum(v, d => d.size), d => d.groups).sort(stacksSortings[SortXAxisBy]).map(d => d[0]);
    const barsDomain = [...new Set(data.map(d => d.bars))]; // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }

    series.each(function (d, serieIndex) {
      // make a local selection for each serie
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // compute each serie width and height

      const serieWidth = d.width - margin.right - margin.left;
      const serieHeight = d.height - margin.top - margin.bottom; // scales

      const setScale = band().range([0, serieWidth]).domain(setsDomain).padding(setsPadding / (serieWidth / setsDomain.length) //convert padding from px to percentage
      );
      const barScale = band().range([0, setScale.bandwidth()]).domain(barsDomain).padding(barsPadding / (setScale.bandwidth() / barsDomain.length) //convert padding from px to percentage
      );
      const localDomain = extent(d.data[1], e => e.size);
      const sizeScale = linear$2().domain(useSameScale ? sizeDomain : localDomain).nice().range([serieHeight, 0]); // check if padding is too high and leave no space for bars

      if (setsPadding * setsDomain.length + barsPadding * barsDomain.length * setsDomain.length >= serieWidth) {
        throw new Error('Paddings are too high, decrase them in the "chart" options panel');
      }

      serieWidth / setScale.domain() / barScale.domain();
      selection.append('g').attr('class', 'bars').selectAll('rect').data(d => d.data[1]).join('rect').attr('id', d => d.series + ' - ' + d.bars).attr('x', d => setScale(d.groups) + barScale(d.bars)).attr('y', d => sizeScale(Math.max(0, d.size))).attr('height', d => Math.abs(sizeScale(d.size) - sizeScale(0))).attr('width', barScale.bandwidth()).attr('fill', d => colorScale(d.bars));
      selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + sizeScale(0) + ')').call(axisBottom(setScale).tickSizeOuter(0));
      selection.append('g').attr('id', 'yAxis').call(axisLeft(sizeScale).tickSizeOuter(0));

      if (showSeriesLabels) {
        select(this).append('text').attr('x', 4).attr('y', 4).text(d => d.data[0]).styles(styles.seriesLabel);
      } // add the x axis titles


      selection.append('text').attr('y', sizeScale(0) - 4).attr('x', serieWidth).attr('text-anchor', 'end').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').styles(styles.axisLabel).text('Sets'); // add the y axis titles

      selection.append('text').attr('y', 0).attr('x', 4).attr('dominant-baseline', 'hanging').attr('text-anchor', 'start').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').styles(styles.axisLabel).text('Value');
    }); // add legend

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);
      chartLegend.addColor('Colors', colorScale);
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$d = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    setsPadding: {
      type: 'number',
      label: 'Padding between sets',
      default: 4,
      group: 'chart'
    },
    barsPadding: {
      type: 'number',
      label: 'Padding between bars',
      default: 1,
      group: 'chart'
    },
    SortXAxisBy: {
      type: 'text',
      label: 'Sort X axis by',
      group: 'chart',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Name'
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: [{
        label: 'Total value (descending)',
        value: 'valueDescending'
      }, {
        label: 'Total value (ascending)',
        value: 'valueAscending'
      }, {
        label: 'Name',
        value: 'name'
      }, {
        label: 'Original',
        value: 'none'
      }],
      default: 'valueDescending'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    repeatAxesLabels: {
      type: 'boolean',
      label: 'Repeat axis labels for each series',
      default: false,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: true,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'bars',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var barchartmultiset = {
    metadata: metadata$d,
    dimensions: dimensions$d,
    mapData: mapData$d,
    render: render$d,
    visualOptions: visualOptions$d,
    styles: styles$1
  };

  var img$q = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2306c26c%3b %7d .cls-2 %7b fill: %2395e5c0%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3crect class='cls-1' x='7.0029' y='9.1357' width='0.9941' height='38.8643'/%3e %3cpolygon class='cls-1' points='5.815 11.115 7.5 9.43 9.185 11.115 9.185 9.685 7.5 8 5.815 9.685 5.815 11.115'/%3e %3c/g%3e %3crect class='cls-1' x='21' y='36' width='7' height='12'/%3e %3crect class='cls-1' x='31' y='38' width='7' height='10'/%3e %3crect class='cls-1' x='41' y='36' width='7' height='12'/%3e %3crect class='cls-1' x='11' y='40' width='7' height='8'/%3e %3crect class='cls-2' x='11' y='34' width='7' height='5'/%3e %3crect class='cls-2' x='21' y='27' width='7' height='8'/%3e %3crect class='cls-2' x='31' y='22' width='7' height='15'/%3e %3crect class='cls-2' x='41' y='32' width='7' height='3'/%3e%3c/svg%3e";

  var img$r = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 160'%3e%3cdefs%3e%3cstyle%3e.cls-1%7bfill:white%3b%7d.cls-2%7bfill:%2369bda9%3b%7d.cls-3%7bfill:%235e4fa2%3b%7d.cls-4%7bfill:%239e0142%3b%7d.cls-5%7bfill:%23fedd8d%3b%7d.cls-6%7bfill:%23f0704a%3b%7d.cls-7%7bfill:%23e0f3a1%3b%7d.cls-8%7bfill:none%3bstroke:black%3b%7d.cls-9%7bisolation:isolate%3bfont-size:10px%3bfont-family:Helvetica%3b%7d%3c/style%3e%3c/defs%3e%3crect id='backgorund' class='cls-1' width='320' height='160'/%3e%3cg id='viz'%3e%3cg id='Tape'%3e%3crect class='cls-2' x='29' y='119.6' width='31.11' height='20.4'/%3e%3crect class='cls-2' x='61.11' y='116.51' width='31.11' height='23.49'/%3e%3crect class='cls-2' x='93.22' y='104.76' width='31.11' height='35.24'/%3e%3crect class='cls-2' x='125.33' y='94.87' width='31.11' height='45.13'/%3e%3crect class='cls-2' x='157.44' y='113.42' width='31.11' height='26.58'/%3e%3crect class='cls-2' x='189.55' y='134.44' width='31.11' height='5.56'/%3e%3c/g%3e%3cg id='Vinyl'%3e%3crect class='cls-3' x='29' y='69.53' width='31.11' height='50.07'/%3e%3crect class='cls-3' x='61.11' y='69.53' width='31.11' height='46.98'/%3e%3crect class='cls-3' x='93.22' y='81.89' width='31.11' height='22.87'/%3e%3crect class='cls-3' x='125.33' y='92.4' width='31.11' height='2.47'/%3e%3crect class='cls-3' x='157.44' y='112.8' width='31.11' height='0.62'/%3e%3crect class='cls-3' x='253.78' y='139.38' width='31.11' height='0.62'/%3e%3crect class='cls-3' x='285.89' y='137.53' width='31.11' height='2.47'/%3e%3c/g%3e%3cg id='Disc'%3e%3crect class='cls-4' x='93.22' y='76.33' width='31.11' height='5.56'/%3e%3crect class='cls-4' x='125.33' y='50.36' width='31.11' height='42.04'/%3e%3crect class='cls-4' x='157.44' y='14.51' width='31.11' height='98.29'/%3e%3crect class='cls-4' x='189.55' y='12.04' width='31.11' height='122.4'/%3e%3crect class='cls-4' x='221.67' y='54.69' width='31.11' height='85.31'/%3e%3crect class='cls-4' x='253.78' y='114.65' width='31.11' height='24.73'/%3e%3crect class='cls-4' x='285.89' y='127.64' width='31.11' height='9.89'/%3e%3c/g%3e%3cg id='Other'%3e%3crect class='cls-5' x='125.33' y='48.51' width='31.11' height='1.85'/%3e%3crect class='cls-5' x='157.44' y='12.04' width='31.11' height='2.47'/%3e%3crect class='cls-5' x='189.55' y='9.56' width='31.11' height='2.47'/%3e%3crect class='cls-5' x='221.67' y='49.75' width='31.11' height='4.95'/%3e%3crect class='cls-5' x='253.78' y='112.18' width='31.11' height='2.47'/%3e%3crect class='cls-5' x='285.89' y='125.78' width='31.11' height='1.85'/%3e%3c/g%3e%3cg id='Download'%3e%3crect class='cls-6' x='221.67' y='41.71' width='31.11' height='8.04'/%3e%3crect class='cls-6' x='253.78' y='93.02' width='31.11' height='19.16'/%3e%3crect class='cls-6' x='285.89' y='110.33' width='31.11' height='15.45'/%3e%3c/g%3e%3cg id='Streaming'%3e%3crect class='cls-7' x='221.67' y='40.47' width='31.11' height='1.24'/%3e%3crect class='cls-7' x='253.78' y='89.93' width='31.11' height='3.09'/%3e%3crect class='cls-7' x='285.89' y='94.87' width='31.11' height='15.45'/%3e%3c/g%3e%3cg id='xAxis'%3e%3cpath class='cls-8' d='M28.5%2c140.5h290'/%3e%3cline class='cls-8' x1='44.55' y1='140' x2='44.55' y2='146'/%3e%3ctext class='cls-9' transform='translate(41.77 156.1)'%3ea%3c/text%3e%3cline class='cls-8' x1='76.67' y1='140' x2='76.67' y2='146'/%3e%3ctext class='cls-9' transform='translate(73.88 156.1)'%3eb%3c/text%3e%3cline class='cls-8' x1='108.78' y1='140' x2='108.78' y2='146'/%3e%3ctext class='cls-9' transform='translate(106.28 156.1)'%3ec%3c/text%3e%3cline class='cls-8' x1='140.89' y1='140' x2='140.89' y2='146'/%3e%3ctext class='cls-9' transform='translate(138.11 156.1)'%3ed%3c/text%3e%3cline class='cls-8' x1='173' y1='140' x2='173' y2='146'/%3e%3ctext class='cls-9' transform='translate(170.22 156.1)'%3ee%3c/text%3e%3cline class='cls-8' x1='205.11' y1='140' x2='205.11' y2='146'/%3e%3ctext class='cls-9' transform='translate(203.72 156.1)'%3ef%3c/text%3e%3cline class='cls-8' x1='237.22' y1='140' x2='237.22' y2='146'/%3e%3ctext class='cls-9' transform='translate(234.44 156.1)'%3eg%3c/text%3e%3cline class='cls-8' x1='269.33' y1='140' x2='269.33' y2='146'/%3e%3ctext class='cls-9' transform='translate(266.55 156.1)'%3eh%3c/text%3e%3cline class='cls-8' x1='301.45' y1='140' x2='301.45' y2='146'/%3e%3ctext class='cls-9' transform='translate(300.34 156.1)'%3ei%3c/text%3e%3c/g%3e%3cg id='yAxis'%3e%3cpath class='cls-8' d='M28.5%2c140.5V4.5'/%3e%3cline class='cls-8' x1='28' y1='140.5' x2='22' y2='140.5'/%3e%3ctext class='cls-9' transform='translate(13.44 143.7)'%3e0%3c/text%3e%3cline class='cls-8' x1='28' y1='128.14' x2='22' y2='128.14'/%3e%3ctext class='cls-9' transform='translate(7.88 131.34)'%3e20%3c/text%3e%3cline class='cls-8' x1='28' y1='115.77' x2='22' y2='115.77'/%3e%3ctext class='cls-9' transform='translate(7.88 118.97)'%3e40%3c/text%3e%3cline class='cls-8' x1='28' y1='103.41' x2='22' y2='103.41'/%3e%3ctext class='cls-9' transform='translate(7.88 106.61)'%3e60%3c/text%3e%3cline class='cls-8' x1='28' y1='91.05' x2='22' y2='91.05'/%3e%3ctext class='cls-9' transform='translate(7.88 94.25)'%3e80%3c/text%3e%3cline class='cls-8' x1='28' y1='78.68' x2='22' y2='78.68'/%3e%3ctext class='cls-9' transform='translate(2.32 81.88)'%3e100%3c/text%3e%3cline class='cls-8' x1='28' y1='66.32' x2='22' y2='66.32'/%3e%3ctext class='cls-9' transform='translate(2.32 69.52)'%3e120%3c/text%3e%3cline class='cls-8' x1='28' y1='53.95' x2='22' y2='53.95'/%3e%3ctext class='cls-9' transform='translate(2.32 57.15)'%3e140%3c/text%3e%3cline class='cls-8' x1='28' y1='41.59' x2='22' y2='41.59'/%3e%3ctext class='cls-9' transform='translate(2.32 44.79)'%3e160%3c/text%3e%3cline class='cls-8' x1='28' y1='29.23' x2='22' y2='29.23'/%3e%3ctext class='cls-9' transform='translate(2.32 32.43)'%3e180%3c/text%3e%3cline class='cls-8' x1='28' y1='16.86' x2='22' y2='16.86'/%3e%3ctext class='cls-9' transform='translate(2.32 20.06)'%3e200%3c/text%3e%3cline class='cls-8' x1='28' y1='4.5' x2='22' y2='4.5'/%3e%3ctext class='cls-9' transform='translate(2.32 7.7)'%3e220%3c/text%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

  const metadata$e = {
    name: 'Histogramme empilées',
    id: 'rawgraphs.barchartstacked',
    thumbnail: img$r,
    icon: img$q,
    categories: ['correlations', 'proportions'],
    description: 'Il affiche plusieurs dimensions quantitatives liées aux catégories. les barres sont empilées visuellement selon la dimension catégorielle, chaque barre représente une dimension quantitative, représentée sur sa hauteur.' // code: "https://github.com/rawgraphs/raw",
    // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$e = [{
    id: 'stacks',
    name: 'Axe X',
    validTypes: ['number', 'string', 'date'],
    required: true,
    operation: 'get'
  }, {
    id: 'bars',
    name: 'Taille',
    validTypes: ['number'],
    required: true,
    multiple: true,
    operation: 'get',
    aggregation: true,
    aggregationDefault: {
      number: 'sum'
    }
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$e = function (data, mapping, dataTypes, dimensions) {
    // as we are working on a multiple dimension (bars), `getDimensionAggregator` will return an array of aggregator functions
    // the order of aggregators is the same as the value of the mapping
    const barsAggregators = getDimensionAggregator('bars', mapping, dataTypes, dimensions);
    let results = [];
    rollups(data, v => {
      // @TODO use the spread operator to creat groups on mapping values
      // for every dimension in the bars field, create an item
      mapping.bars.value.forEach((barName, i) => {
        //getting values for aggregation
        const valuesForSize = v.map(x => x[barName]); //getting i-th aggregator

        const aggregator = barsAggregators[i]; // create the item

        const item = {
          series: v[0][mapping.series.value],
          // get the first one since it's grouped
          stacks: v[0][mapping.stacks.value],
          // get the first one since it's grouped
          bars: barName,
          size: aggregator(valuesForSize)
        };
        results.push(item);
      });
    }, d => d[mapping.series.value], // series grouping
    d => d[mapping.stacks.value].toString() // stacks grouping. toString() to enable grouping on dates
    );
    return results;
  };

  function render$e(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      stacksOrder,
      stacksPadding,
      SortXAxisBy,
      // series options
      columnsNumber,
      useSameScale,
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid = true,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; //check if there are negative values, in case throw error

    data.forEach(d => {
      if (d.size < 0) {
        throw new Error('Values cannot be negative');
      }
    }); // create nest structure

    const nestedData = rollups(data, v => v, d => d.series).map(d => ({
      data: d,
      totalSize: sum(d[1], d => d.size)
    })); // sort series

    nestedData.sort((a, b) => {
      return {
        valueDescending: descending(a.totalSize, b.totalSize),
        valueAscending: ascending(a.totalSize, b.totalSize),
        name: ascending(a.data[0], b.data[0])
      }[sortSeriesBy];
    }); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(columnsNumber);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz');
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')'); // domains
    // sum all values for each serie / stack

    const scaleRollup = rollups(data, v => sum(v, d => d.size), d => d.stacks + '_' + d.series).map(d => d[1]);
    let sizeDomain = [0, max(scaleRollup)]; // stacks (x axis) sorting functions

    const stacksSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a[1], b[1]);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a[1], b[1]);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      },
      Original: function (a, b) {
        return true;
      }
    }; // stacks (x axis) domain

    const stacksDomain = rollups(data, v => sum(v, d => d.size), d => d.stacks).sort(stacksSortings[SortXAxisBy]).map(d => d[0]);
    const barsDomain = [...new Set(data.map(d => d.bars))]; // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }

    series.each(function (d, serieIndex) {
      // make a local selection for each serie
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // compute each serie width and height

      const serieWidth = d.width - margin.right - margin.left;
      const serieHeight = d.height - margin.top - margin.bottom; //prepare data for stack

      let localStack = Array.from(rollup(d.data[1], ([e]) => e, e => e.stacks, e => e.bars)); // creaet an object with ordering methods

      const orderings = {
        Earliest: 'stackOrderAppearance',
        Ascending: 'stackOrderAscending',
        Descending: 'stackOrderDescending',
        'Inside out': 'stackOrderInsideOut',
        None: 'stackOrderNone',
        Reverse: 'stackOrderReverse'
      }; // create the stack
      // define the funciton to retrieve the value
      // inspired by https://observablehq.com/@stevndegwa/stack-chart

      let stack$1 = stack().keys(barsDomain).value((data, key) => data[1].has(key) ? data[1].get(key).size : 0).order(d3[orderings[stacksOrder]]);
      let stackedData = stack$1(localStack); // check if padding is too high and leave no space for bars

      if (stacksPadding * stacksDomain.length > serieWidth) {
        throw new Error('Padding is too high, decrase it in the panel "chart" > "Padding"');
      } // scales


      const stacksScale = band().range([0, serieWidth]).domain(stacksDomain).padding(stacksPadding / (serieWidth / stacksDomain.length) //convert padding from px to percentage
      );
      let localDomain = [0, max(rollups(d.data[1], v => sum(v, d => d.size), d => d.stacks).map(d => d[1]))];
      const sizeScale = linear$2().domain(useSameScale ? sizeDomain : localDomain).nice().range([serieHeight, 0]);
      selection.selectAll('g').data(stackedData).join('g').attr('id', d => d.key).attr('fill', d => colorScale(d.key)).selectAll('rect').data(d => d).join('rect').attr('x', d => stacksScale(d.data[0])).attr('y', d => sizeScale(d[1])).attr('width', stacksScale.bandwidth()).attr('height', d => serieHeight - sizeScale(d[1] - d[0]));
      selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + sizeScale(0) + ')').call(axisBottom(stacksScale).tickSizeOuter(0));
      selection.append('g').attr('id', 'yAxis').call(axisLeft(sizeScale).tickSizeOuter(0));

      if (showSeriesLabels) {
        select(this).append('text').attr('x', 4).attr('y', 4).text(d => d.data[0]).styles(styles.seriesLabel);
      } // add the x axis titles


      selection.append('text').attr('y', serieHeight - 4).attr('x', serieWidth).attr('text-anchor', 'end').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping.stacks.value).styles(styles.axisLabel);
    }); // add legend

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);
      chartLegend.addColor('Colors', colorScale);
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$e = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    stacksPadding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    stacksOrder: {
      type: 'text',
      label: 'Sort stacks by',
      group: 'chart',
      options: ['Earliest', 'Ascending', 'Descending', 'None', 'Reverse'],
      default: 'None'
    },
    SortXAxisBy: {
      type: 'text',
      label: 'Sort X axis by',
      group: 'chart',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Name'
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: [{
        label: 'Total value (descending)',
        value: 'valueDescending'
      }, {
        label: 'Total value (ascending)',
        value: 'valueAscending'
      }, {
        label: 'Name',
        value: 'name'
      }, {
        label: 'Original',
        value: 'none'
      }],
      default: 'valueDescending'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    repeatAxesLabels: {
      type: 'boolean',
      label: 'Repeat axis labels for each series',
      default: false,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: true,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'bars',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var barchartstacked = {
    metadata: metadata$e,
    dimensions: dimensions$e,
    mapData: mapData$e,
    render: render$e,
    visualOptions: visualOptions$e,
    styles: styles$1
  };

  var img$s = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpolygon class='cls-1' points='16.863 25.576 7.179 23.448 14.631 46.387 20.616 37.13 16.863 25.576'/%3e %3cpolygon class='cls-1' points='34.039 25.453 47.459 22.504 28 8.363 28 17.532 34.039 25.453'/%3e %3cpolygon class='cls-1' points='37.474 41.908 40.369 46.387 47.821 23.448 34.42 26.393 37.474 41.908'/%3e %3cpolygon class='cls-1' points='27 17.447 27 8.363 7.541 22.504 17.137 24.613 27 17.447'/%3e %3cpolygon class='cls-1' points='21.379 37.791 15.426 47 39.574 47 36.682 42.525 21.379 37.791'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='36.009 39.642 33.443 26.608 28.311 27.736 36.009 39.642'/%3e %3cpolygon class='cls-2' points='17.995 25.825 21.316 36.047 26.689 27.736 17.995 25.825'/%3e %3cpolygon class='cls-2' points='27 18.682 18.444 24.9 27 26.781 27 18.682'/%3e %3cpolygon class='cls-2' points='21.943 36.918 35.835 41.216 27.5 28.323 21.943 36.918'/%3e %3cpolygon class='cls-2' points='28 26.781 32.962 25.69 28 19.182 28 26.781'/%3e %3c/g%3e%3c/svg%3e";

  var img$t = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-2 %7b fill: none%3b %7d .cls-1 %7b stroke: %23d3d3d3%3b stroke-width: 0.5px%3b %7d .cls-2 %7b stroke: black%3b %7d .cls-3%2c .cls-4%2c .cls-5 %7b isolation: isolate%3b %7d .cls-3%2c .cls-4 %7b font-size: 12px%3b font-family: ArialMT%2c Arial%3b %7d .cls-3 %7b letter-spacing: -0.05518em%3b %7d .cls-5 %7b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-6%2c .cls-7 %7b fill: %2369bda9%3b %7d .cls-10%2c .cls-12%2c .cls-6%2c .cls-8 %7b fill-opacity: 0%3b stroke-width: 2px%3b %7d .cls-6 %7b stroke: %2369bda9%3b %7d .cls-8%2c .cls-9 %7b fill: %239e0142%3b %7d .cls-8 %7b stroke: %239e0142%3b %7d .cls-10%2c .cls-11 %7b fill: %23fedd8d%3b %7d .cls-10 %7b stroke: %23fedd8d%3b %7d .cls-12%2c .cls-13 %7b fill: %235e4fa2%3b %7d .cls-12 %7b stroke: %235e4fa2%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cg id='axes'%3e %3ccircle id='_10' data-name='10' class='cls-1' cx='159.99951' cy='87.59481' r='80'/%3e %3ccircle id='_8' data-name='8' class='cls-1' cx='159.99951' cy='87.59481' r='64'/%3e %3ccircle id='_6' data-name='6' class='cls-1' cx='159.99951' cy='87.59481' r='48'/%3e %3ccircle id='_4' data-name='4' class='cls-1' cx='159.99951' cy='87.59481' r='32'/%3e %3ccircle id='_2' data-name='2' class='cls-1' cx='159.99951' cy='87.59481' r='16'/%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='87.59481' x2='159.99951' y2='7.59481'/%3e %3ctext class='cls-3' transform='translate(164.15332 9.54694)'%3eA%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='87.59481' x2='236.08403' y2='62.87345'/%3e %3ctext class='cls-4' transform='translate(241.59277 63.98328)'%3eB%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='87.59481' x2='207.02233' y2='152.31617'/%3e %3ctext class='cls-4' transform='translate(211.25854 159.99991)'%3eC%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='87.59481' x2='112.97669' y2='152.31617'/%3e %3ctext class='cls-4' transform='translate(101.13208 160.09991)'%3eD%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='87.59481' x2='83.91499' y2='62.87345'/%3e %3ctext class='cls-4' transform='translate(70.40259 63.98328)'%3eE%3c/text%3e %3c/g%3e %3cg id='y_axis' data-name='y axis'%3e %3cpath class='cls-2' d='M153.99951%2c8.09481h6.5v80h-6.5'/%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='8.09481' x2='153.99951' y2='8.09481'/%3e %3ctext class='cls-5' transform='translate(139.87646 11.2948)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='24.09481' x2='153.99951' y2='24.09481'/%3e %3ctext class='cls-5' transform='translate(145.43799 27.2948)'%3e8%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='40.09481' x2='153.99951' y2='40.09481'/%3e %3ctext class='cls-5' transform='translate(145.43799 43.2948)'%3e6%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='56.09481' x2='153.99951' y2='56.09481'/%3e %3ctext class='cls-5' transform='translate(145.43799 59.2948)'%3e4%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='72.09481' x2='153.99951' y2='72.09481'/%3e %3ctext class='cls-5' transform='translate(145.43799 75.2948)'%3e2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-2' x1='159.99951' y1='88.09481' x2='153.99951' y2='88.09481'/%3e %3ctext class='cls-5' transform='translate(145.43799 91.2948)'%3e0%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='radars'%3e %3cg id='_4-2' data-name='4'%3e %3cpath class='cls-6' d='M213.25868%2c70.28986c6.26971%2c19.29618-.82122%2c56.22862-15.64091%2c69.082-15.76947%2c13.67717-63.52448%2c18.39783-79.9388%2c6.47213S91.53251%2c88.34569%2c99.13189%2c67.81772c7.36046-19.88255%2c41.58961-45.10552%2c60.86762-44.22291%2c18.705.85637%2c46.98946%2c27.39887%2c53.25917%2c46.69505'/%3e %3cg id='dots'%3e %3ccircle class='cls-7' cx='159.99951' cy='23.59481' r='2'/%3e %3ccircle class='cls-7' cx='213.25868' cy='70.28986' r='2'/%3e %3ccircle class='cls-7' cx='197.61777' cy='139.3719' r='2'/%3e %3ccircle class='cls-7' cx='117.67897' cy='145.84403' r='2'/%3e %3ccircle class='cls-7' cx='99.13189' cy='67.81772' r='2'/%3e %3c/g%3e %3c/g%3e %3cg id='_0' data-name='0'%3e %3cpath class='cls-8' d='M175.21642%2c82.65054c4.70228%2c14.47213%2c18.807%2c34.17211%2c12.99678%2c43.77709-7.04258%2c11.64228-57.76716%2c21.429-65.83194%2c12.94427-7.69079-8.09128%2c7.84517-41.72836%2c14.7929-59.1935%2c6.06938-15.25715%2c16.46625-41.13379%2c22.82535-40.58359%2c6.2976.54488%2c10.51462%2c28.58359%2c15.21691%2c43.05573'/%3e %3cg id='dots-2' data-name='dots'%3e %3ccircle class='cls-9' cx='159.99951' cy='39.59481' r='2'/%3e %3ccircle class='cls-9' cx='175.21642' cy='82.65054' r='2'/%3e %3ccircle class='cls-9' cx='188.2132' cy='126.42763' r='2'/%3e %3ccircle class='cls-9' cx='122.38126' cy='139.3719' r='2'/%3e %3ccircle class='cls-9' cx='137.17416' cy='80.1784' r='2'/%3e %3c/g%3e %3c/g%3e %3cg id='_2-2' data-name='2'%3e %3cpath class='cls-10' d='M228.47558%2c65.34558c4.86633%2c6.38693-23.04318%2c53.14809-40.26238%2c61.08205-14.53515%2c6.69725-36.50441%2c1.90671-51.7251-6.47214-17.73077-9.76063-48.69983-49.12743-44.96465-54.60991%2c3.7683-5.5311%2c45.65071%2c22.24923%2c68.47606%2c22.24923s63.64841-28.58541%2c68.47607-22.24923'/%3e %3cg id='dots-3' data-name='dots'%3e %3ccircle class='cls-11' cx='159.99951' cy='87.59481' r='2'/%3e %3ccircle class='cls-11' cx='228.47558' cy='65.34558' r='2'/%3e %3ccircle class='cls-11' cx='188.2132' cy='126.42763' r='2'/%3e %3ccircle class='cls-11' cx='136.4881' cy='119.95549' r='2'/%3e %3ccircle class='cls-11' cx='91.52345' cy='65.34558' r='2'/%3e %3c/g%3e %3c/g%3e %3cg id='_5' data-name='5'%3e %3cpath class='cls-12' d='M159.99951%2c87.59481c5.64274%2c17.36656%2c44.27139%2c56.4683%2c42.32054%2c58.24922-1.90646%2c1.7404-34.82076-32.1427-51.7251-45.305-14.87958-11.58571-45.11623-22.77868-43.8546-30.24922%2c1.28479-7.6077%2c45.58707-20.537%2c53.25916-14.69505%2c5.83883%2c4.446-3.76182%2c20.42229%2c0%2c32'/%3e %3cg id='dots-4' data-name='dots'%3e %3ccircle class='cls-13' cx='159.99951' cy='55.59481' r='2'/%3e %3ccircle class='cls-13' cx='159.99951' cy='87.59481' r='2'/%3e %3ccircle class='cls-13' cx='202.32005' cy='145.84403' r='2'/%3e %3ccircle class='cls-13' cx='150.59495' cy='100.53908' r='2'/%3e %3ccircle class='cls-13' cx='106.74035' cy='70.28986' r='2'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$f = {
    name: 'Diagramme en radar',
    id: 'rawgraphs.radarchart',
    thumbnail: img$t,
    icon: img$s,
    categories: ['correlations'],
    description: 'Il affiche de multiples dimensions continues comme axes à partir d\'un même point et en les disposant radialement. Chaque dimension est représentée comme un axe partant du centre du chariot. La même échelle est appliquée à tous les axes.' // code: 'https://github.com/rawgraphs/raw',
    // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$f = [{
    id: 'axes',
    name: 'Rayons',
    validTypes: ['number'],
    required: true,
    multiple: true,
    minValues: 3
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$f = function (data, mapping, dataTypes, dimensions) {
    // define aggregators
    getDimensionAggregator('color', mapping, dataTypes, dimensions); // we will use rollup to populate a flat array of objects
    // that will be passed to the render

    let results = [];
    let index = 0;
    rollups(data, v => {
      //@TODO: find a better way to assing a unique index to each entry
      return v.map(d => {
        mapping.axes.value.forEach(axisName => {
          let item = {
            name: index,
            // each line will create a radar
            color: d[mapping.color.value],
            series: d[mapping.series.value],
            axes: axisName,
            value: d[axisName]
          };
          results.push(item);
        });
        index++;
        return 'done';
      });
    }, d => d[mapping.series.value] // series grouping
    );
    return results;
  };

  function render$f(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      showLegend,
      legendWidth,
      // visual model options
      showDots,
      dotsDiameter,
      interpolation,
      innerDiameter,
      fillOpacity,
      //labels
      labelsPadding,
      //series options
      columnsNumber,
      sortSeriesBy,
      showSeriesLabels,
      showGrid,
      // color otpions
      colorScale
    } = visualOptions; // Margin convention

    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; //check if there are negative values, in case throw error

    data.forEach(d => {
      if (d.value < 0) {
        throw new Error('Values cannot be negative');
      }
    }); // convert string to d3 functions

    const curveType = {
      Linear: linearClosed,
      Basis: basisClosed$1,
      Cardinal: cardinalClosed,
      'Catmull–Rom': catmullRomClosed
    }; // if series is exposed, recreate the nested structure

    const nestedData = rollups(data, v => v, d => d.series, d => d.name).map(d => {
      //calc the total values
      d.totalSize = sum(d[1].map(e => e[1]).flat(), e => e.value);
      return d;
    }); // sort series

    nestedData.sort((a, b) => {
      return {
        valueDescending: descending(a.totalSize, b.totalSize),
        valueAscending: ascending(a.totalSize, b.totalSize),
        name: ascending(a[0], b[0])
      }[sortSeriesBy];
    }); // select the SVG element

    const svg = select(svgNode); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(mapping.series.value ? columnsNumber : 1);
    const griddingData = gridding$1(nestedData); // create the clip path

    svg.append('clipPath').attr('id', 'serieClipPath').append('rect').attr('x', 0).attr('y', 0).attr('width', griddingData[0].width).attr('height', griddingData[0].height); // create the grid

    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')');
    /*
      CODE FOR ALL THE SERIES
     */

    const axesDomain = mapping.axes.value; // create the radial scale to dispose axes

    const radialScale = point().domain(axesDomain).range([-Math.PI / 2, Math.PI * 1.5]) // starts from -PI/2 (upper part of circle)
    .padding(0.5) // calculate half padding at beginning and half at end
    .align(0) // put all the apdding at the end
    .round(false);
    const maxValue = max(data, d => d.value);
    const innerRadius = innerDiameter / 2;
    const outerRadius = min([(griddingData[0].width - margin.right - margin.left) / 2, (griddingData[0].height - margin.top - margin.bottom) / 2]);
    const axesScale = linear$2().domain([0, maxValue]).nice().rangeRound([innerRadius, outerRadius]);
    const axesGrid = linear$2().domain([maxValue, 0]).rangeRound([innerRadius, outerRadius]); // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }
    /*
      CODE FOR EACH SERIE
    */


    series.each(function (d, seriesIndex) {
      // make a local selection for each serie
      const selection = select(this); // apply clipPath

      selection.attr('clip-path', 'url(#serieClipPath)'); // compute each serie width and height

      d.width - margin.right - margin.left;
      d.height - margin.top - margin.bottom; // use the smallest dimension as diameter
      // get the array containing all the data for each radar chart

      let radarData = d[1]; // create the axis and the grid

      let viz = selection.append('g').attr('id', d[0]).attr('transform', `translate(${outerRadius + margin.left}, ${outerRadius + margin.top})`);
      let axesLayer = viz.append('g').attr('id', 'axes');
      let axisFunction = axisLeft(axesGrid); // add a circle for each tick on the axis

      axesLayer.selectAll('.grid').data(axisFunction.scale().ticks()).enter().append('circle').attr('r', d => axesScale(d)).attr('fill', 'none').attr('stroke', 'LightGray').attr('class', 'grid').attr('id', d => d); // add axes

      let axesGroups = axesLayer.selectAll('g').data(axesDomain).enter().append('g'); // draw a line for each axis

      axesGroups.append('line').attr('x1', d => {
        return Math.cos(radialScale(d)) * innerRadius;
      }).attr('y1', d => {
        return Math.sin(radialScale(d)) * innerRadius;
      }).attr('x2', d => {
        return Math.cos(radialScale(d)) * outerRadius;
      }).attr('y2', d => {
        return Math.sin(radialScale(d)) * outerRadius;
      }).attr('stroke', 'black'); //add a label for each axis

      axesGroups.append('text').attr('text-anchor', 'middle').attr('dy', '0.35em').attr('x', d => {
        return Math.cos(radialScale(d)) * (outerRadius + labelsPadding);
      }).attr('y', d => {
        return Math.sin(radialScale(d)) * (outerRadius + labelsPadding);
      }).text(d => d).attr('font-family', 'Arial, sans-serif').attr('font-size', 12); //draw scale for first axis

      axesLayer.append('g').attr('id', 'y axis').call(axisFunction).attr('transform', `translate(${0}, ${-outerRadius - innerRadius})`); // draw each radar chart

      let plots = viz.append('g').attr('id', 'radars').selectAll('g').data(radarData).enter().append('g').attr('id', d => d[0]);
      let radarLine = lineRadial$1().curve(curveType[interpolation]).radius(d => axesScale(d.value)).angle(d => radialScale(d.axes) + Math.PI / 2);
      plots.append('path').attr('d', d => radarLine(d[1])).attr('stroke', d => colorScale(d[1][0].color)) //first item of the data list
      .attr('fill', d => colorScale(d[1][0].color)).attr('fill-opacity', fillOpacity);

      if (showDots) {
        plots.append('g').attr('id', 'dots').selectAll('circle').data(d => d[1]).enter().append('circle').attr('cx', d => Math.cos(radialScale(d.axes)) * axesScale(d.value)).attr('cy', d => Math.sin(radialScale(d.axes)) * axesScale(d.value)).attr('r', dotsDiameter / 2).attr('stroke', 'none').attr('fill', d => colorScale(d.color));
      } // add series titles


      if (showSeriesLabels) {
        selection.append('text').attr('x', 5).attr('y', 5).text(d => d[0]).styles(styles.seriesLabel);
      }
    }); // show legends

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$f = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 30,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 20,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 0,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 20,
      group: 'artboard'
    },
    showDots: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: true,
      group: 'chart'
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showDots: false
      }
    },
    innerDiameter: {
      type: 'number',
      label: 'Inner diameter',
      default: 0,
      group: 'chart'
    },
    interpolation: {
      type: 'text',
      label: 'Type de courbe',
      default: 'Catmull–Rom',
      options: ['Basis', 'Cardinal', 'Catmull–Rom', 'Linear'],
      group: 'chart'
    },
    fillOpacity: {
      type: 'number',
      label: 'Fill opacity',
      default: 0.5,
      step: 0.1,
      min: 0,
      max: 1,
      group: 'chart'
    },
    labelsPadding: {
      type: 'number',
      label: 'Axis labels padding',
      default: 10,
      group: 'labels'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'schemeCategory10'
      },
      group: 'colors'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: [{
        label: 'Total value (descending)',
        value: 'valueDescending'
      }, {
        label: 'Total value (ascending)',
        value: 'valueAscending'
      }, {
        label: 'Name',
        value: 'nameAscending'
      }, {
        label: 'Original',
        value: 'none'
      }],
      default: 'valueDescending'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: true,
      group: 'series'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    }
  };

  var radarchart = {
    metadata: metadata$f,
    dimensions: dimensions$f,
    mapData: mapData$f,
    render: render$f,
    visualOptions: visualOptions$f,
    styles: styles$1
  };

  var img$u = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M46%2c36.5a12.5819%2c12.5819%2c0%2c0%2c0-.0647-1.2765A18.4765%2c18.4765%2c0%2c0%2c0%2c9.0491%2c35.53%2c9.5958%2c9.5958%2c0%2c0%2c0%2c9%2c36.5h1a2.5%2c2.5%2c0%2c0%2c1%2c5%2c0h1a5.4595%2c5.4595%2c0%2c0%2c1%2c6.2635-5.4406A12.4026%2c12.4026%2c0%2c0%2c0%2c21%2c36.5h1a11.4147%2c11.4147%2c0%2c0%2c1%2c1.2594-5.2061A5.5067%2c5.5067%2c0%2c0%2c1%2c27%2c36.5h1a9.4809%2c9.4809%2c0%2c0%2c0-3.3994-7.2723%2c11.4824%2c11.4824%2c0%2c0%2c1%2c19.39%2c2.5843A6.4914%2c6.4914%2c0%2c0%2c0%2c33%2c36.5h1a2.5%2c2.5%2c0%2c0%2c1%2c5%2c0h1A3.5042%2c3.5042%2c0%2c0%2c0%2c36.5%2c33a3.4586%2c3.4586%2c0%2c0%2c0-1.5038.3531%2c5.4954%2c5.4954%2c0%2c0%2c1%2c9.9754%2c2.5853c.0091.1873.0284.372.0284.5616ZM21.5%2c30a6.5082%2c6.5082%2c0%2c0%2c0-6.1676%2c4.4611%2c3.4741%2c3.4741%2c0%2c0%2c0-4.8217-.8345%2c8.4807%2c8.4807%2c0%2c0%2c1%2c12.6938-4.2c-.1559.2262-.2967.4627-.4378.6993A6.4973%2c6.4973%2c0%2c0%2c0%2c21.5%2c30Zm3.4943%2c1.0281a6.48%2c6.48%2c0%2c0%2c0-1.2336-.6144c.08-.1275.1542-.2587.2389-.3828A8.5707%2c8.5707%2c0%2c0%2c1%2c24.9943%2c31.0281ZM33.5%2c24a12.4777%2c12.4777%2c0%2c0%2c0-9.6944%2c4.6233A9.4733%2c9.4733%2c0%2c0%2c0%2c11.024%2c30.6584a17.4738%2c17.4738%2c0%2c0%2c1%2c31.9686-2.27A12.469%2c12.469%2c0%2c0%2c0%2c33.5%2c24Z'/%3e %3c/g%3e %3cg id='primary'%3e %3ccircle class='cls-2' cx='9.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='15.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='21.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='27.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='33.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='39.5' cy='36.5' r='1.5'/%3e %3ccircle class='cls-2' cx='45.5' cy='36.5' r='1.5'/%3e %3c/g%3e%3c/svg%3e";

  var img$v = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: none%3b stroke: %23ccc%3b %7d .cls-2 %7b fill: %239e0142%3b %7d .cls-3 %7b fill: %235e4fa2%3b %7d .cls-4 %7b fill: %23e0f3a1%3b %7d .cls-5 %7b fill: %23fedd8d%3b %7d .cls-6 %7b fill: %2369bda9%3b %7d .cls-7 %7b fill: %23f0704a%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cpath class='cls-1' d='M165.23547%2c152.97288a11.48737%2c11.48737%2c0%2c0%2c0-22.97475%2c0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a28.71845%2c28.71845%2c0%2c0%2c1%2c57.43689%2c0'/%3e %3cpath class='cls-1' d='M4.41219%2c152.97288a11.48738%2c11.48738%2c0%2c0%2c1%2c22.97476%2c0'/%3e %3cpath class='cls-1' d='M188.21023%2c152.97288a22.97475%2c22.97475%2c0%2c1%2c1%2c45.94951%2c0'/%3e %3cpath class='cls-1' d='M245.64712%2c152.97288a120.61747%2c120.61747%2c0%2c0%2c0-241.23493%2c0'/%3e %3cpath class='cls-1' d='M50.3617%2c152.97288a22.97476%2c22.97476%2c0%2c1%2c0-45.94951%2c0'/%3e %3cpath class='cls-1' d='M188.21023%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c0-11.48738%2c0'/%3e %3cpath class='cls-1' d='M291.59663%2c152.97288a143.59222%2c143.59222%2c0%2c1%2c0-287.18444%2c0'/%3e %3cpath class='cls-1' d='M153.74809%2c152.97288a11.48738%2c11.48738%2c0%2c0%2c1%2c22.97476%2c0'/%3e %3cpath class='cls-1' d='M119.286%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c1%2c11.48738%2c0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c1%2c11.48738%2c0'/%3e %3cpath class='cls-1' d='M165.23547%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c1%2c11.48738%2c0'/%3e %3cpath class='cls-1' d='M257.1345%2c152.97288a91.899%2c91.899%2c0%2c1%2c0-183.798%2c0'/%3e %3cpath class='cls-1' d='M176.72285%2c152.97288a17.23107%2c17.23107%2c0%2c0%2c0-34.46213%2c0h0'/%3e %3cpath class='cls-1' d='M234.15974%2c152.97288a11.48737%2c11.48737%2c0%2c0%2c0-22.97475%2c0'/%3e %3cpath class='cls-1' d='M303.084%2c152.97288a132.10485%2c132.10485%2c0%2c0%2c0-264.20968%2c0'/%3e %3cpath class='cls-1' d='M234.15974%2c152.97288a17.23107%2c17.23107%2c0%2c0%2c0-34.46213%2c0h0'/%3e %3cpath class='cls-1' d='M165.23547%2c152.97288a28.71844%2c28.71844%2c0%2c0%2c0-57.43688%2c0'/%3e %3cpath class='cls-1' d='M73.33645%2c152.97288a34.46213%2c34.46213%2c0%2c0%2c0-68.92426%2c0'/%3e %3cpath class='cls-1' d='M211.185%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c0-11.48738%2c0'/%3e %3cpath class='cls-1' d='M15.89957%2c152.97288a17.23107%2c17.23107%2c0%2c0%2c1%2c34.46213%2c0h0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a86.15534%2c86.15534%2c0%2c0%2c1%2c172.31067%2c0'/%3e %3cpath class='cls-1' d='M188.21023%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c1%2c11.48738%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a11.48738%2c11.48738%2c0%2c0%2c1%2c22.97476%2c0'/%3e %3cpath class='cls-1' d='M15.89957%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c0-11.48738%2c0'/%3e %3cpath class='cls-1' d='M188.21023%2c152.97288a11.48738%2c11.48738%2c0%2c0%2c1%2c22.97476%2c0'/%3e %3cpath class='cls-1' d='M165.23547%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c0-11.48738%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c1%2c11.48738%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a34.46213%2c34.46213%2c0%2c0%2c1%2c68.92426%2c0'/%3e %3cpath class='cls-1' d='M314.57139%2c152.97288a103.3864%2c103.3864%2c0%2c1%2c0-206.77281%2c0h0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a114.87378%2c114.87378%2c0%2c1%2c1%2c229.74756%2c0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a17.23107%2c17.23107%2c0%2c0%2c0-34.46213%2c0'/%3e %3cpath class='cls-1' d='M38.87432%2c152.97288a11.48738%2c11.48738%2c0%2c0%2c0-22.97475%2c0'/%3e %3cpath class='cls-1' d='M61.84908%2c152.97288a28.71845%2c28.71845%2c0%2c0%2c0-57.43689%2c0'/%3e %3cpath class='cls-1' d='M291.59663%2c152.97288a97.64271%2c97.64271%2c0%2c0%2c0-195.28542%2c0'/%3e %3cpath class='cls-1' d='M314.57139%2c152.97288a68.92427%2c68.92427%2c0%2c0%2c0-137.84854%2c0h0'/%3e %3cpath class='cls-1' d='M84.82383%2c152.97288a22.97476%2c22.97476%2c0%2c1%2c0-45.94951%2c0'/%3e %3cpath class='cls-1' d='M222.67236%2c152.97288a109.13009%2c109.13009%2c0%2c0%2c0-218.26017%2c0'/%3e %3cpath class='cls-1' d='M176.72285%2c152.97288a28.71844%2c28.71844%2c0%2c0%2c0-57.43688%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a63.18058%2c63.18058%2c0%2c0%2c1%2c126.36115%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a34.46214%2c34.46214%2c0%2c0%2c0-68.92427%2c0'/%3e %3cpath class='cls-1' d='M153.74809%2c152.97288a5.74369%2c5.74369%2c0%2c1%2c0-11.48737%2c0'/%3e %3cpath class='cls-1' d='M188.21023%2c152.97288a74.668%2c74.668%2c0%2c1%2c0-149.3359%2c0h0'/%3e %3cpath class='cls-1' d='M130.77332%2c152.97288a74.668%2c74.668%2c0%2c1%2c1%2c149.33592%2c0'/%3e %3cpath class='cls-1' d='M107.79859%2c152.97288a51.6932%2c51.6932%2c0%2c1%2c1%2c103.3864%2c0'/%3e %3ccircle class='cls-2' cx='4.41219' cy='152.97288' r='4.4122'/%3e %3ccircle class='cls-3' cx='15.89957' cy='152.97288' r='3.84557'/%3e %3ccircle class='cls-4' cx='27.38695' cy='152.97288' r='3.61601'/%3e %3ccircle class='cls-2' cx='38.87432' cy='152.97288' r='7.02712'/%3e %3ccircle class='cls-2' cx='50.3617' cy='152.97288' r='3.91323'/%3e %3ccircle class='cls-5' cx='61.84908' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-2' cx='73.33645' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-2' cx='84.82383' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-3' cx='96.31121' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-3' cx='107.79859' cy='152.97288' r='4.36371'/%3e %3ccircle class='cls-3' cx='119.28597' cy='152.97288' r='3.52703'/%3e %3ccircle class='cls-6' cx='130.77335' cy='152.97288' r='3.4286' transform='translate(-14.43719 13.6306) rotate(-5.65498)'/%3e %3ccircle class='cls-4' cx='142.26072' cy='152.97288' r='3.4286'/%3e %3ccircle class='cls-4' cx='153.74809' cy='152.97288' r='3.52703'/%3e %3ccircle class='cls-4' cx='165.23547' cy='152.97288' r='3.52703'/%3e %3ccircle class='cls-6' cx='176.72285' cy='152.97288' r='3.61602'/%3e %3ccircle class='cls-7' cx='188.21023' cy='152.97288' r='5.687'/%3e %3ccircle class='cls-7' cx='199.69761' cy='152.97288' r='4.26255'/%3e %3ccircle class='cls-7' cx='211.18499' cy='152.97288' r='4.7613'/%3e %3ccircle class='cls-6' cx='222.67236' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-6' cx='234.15974' cy='152.97288' r='4.63738'/%3e %3ccircle class='cls-6' cx='245.64712' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-6' cx='257.1345' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-5' cx='268.62188' cy='152.97288' r='3.31688'/%3e %3ccircle class='cls-5' cx='280.10924' cy='152.97288' r='3.18435'/%3e %3ccircle class='cls-5' cx='291.59663' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-7' cx='303.084' cy='152.97288' r='3.01162'/%3e %3ccircle class='cls-7' cx='314.57139' cy='152.97288' r='3.42861'/%3e %3c/g%3e%3c/svg%3e";

  const metadata$g = {
    name: 'Arc Diagram',
    id: 'rawgraphs.arcdiagram',
    thumbnail: img$v,
    icon: img$u,
    categories: ['networks'],
    description: 'Arc diagram description',
    code: 'https://observablehq.com/@d3/arc-diagram'
  };

  const dimensions$g = [{
    id: 'source',
    name: 'Source node',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'target',
    name: 'Target node',
    validTypes: ['number', 'date', 'string'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    validTypes: ['number'],
    required: false,
    aggregation: true,
    aggregationDefault: 'sum'
  }];

  const mapData$g = function (data, mapping, dataTypes, dimensions) {
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const results = [];
    rollups(data, v => {
      const item = {
        source: v[0][mapping.source.value],
        target: v[0][mapping.target.value],
        value: mapping.size.value ? sizeAggregator(v.map(d => d[mapping.size.value])) : 1
      };
      results.push(item);
      return item;
    }, d => d[mapping.source.value] + d[mapping.target.value] // crossgrup functions. aggregate links among same source and target
    );
    return results;
  };

  function createCommonjsModule$1(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var louvain = createCommonjsModule$1(function (module, exports) {
  /*
   Author: Corneliu S. (github.com/upphiminn)
   This is a javascript implementation of the Louvain
   community detection algorithm (http://arxiv.org/abs/0803.0476)
   Based on https://bitbucket.org/taynaud/python-louvain/overview
   */

  module.exports.jLouvain = exports.jLouvain = function () {
      //Constants
      let __PASS_MAX = -1;
      let __MIN = 0.0000001;

      //Local lets
      let original_graph_nodes;
      let original_graph_edges;
      let original_graph = {};
      let partition_init;
      let edge_index = {};


      //Helpers
      function make_set(array) {
          let set = {};
          array.forEach(function (d, i) {
              set[d] = true;
          });

          return Object.keys(set);
      }

      function obj_values(obj) {
          let vals = [];
          for (let key in obj) {
              if (obj.hasOwnProperty(key)) {
                  vals.push(obj[key]);
              }
          }

          return vals;
      }

      function get_degree_for_node(graph, node) {
          let neighbours = graph._assoc_mat[node] ? Object.keys(graph._assoc_mat[node]) : [];
          let weight = 0;
          neighbours.forEach(function (neighbour, i) {
              let value = graph._assoc_mat[node][neighbour] || 1;
              if (node === neighbour) {
                  value *= 2;
              }
              weight += value;
          });

          return weight;
      }

      function get_neighbours_of_node(graph, node) {
          if (typeof graph._assoc_mat[node] === 'undefined') {
              return [];
          }

          // neighbours
          return Object.keys(graph._assoc_mat[node]);

      }


      function get_edge_weight(graph, node1, node2) {
          return graph._assoc_mat[node1] ? graph._assoc_mat[node1][node2] : undefined;
      }

      function get_graph_size(graph) {
          let size = 0;
          graph.edges.forEach(function (edge) {
              size += edge.weight;
          });

          return size;
      }

      function add_edge_to_graph(graph, edge) {
          update_assoc_mat(graph, edge);

          if (edge_index[edge.source+'_'+edge.target]) {
              graph.edges[edge_index[edge.source + '_' + edge.target]].weight = edge.weight;
          } else {
              graph.edges.push(edge);
              edge_index[edge.source + '_' + edge.target] = graph.edges.length - 1;
          }
      }

      function make_assoc_mat(edge_list) {
          let mat = {};
          edge_list.forEach(function (edge, i) {
              mat[edge.source] = mat[edge.source] || {};
              mat[edge.source][edge.target] = edge.weight;
              mat[edge.target] = mat[edge.target] || {};
              mat[edge.target][edge.source] = edge.weight;
          });

          return mat;
      }

      function update_assoc_mat(graph, edge) {
          graph._assoc_mat[edge.source] = graph._assoc_mat[edge.source] || {};
          graph._assoc_mat[edge.source][edge.target] = edge.weight;
          graph._assoc_mat[edge.target] = graph._assoc_mat[edge.target] || {};
          graph._assoc_mat[edge.target][edge.source] = edge.weight;
      }

      function clone(obj) {
          if (obj === null || typeof(obj) !== 'object')
              return obj;

          let temp = obj.constructor();

          for (let key in obj) {
              temp[key] = clone(obj[key]);
          }

          return temp;
      }

      //Core-Algorithm Related
      function init_status(graph, status, part) {
          status['nodes_to_com'] = {};
          status['total_weight'] = 0;
          status['internals'] = {};
          status['degrees'] = {};
          status['gdegrees'] = {};
          status['loops'] = {};
          status['total_weight'] = get_graph_size(graph);

          if (typeof part === 'undefined') {
              graph.nodes.forEach(function (node, i) {
                  status.nodes_to_com[node] = i;
                  let deg = get_degree_for_node(graph, node);

                  if (deg < 0)
                      throw 'Bad graph type, use positive weights!';

                  status.degrees[i] = deg;
                  status.gdegrees[node] = deg;
                  status.loops[node] = get_edge_weight(graph, node, node) || 0;
                  status.internals[i] = status.loops[node];
              });
          } else {
              graph.nodes.forEach(function (node, i) {
                  let com = part[node];
                  status.nodes_to_com[node] = com;
                  let deg = get_degree_for_node(graph, node);
                  status.degrees[com] = (status.degrees[com] || 0) + deg;
                  status.gdegrees[node] = deg;
                  let inc = 0.0;

                  let neighbours = get_neighbours_of_node(graph, node);
                  neighbours.forEach(function (neighbour, i) {
                      let weight = graph._assoc_mat[node][neighbour];

                      if (weight <= 0) {
                          throw "Bad graph type, use positive weights";
                      }

                      if (part[neighbour] === com) {
                          if (neighbour === node) {
                              inc += weight;
                          } else {
                              inc += weight / 2.0;
                          }
                      }
                  });
                  status.internals[com] = (status.internals[com] || 0) + inc;
              });
          }
      }

      function __modularity(status) {
          let links = status.total_weight;
          let result = 0.0;
          let communities = make_set(obj_values(status.nodes_to_com));

          communities.forEach(function (com, i) {
              let in_degree = status.internals[com] || 0;
              let degree = status.degrees[com] || 0;
              if (links > 0) {
                  result = result + in_degree / links - Math.pow((degree / (2.0 * links)), 2);
              }
          });

          return result;
      }

      function __neighcom(node, graph, status) {
          // compute the communities in the neighb. of the node, with the graph given by
          // node_to_com
          let weights = {};
          let neighboorhood = get_neighbours_of_node(graph, node);//make iterable;

          neighboorhood.forEach(function (neighbour, i) {
              if (neighbour !== node) {
                  let weight = graph._assoc_mat[node][neighbour] || 1;
                  let neighbourcom = status.nodes_to_com[neighbour];
                  weights[neighbourcom] = (weights[neighbourcom] || 0) + weight;
              }
          });

          return weights;
      }

      function __insert(node, com, weight, status) {
          //insert node into com and modify status
          status.nodes_to_com[node] = +com;
          status.degrees[com] = (status.degrees[com] || 0) + (status.gdegrees[node] || 0);
          status.internals[com] = (status.internals[com] || 0) + weight + (status.loops[node] || 0);
      }

      function __remove(node, com, weight, status) {
          //remove node from com and modify status
          status.degrees[com] = ((status.degrees[com] || 0) - (status.gdegrees[node] || 0));
          status.internals[com] = ((status.internals[com] || 0) - weight - (status.loops[node] || 0));
          status.nodes_to_com[node] = -1;
      }

      function __renumber(dict) {
          let count = 0;
          let ret = clone(dict); //deep copy :)
          let new_values = {};
          let dict_keys = Object.keys(dict);
          dict_keys.forEach(function (key) {
              let value = dict[key];
              let new_value = typeof new_values[value] === 'undefined' ? -1 : new_values[value];
              if (new_value === -1) {
                  new_values[value] = count;
                  new_value = count;
                  count = count + 1;
              }
              ret[key] = new_value;
          });

          return ret;
      }

      function __one_level(graph, status) {
          //Compute one level of the Communities Dendogram.
          let modif = true;
          let nb_pass_done = 0;
          let cur_mod = __modularity(status);
          let new_mod = cur_mod;

          while (modif && nb_pass_done !== __PASS_MAX) {
              cur_mod = new_mod;
              modif = false;
              nb_pass_done += 1;

              graph.nodes.forEach(function (node, i) {
                  let com_node = status.nodes_to_com[node];
                  let degc_totw = (status.gdegrees[node] || 0) / (status.total_weight * 2.0);
                  let neigh_communities = __neighcom(node, graph, status);
                  __remove(node, com_node, (neigh_communities[com_node] || 0.0), status);
                  let best_com = com_node;
                  let best_increase = 0;
                  let neigh_communities_entries = Object.keys(neigh_communities);//make iterable;

                  neigh_communities_entries.forEach(function (com, i) {
                      let incr = neigh_communities[com] - (status.degrees[com] || 0.0) * degc_totw;
                      if (incr > best_increase) {
                          best_increase = incr;
                          best_com = com;
                      }
                  });

                  __insert(node, best_com, neigh_communities[best_com] || 0, status);

                  if (best_com !== com_node) {
                      modif = true;
                  }
              });
              new_mod = __modularity(status);
              if (new_mod - cur_mod < __MIN) {
                  break;
              }
          }
      }

      function induced_graph(partition, graph) {
          let ret = {nodes: [], edges: [], _assoc_mat: {}};
          let w_prec, weight;
          //add nodes from partition values
          let partition_values = obj_values(partition);
          ret.nodes = ret.nodes.concat(make_set(partition_values)); //make set
          graph.edges.forEach(function (edge, i) {
              weight = edge.weight || 1;
              let com1 = partition[edge.source];
              let com2 = partition[edge.target];
              w_prec = (get_edge_weight(ret, com1, com2) || 0);
              let new_weight = (w_prec + weight);
              add_edge_to_graph(ret, {'source': com1, 'target': com2, 'weight': new_weight});
              edge_index = {};
          });

          return ret;
      }

      function partition_at_level(dendogram, level) {
          let partition = clone(dendogram[0]);
          for (let i = 1; i < level + 1; i++) {
              Object.keys(partition).forEach(function (key, j) {
                  let node = key;
                  let com = partition[key];
                  partition[node] = dendogram[i][com];
              });
          }

          return partition;
      }

      function generate_dendogram(graph, part_init) {
          if (graph.edges.length === 0) {
              let part = {};
              graph.nodes.forEach(function (node, i) {
                  part[node] = node;
              });
              return part;
          }
          let status = {};

          init_status(original_graph, status, part_init);
          let mod = __modularity(status);
          let status_list = [];
          __one_level(original_graph, status);
          let new_mod = __modularity(status);
          let partition = __renumber(status.nodes_to_com);
          status_list.push(partition);
          mod = new_mod;
          let current_graph = induced_graph(partition, original_graph);
          init_status(current_graph, status);

          while (true) {
              __one_level(current_graph, status);
              new_mod = __modularity(status);
              if (new_mod - mod < __MIN) {
                  break;
              }

              partition = __renumber(status.nodes_to_com);
              status_list.push(partition);

              mod = new_mod;
              current_graph = induced_graph(partition, current_graph);
              init_status(current_graph, status);
          }

          return status_list;
      }

      let core = function () {
          let dendogram = generate_dendogram(original_graph, partition_init);

          return partition_at_level(dendogram, dendogram.length - 1);
      };

      core.nodes = function (nds) {
          if (arguments.length > 0) {
              original_graph_nodes = nds;
          }

          return core;
      };

      core.edges = function (edgs) {
          if (typeof original_graph_nodes === 'undefined')
              throw 'Please provide the graph nodes first!';

          if (arguments.length > 0) {
              original_graph_edges = edgs;
              let assoc_mat = make_assoc_mat(edgs);
              original_graph = {
                  'nodes': original_graph_nodes,
                  'edges': original_graph_edges,
                  '_assoc_mat': assoc_mat
              };
          }

          return core;

      };

      core.partition_init = function (prttn) {
          if (arguments.length > 0) {
              partition_init = prttn;
          }
          return core;
      };

      return core;
  };
  });

  function render$g(svgNode, data, visualOptions, mapping, originalData) {
    const {
      // artboard
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      //chart
      minDiameter,
      maxDiameter,
      nodeSize,
      orderNodesBy,
      linkOpacity,
      sameSide
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // create a graph data file from the incoming data

    let graph = graphFromEdgesTable(data); //compute nodes modularity

    if (orderNodesBy == 'Minimize overlaps') {
      let community = louvain.jLouvain().nodes(graph.nodes.map(d => d.id)).edges(graph.links.map(d => ({
        source: d.source.id,
        target: d.target.id,
        weight: d.value
      })));
      let results = community();
      graph.nodes.forEach(n => n.community = results[n.id]);
    } // sort nodes
    // 'Name', 'Links count (degree)', 'Total value'


    graph.nodes.sort((a, b) => {
      switch (orderNodesBy) {
        case 'Total value':
          return descending(a.totalValue, b.totalValue);

        case 'Links count (degree)':
          return ascending(a.degree, b.degree);

        case 'Name':
          return ascending(a.id, b.id);

        case 'Minimize overlaps':
          return ascending(a.community, b.community);

        default:
          return 0;
      }
    }); // size scale

    const sizeScale = sqrt$1().domain([0, max(graph.nodes, d => d[nodeSize])]).range([minDiameter, maxDiameter]); // widthScale (for nodes)

    const widthScale = linear$2().domain([0, max(graph.links, d => d.value)]).range([0, maxDiameter]); // get the total size

    const totalValue = sum(graph.nodes, d => sizeScale(d[nodeSize]) * 2); // compute padding

    const padding = (chartWidth - totalValue) / (graph.nodes.length - 1); // compute x positions. @TODO could be improved

    let xPos = 0;
    graph.nodes.forEach((d, i) => {
      d.x = xPos + sizeScale(d[nodeSize]);
      d.y = sameSide ? chartHeight - maxDiameter : chartHeight / 2;
      xPos += padding + sizeScale(d[nodeSize]) * 2;
    }); // add background

    select(svgNode).append('rect').attr('width', width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz'); // draw links

    const arcs = svg.append('g').attr('id', 'arcs');
    arcs.selectAll('path').data(graph.links).enter().append('path').attr('d', d => {
      const r = Math.abs(d.source.x - d.target.x) / 2;
      const sweep = sameSide ? d.source.x < d.target.x ? 1 : 0 : 1;
      return `M${d.source.x},${d.source.y}A${r},${r} 0,0,${sweep} ${d.target.x},${d.target.y}`;
    }).attr('fill', 'none').attr('stroke', 'gray').attr('stroke-width', d => widthScale(d.value)).attr('opacity', linkOpacity); // draw nodes

    const nodes = svg.append('g').attr('id', 'nodes').selectAll('g').data(graph.nodes).enter().append('g'); // add circles

    nodes.append('circle').attr('cx', d => d.x).attr('cy', d => d.y).attr('r', d => sizeScale(d[nodeSize])); // add labels

    nodes.append('text') // .attr('x', (d) => d.x)
    // .attr('y', (d) => d.y + sizeScale(d[nodeSize]))
    .text(d => d.id).attr('transform', d => `translate(${d.x},${d.y + sizeScale(d[nodeSize]) + 5}) rotate(-90)`).attr('alignment-baseline', 'middle').attr('font-family', 'Helvetica, Arial, sans-serif').attr('font-size', 12).attr('text-anchor', 'end');
  }
  /*
   helper function to create a graph js object
   */

  function graphFromEdgesTable(_edgesTable) {
    // links are a deep copy of the dataset, to avoid modification of origina data variable
    let links = _edgesTable.map(d => Object.assign({}, d));

    const nodes = Array.from(new Set(links.flatMap(l => [l.source, l.target])), id => ({
      id,
      outLinks: [],
      inLinks: [],
      totalValue: 0,
      inValue: 0,
      outValue: 0,
      degree: 0,
      inDegree: 0,
      outDegree: 0,
      default: 1
    }));
    const nodeById = new Map(nodes.map(d => [d.id, d])); //links are now re-populated ank linked to nodes objects

    links = links.map(({
      source,
      target,
      value
    }) => ({
      source: nodeById.get(source),
      target: nodeById.get(target),
      value
    })); // links added to nodes objects

    for (const link of links) {
      const {
        source,
        target,
        value
      } = link; //update source

      source.outLinks.push(link);
      source.totalValue += link.value;
      source.outValue += link.value;
      source.degree++;
      source.outDegree++; //update target

      target.inLinks.push(link);
      target.degree++;
      target.inDegree++;
      target.totalValue += link.value;
      target.inValue += link.value;
    }

    return {
      nodes,
      links
    };
  }

  const visualOptions$g = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 10,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    minDiameter: {
      type: 'number',
      label: 'Min diameter',
      default: 2,
      group: 'chart'
    },
    maxDiameter: {
      type: 'number',
      label: 'Diamètre maximum',
      default: 30,
      group: 'chart'
    },
    linkOpacity: {
      type: 'number',
      label: 'Links opacity (0-1)',
      default: 0.5,
      step: 0.1,
      min: 0,
      max: 1,
      group: 'chart'
    },
    sameSide: {
      type: 'boolean',
      label: 'Arcs only on the top',
      default: false,
      group: 'chart'
    },
    nodeSize: {
      type: 'text',
      label: 'Nodes diameter',
      group: 'chart',
      options: [{
        label: 'Same size',
        value: 'default'
      }, {
        label: 'Weighted degree',
        value: 'totalValue'
      }, {
        label: 'Weighted inDegree',
        value: 'inValue'
      }, {
        label: 'Weighted outDegree',
        value: 'outValue'
      }, {
        label: 'Links count',
        value: 'degree'
      }, {
        label: 'OutDegree',
        value: 'outDegree'
      }, {
        label: 'InDegree',
        value: 'inDegree'
      }],
      default: 'totalValue'
    },
    orderNodesBy: {
      type: 'text',
      label: 'Sort nodes by',
      group: 'chart',
      options: ['Name', 'Links count (degree)', 'Size', 'Minimize overlaps'],
      default: 'Minimize overlaps'
    }
  };

  var arcdiagram = {
    metadata: metadata$g,
    dimensions: dimensions$g,
    mapData: mapData$g,
    render: render$g,
    visualOptions: visualOptions$g
  };

  var img$w = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M19.9971%2c24.5a6.3078%2c6.3078%2c0%2c0%2c0-1.4239-3.6611A7.1479%2c7.1479%2c0%2c0%2c1%2c16.9971%2c16.5v-.4971h-.9942V16.5a7.1479%2c7.1479%2c0%2c0%2c1-1.5761%2c4.3389A6.3078%2c6.3078%2c0%2c0%2c0%2c13.0029%2c24.5a12.4967%2c12.4967%2c0%2c0%2c1-.4853%2c3.38%2c13.5076%2c13.5076%2c0%2c0%2c0-.5147%2c3.62%2c6.3078%2c6.3078%2c0%2c0%2c0%2c1.4239%2c3.6611A7.1479%2c7.1479%2c0%2c0%2c1%2c15.0029%2c39.5a19.2486%2c19.2486%2c0%2c0%2c0%2c.5664%2c4.7246A13.6883%2c13.6883%2c0%2c0%2c1%2c16.0029%2c47.5v.4971h.9942V47.5a13.6883%2c13.6883%2c0%2c0%2c1%2c.4336-3.2754A19.2486%2c19.2486%2c0%2c0%2c0%2c17.9971%2c39.5a7.1479%2c7.1479%2c0%2c0%2c1%2c1.5761-4.3389A6.3078%2c6.3078%2c0%2c0%2c0%2c20.9971%2c31.5a13.5076%2c13.5076%2c0%2c0%2c0-.5147-3.62A12.4967%2c12.4967%2c0%2c0%2c1%2c19.9971%2c24.5Z'/%3e %3cpath class='cls-1' d='M47.3975%2c35.7021a5.179%2c5.179%2c0%2c0%2c1-1.4-3.2021%2c14.5%2c14.5%2c0%2c0%2c0-.458-3.4932%2c18.1508%2c18.1508%2c0%2c0%2c1-.542-4.5068v-.4971h-.9942V24.5a18.1508%2c18.1508%2c0%2c0%2c1-.542%2c4.5068%2c14.5%2c14.5%2c0%2c0%2c0-.458%2c3.4932%2c5.179%2c5.179%2c0%2c0%2c1-1.4%2c3.2021%2c6.038%2c6.038%2c0%2c0%2c0-1.6%2c3.7979c0%2c1.582.9717%2c2.667%2c1.9121%2c3.7158%2c1.0264%2c1.1455%2c2.0879%2c2.3311%2c2.0879%2c4.2842v.4971h.9942V47.5c0-1.9531%2c1.0615-3.1387%2c2.0879-4.2842.94-1.0488%2c1.9121-2.1338%2c1.9121-3.7158A6.038%2c6.038%2c0%2c0%2c0%2c47.3975%2c35.7021Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M34.6436%2c12.6963c-1.793-1.1426-3.6465-2.3252-3.6465-4.1963V8.0029h-.9942V8.5c0%2c1.8711-1.8535%2c3.0537-3.6465%2c4.1963-1.7246%2c1.1006-3.3535%2c2.1387-3.3535%2c3.8037%2c0%2c1.6152%2c1.2188%2c2.7031%2c2.3975%2c3.7549%2c1.2793%2c1.1426%2c2.6025%2c2.3242%2c2.6025%2c4.2451a18.1508%2c18.1508%2c0%2c0%2c1-.542%2c4.5068%2c14.5%2c14.5%2c0%2c0%2c0-.458%2c3.4932%2c6.038%2c6.038%2c0%2c0%2c0%2c1.6%2c3.7979%2c5.179%2c5.179%2c0%2c0%2c1%2c1.4%2c3.2021v.4971h.9942V39.5a5.179%2c5.179%2c0%2c0%2c1%2c1.4-3.2021%2c6.038%2c6.038%2c0%2c0%2c0%2c1.6-3.7979%2c14.5%2c14.5%2c0%2c0%2c0-.458-3.4932%2c18.1508%2c18.1508%2c0%2c0%2c1-.542-4.5068c0-1.9209%2c1.3232-3.1025%2c2.6025-4.2451%2c1.1787-1.0518%2c2.3975-2.14%2c2.3975-3.7549C37.9971%2c14.835%2c36.3682%2c13.7969%2c34.6436%2c12.6963Z'/%3e %3cpolygon class='cls-2' points='9.185 9.685 7.5 8 5.815 9.685 5.815 11.115 7.003 9.927 7.003 48 7.997 48 7.997 9.927 9.185 11.115 9.185 9.685'/%3e %3c/g%3e%3c/svg%3e";

  var img$x = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: none%3b stroke: black%3b %7d .cls-2 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d .cls-3 %7b fill: %239e0142%3b %7d .cls-4 %7b fill: %23a0d9a3%3b %7d .cls-5 %7b fill: %235e4fa2%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cpath class='cls-1' d='M25.5%2c142.5h295'/%3e %3cline class='cls-1' x1='74.16666' y1='142' x2='74.16666' y2='148'/%3e %3cline class='cls-1' x1='172.5' y1='142' x2='172.5' y2='148'/%3e %3cline class='cls-1' x1='270.83334' y1='142' x2='270.83334' y2='148'/%3e %3c/g%3e %3cg%3e %3cg%3e %3cline class='cls-1' x1='25' y1='142.5' x2='19' y2='142.5'/%3e %3ctext class='cls-2' transform='translate(2.09863 145.7)'%3e4.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='125.375' x2='19' y2='125.375'/%3e %3ctext class='cls-2' transform='translate(2.09863 128.575)'%3e4.5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='108.25' x2='19' y2='108.25'/%3e %3ctext class='cls-2' transform='translate(2.09863 111.45)'%3e5.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='91.125' x2='19' y2='91.125'/%3e %3ctext class='cls-2' transform='translate(2.09863 94.325)'%3e5.5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='74' x2='19' y2='74'/%3e %3ctext class='cls-2' transform='translate(2.09863 77.2)'%3e6.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='56.875' x2='19' y2='56.875'/%3e %3ctext class='cls-2' transform='translate(2.09863 60.07499)'%3e6.5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='39.75' x2='19' y2='39.75'/%3e %3ctext class='cls-2' transform='translate(2.09863 42.95)'%3e7.0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='22.625' x2='19' y2='22.625'/%3e %3ctext class='cls-2' transform='translate(2.09863 25.82501)'%3e7.5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-1' x1='25' y1='5.5' x2='19' y2='5.5'/%3e %3ctext class='cls-2' transform='translate(2.09863 8.70001)'%3e8.0%3c/text%3e %3c/g%3e %3c/g%3e %3cpath class='cls-3' d='M74.16667%2c142a6.71935%2c6.71935%2c0%2c0%2c1%2c.8155-3.425c.70031-1.14166%2c2.04334-2.28332%2c2.93582-3.425a33.06169%2c33.06169%2c0%2c0%2c1%2c2.44651-3.425c1.11211-1.14167%2c2.89438-2.28334%2c4.07753-3.425s1.76718-2.28333%2c2.77271-3.425%2c2.43259-2.28333%2c3.262-3.425%2c1.06126-2.28333%2c2.44652-3.425a38.70607%2c38.70607%2c0%2c0%2c1%2c6.19784-3.425%2c62.1746%2c62.1746%2c0%2c0%2c0%2c6.03473-3.425c1.75174-1.14167%2c3.24613-2.28333%2c2.93582-3.425s-2.42534-2.28333-3.75132-3.425-1.86294-2.28333-3.42512-3.425a42.08544%2c42.08544%2c0%2c0%2c0-6.68714-3.425%2c30.2741%2c30.2741%2c0%2c0%2c1-6.36094-3.425A5.43331%2c5.43331%2c0%2c0%2c1%2c86.073%2c90.625%2c6.50925%2c6.50925%2c0%2c0%2c0%2c84.27893%2c87.2c-1.15353-1.14166-3.09475-2.28333-4.24063-3.425a6.73612%2c6.73612%2c0%2c0%2c1-1.79411-3.425%2c15.2364%2c15.2364%2c0%2c0%2c0-1.14171-3.425c-.59919-1.14167-1.55276-2.28333-2.12031-3.425a8.56248%2c8.56248%2c0%2c0%2c1-.8155-3.425c-.06644-1.14166-.01781-2.28333%2c0-3.425s.00477-2.28333%2c0-3.425-.00128-2.28334%2c0-3.425.00034-2.28334%2c0-3.425-.00009-2.28333%2c0-3.425%2c0-2.28333%2c0-3.425%2c0-2.28334%2c0-3.425V5h0V42.675q0%2c1.71249%2c0%2c3.425t0%2c3.425q0%2c1.71251%2c0%2c3.425.00014%2c1.7125%2c0%2c3.425-.00051%2c1.71249%2c0%2c3.425c.00127%2c1.14166.00477%2c2.28333%2c0%2c3.425s-.01781%2c2.28333%2c0%2c3.425.06644%2c2.28333%2c0%2c3.425a8.56233%2c8.56233%2c0%2c0%2c1-.81551%2c3.425c-.56754%2c1.14167-1.52111%2c2.28333-2.12031%2c3.425a15.2369%2c15.2369%2c0%2c0%2c0-1.14171%2c3.425A6.736%2c6.736%2c0%2c0%2c1%2c68.295%2c83.775c-1.14588%2c1.14166-3.0871%2c2.28333-4.24062%2c3.425a6.50918%2c6.50918%2c0%2c0%2c0-1.79411%2c3.425%2c5.43341%2c5.43341%2c0%2c0%2c1-1.79411%2c3.425%2c30.27461%2c30.27461%2c0%2c0%2c1-6.36094%2c3.425%2c42.085%2c42.085%2c0%2c0%2c0-6.68714%2c3.425c-1.56218%2c1.14166-2.09913%2c2.28333-3.42512%2c3.425s-3.441%2c2.28334-3.75132%2c3.425%2c1.18407%2c2.28333%2c2.93581%2c3.425a62.17484%2c62.17484%2c0%2c0%2c0%2c6.03474%2c3.425%2c38.70651%2c38.70651%2c0%2c0%2c1%2c6.19784%2c3.425c1.38525%2c1.14166%2c1.61708%2c2.28333%2c2.44651%2c3.425s2.25648%2c2.28334%2c3.262%2c3.425%2c1.58957%2c2.28333%2c2.77272%2c3.425%2c2.96542%2c2.28333%2c4.07752%2c3.425a33.06182%2c33.06182%2c0%2c0%2c1%2c2.44652%2c3.425c.89247%2c1.14168%2c2.2355%2c2.28334%2c2.93581%2c3.425A6.71946%2c6.71946%2c0%2c0%2c1%2c74.16667%2c142Z'/%3e %3cpath class='cls-4' d='M172.5%2c142q.00009-1.71249%2c0-3.425-.00017-1.71249%2c0-3.425.0006-1.71249%2c0-3.425c-.00147-1.14167-.00547-2.28334%2c0-3.425s.02042-2.28333%2c0-3.425-.0762-2.28333%2c0-3.425a9.41552%2c9.41552%2c0%2c0%2c1%2c.81551-3.425%2c31.18636%2c31.18636%2c0%2c0%2c1%2c2.12031-3.425c.73521-1.14167%2c1.35164-2.28334%2c1.95721-3.425a14.94819%2c14.94819%2c0%2c0%2c0%2c1.46791-3.425%2c6.26068%2c6.26068%2c0%2c0%2c0-.1631-3.425c-.37126-1.14166-1.05431-2.28333-.97861-3.425s.91015-2.28333%2c2.28342-3.425A34.80929%2c34.80929%2c0%2c0%2c1%2c185.385%2c94.05c2.097-1.14167%2c4.37891-2.28333%2c6.36094-3.425a13.51241%2c13.51241%2c0%2c0%2c0%2c4.40372-3.425%2c2.9951%2c2.9951%2c0%2c0%2c0-.1631-3.425c-.69968-1.14167-1.89606-2.28333-2.60961-3.425a26.54476%2c26.54476%2c0%2c0%2c1-1.46792-3.425%2c22.848%2c22.848%2c0%2c0%2c1-1.631-3.425%2c11.347%2c11.347%2c0%2c0%2c1%2c0-3.425%2c5.42365%2c5.42365%2c0%2c0%2c0-.81551-3.425%2c26.15115%2c26.15115%2c0%2c0%2c0-3.262-3.425%2c7.53107%2c7.53107%2c0%2c0%2c1-2.28341-3.425c-.23052-1.14167.21958-2.28334.1631-3.425a14.58786%2c14.58786%2c0%2c0%2c0-.9786-3.425%2c18.72525%2c18.72525%2c0%2c0%2c1-.65241-3.425%2c10.25033%2c10.25033%2c0%2c0%2c0-.8155-3.425%2c15.30344%2c15.30344%2c0%2c0%2c0-2.60962-3.425%2c26.9162%2c26.9162%2c0%2c0%2c1-2.93582-3.425%2c15.67918%2c15.67918%2c0%2c0%2c1-1.46791-3.425c-.41018-1.14167-.90513-2.28333-1.3048-3.425A14.78438%2c14.78438%2c0%2c0%2c1%2c172.5%2c28.975a27.70546%2c27.70546%2c0%2c0%2c1%2c0-3.425c.02986-1.14167.008-2.28334%2c0-3.425s-.00214-2.28333%2c0-3.425.00058-2.28334%2c0-3.425-.00015-2.28334%2c0-3.425%2c0-2.28334%2c0-3.425%2c0-2.28334%2c0-3.425h0q0%2c1.71249%2c0%2c3.425t0%2c3.425q.00024%2c1.71249%2c0%2c3.425-.00086%2c1.71249%2c0%2c3.425c.00215%2c1.14167.008%2c2.28333%2c0%2c3.425s-.02985%2c2.28333%2c0%2c3.425a27.7035%2c27.7035%2c0%2c0%2c1%2c0%2c3.425%2c14.78486%2c14.78486%2c0%2c0%2c1-.8155%2c3.425c-.39968%2c1.14167-.89462%2c2.28333-1.30481%2c3.425a15.67918%2c15.67918%2c0%2c0%2c1-1.46791%2c3.425%2c26.91608%2c26.91608%2c0%2c0%2c1-2.93581%2c3.425%2c15.30344%2c15.30344%2c0%2c0%2c0-2.60962%2c3.425%2c10.25035%2c10.25035%2c0%2c0%2c0-.81551%2c3.425%2c18.72606%2c18.72606%2c0%2c0%2c1-.6524%2c3.425%2c14.58786%2c14.58786%2c0%2c0%2c0-.9786%2c3.425c-.05649%2c1.14166.39361%2c2.28333.1631%2c3.425a7.531%2c7.531%2c0%2c0%2c1-2.28342%2c3.425%2c26.15181%2c26.15181%2c0%2c0%2c0-3.262%2c3.425%2c5.42357%2c5.42357%2c0%2c0%2c0-.8155%2c3.425%2c11.34732%2c11.34732%2c0%2c0%2c1%2c0%2c3.425%2c22.84812%2c22.84812%2c0%2c0%2c1-1.631%2c3.425%2c26.54467%2c26.54467%2c0%2c0%2c1-1.46791%2c3.425c-.71355%2c1.14167-1.90993%2c2.28333-2.60962%2c3.425a2.99512%2c2.99512%2c0%2c0%2c0-.1631%2c3.425%2c13.51247%2c13.51247%2c0%2c0%2c0%2c4.40373%2c3.425c1.982%2c1.14167%2c4.26394%2c2.28333%2c6.36094%2c3.425a34.80977%2c34.80977%2c0%2c0%2c1%2c5.38233%2c3.425c1.37326%2c1.14167%2c2.20771%2c2.28333%2c2.28341%2c3.425s-.60735%2c2.28333-.9786%2c3.425a6.26058%2c6.26058%2c0%2c0%2c0-.1631%2c3.425%2c14.94814%2c14.94814%2c0%2c0%2c0%2c1.4679%2c3.425c.60558%2c1.14166%2c1.222%2c2.28333%2c1.95721%2c3.425a31.185%2c31.185%2c0%2c0%2c1%2c2.12032%2c3.425%2c9.41529%2c9.41529%2c0%2c0%2c1%2c.8155%2c3.425c.07621%2c1.14168.02042%2c2.28334%2c0%2c3.425s-.00547%2c2.28333%2c0%2c3.425.00147%2c2.28333%2c0%2c3.425-.00039%2c2.28333%2c0%2c3.425.00012%2c2.28334%2c0%2c3.425S172.5%2c140.85834%2c172.5%2c142Z'/%3e %3cpath class='cls-5' d='M270.83334%2c142q.00017-1.71249%2c0-3.425-.00033-1.71249%2c0-3.425c.00076-1.14166.00284-2.28332%2c0-3.425s-.01059-2.28334%2c0-3.425.03951-2.28333%2c0-3.425a20.94874%2c20.94874%2c0%2c0%2c1%2c0-3.425c.14746-1.14166.55032-2.28333.8155-3.425a23.94361%2c23.94361%2c0%2c0%2c0%2c.48931-3.425c.09663-1.14167.16238-2.28334.1631-3.425s-.06363-2.28333-.1631-3.425a25.90856%2c25.90856%2c0%2c0%2c0-.48931-3.425c-.25522-1.14166-.631-2.28333-.8155-3.425a10.86926%2c10.86926%2c0%2c0%2c1%2c0-3.425c.17755-1.14167.52574-2.28334.8155-3.425a9.77528%2c9.77528%2c0%2c0%2c1%2c1.30481-3.425c.7837-1.14167%2c2.11975-2.28333%2c3.09892-3.425a22.866%2c22.866%2c0%2c0%2c0%2c2.28341-3.425c.682-1.14167%2c1.42358-2.28333%2c1.95721-3.425a10.68617%2c10.68617%2c0%2c0%2c0%2c.97861-3.425%2c12.00156%2c12.00156%2c0%2c0%2c1%2c.4893-3.425%2c8.7902%2c8.7902%2c0%2c0%2c1%2c2.93582-3.425c1.47818-1.14166%2c3.4338-2.28333%2c5.21923-3.425s3.40069-2.28333%2c3.75132-3.425-.56335-2.28334-.8155-3.425.15751-2.28334-.65241-3.425-2.83941-2.28333-3.91442-3.425-1.19554-2.28333-1.79411-3.425-1.67518-2.28334-2.28341-3.425-.7481-2.28334-1.46791-3.425-2.01956-2.28334-2.60962-3.425a10.18089%2c10.18089%2c0%2c0%2c1-.6524-3.425c-.182-1.14167-.66556-2.28333-.81551-3.425a18.91093%2c18.91093%2c0%2c0%2c0-.3262-3.425c-.36-1.14167-1.26358-2.28333-1.46791-3.425a7.38743%2c7.38743%2c0%2c0%2c1%2c.65241-3.425%2c31.13085%2c31.13085%2c0%2c0%2c0%2c.8155-3.425%2c22.0582%2c22.0582%2c0%2c0%2c0%2c.48931-3.425%2c6.9892%2c6.9892%2c0%2c0%2c0-.65241-3.425%2c15.01485%2c15.01485%2c0%2c0%2c0-2.60961-3.425c-1.07573-1.14167-2.25043-2.28334-3.42512-3.425h-2.60962c-1.17469%2c1.14166-2.34939%2c2.28333-3.42512%2c3.425a15.01456%2c15.01456%2c0%2c0%2c0-2.60961%2c3.425%2c6.98909%2c6.98909%2c0%2c0%2c0-.65241%2c3.425%2c22.057%2c22.057%2c0%2c0%2c0%2c.4893%2c3.425%2c31.13091%2c31.13091%2c0%2c0%2c0%2c.81551%2c3.425%2c7.38742%2c7.38742%2c0%2c0%2c1%2c.6524%2c3.425c-.20432%2c1.14167-1.10794%2c2.28333-1.46791%2c3.425a18.91093%2c18.91093%2c0%2c0%2c0-.3262%2c3.425c-.14994%2c1.14167-.63353%2c2.28333-.8155%2c3.425a10.18066%2c10.18066%2c0%2c0%2c1-.65241%2c3.425c-.59006%2c1.14166-1.8898%2c2.28333-2.60961%2c3.425s-.85967%2c2.28333-1.46791%2c3.425-1.68485%2c2.28333-2.28341%2c3.425-.7191%2c2.28333-1.79411%2c3.425-3.10451%2c2.28333-3.91443%2c3.425-.40024%2c2.28333-.6524%2c3.425-1.16614%2c2.28333-.81551%2c3.425%2c1.96589%2c2.28333%2c3.75133%2c3.425%2c3.74105%2c2.28333%2c5.21923%2c3.425a8.79024%2c8.79024%2c0%2c0%2c1%2c2.93581%2c3.425%2c12.00193%2c12.00193%2c0%2c0%2c1%2c.48931%2c3.425%2c10.68615%2c10.68615%2c0%2c0%2c0%2c.9786%2c3.425c.53363%2c1.14167%2c1.27526%2c2.28333%2c1.95721%2c3.425a22.86613%2c22.86613%2c0%2c0%2c0%2c2.28342%2c3.425c.97917%2c1.14168%2c2.31522%2c2.28334%2c3.09892%2c3.425a9.77525%2c9.77525%2c0%2c0%2c1%2c1.3048%2c3.425c.28977%2c1.14166.638%2c2.28333.81551%2c3.425a10.86926%2c10.86926%2c0%2c0%2c1%2c0%2c3.425c-.18446%2c1.14166-.56029%2c2.28333-.81551%2c3.425a25.91019%2c25.91019%2c0%2c0%2c0-.4893%2c3.425c-.09947%2c1.14167-.16381%2c2.28333-.1631%2c3.425s.06647%2c2.28333.1631%2c3.425a23.94358%2c23.94358%2c0%2c0%2c0%2c.4893%2c3.425c.26518%2c1.14166.668%2c2.28333.81551%2c3.425a20.94874%2c20.94874%2c0%2c0%2c1%2c0%2c3.425c-.03951%2c1.14167-.01059%2c2.28333%2c0%2c3.425s.00284%2c2.28333%2c0%2c3.425-.00077%2c2.28333%2c0%2c3.425.00022%2c2.28334%2c0%2c3.425S270.83323%2c140.85834%2c270.83334%2c142Z'/%3e %3ctext class='cls-2' transform='translate(71.31506 159.01062)'%3ea%3c/text%3e %3ctext class='cls-2' transform='translate(169.98578 159.01062)'%3eb%3c/text%3e %3ctext class='cls-2' transform='translate(268.65417 159.01062)'%3ec%3c/text%3e %3cline class='cls-1' x1='25' y1='5.5' x2='25.5' y2='142.5'/%3e%3c/svg%3e";

  const metadata$h = {
    name: 'Violin plot',
    id: 'rawgraphs.violinplot',
    thumbnail: img$x,
    icon: img$w,
    categories: ['distributions'],
    description: 'It is useful to show the distribution of a numeric dimension. The shape width represents the amount of items with the same value in the dataset.' // code: 'https://www.d3-graph-gallery.com/graph/violin_basicHist.html',
    // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$h = [{
    id: 'value',
    name: 'Axe Y',
    validTypes: ['number'],
    required: true
  }, {
    id: 'group',
    name: 'Groups',
    validTypes: ['number', 'date', 'string'],
    required: false
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }];

  const mapData$h = function (data, mapping, dataTypes, dimensions) {
    // define aggregators
    // you should provide the dimension name (defined in dimensions.js)
    // and pass mapping, dataTypes, and dimensions.
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'group' in mapping ? null : mapping.group = {
      value: undefined
    };
    'color' in mapping ? null : mapping.color = {
      value: undefined
    }; // we will use rollup to populate a flat array of objects
    // that will be passed to the render

    let results = [];
    rollups(data, v => {
      v.forEach(d => {
        const item = {
          group: d[mapping.group.value],
          value: d[mapping.value.value],
          color: colorAggregator(v.map(e => e[mapping.color.value]))
        };
        results.push(item);
      });
      return v;
    }, d => d[mapping.group.value] // groups grouping
    );
    return results;
  };

  function render$h(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // charts options
      padding,
      sortGroupsBy,
      binsNumber,
      // how many 'bins' are available
      interpolation,
      showDots,
      dotsDiameter,
      //legend
      showLegend,
      legendWidth,
      // color dimension option, defined in visualOptions.js
      colorScale
    } = visualOptions; // Margin convention

    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // convert string to d3 functions

    const curveType = {
      Basis: basis$2,
      Bundle: bundle,
      Cardinal: cardinal,
      'Catmull–Rom': catmullRom,
      Linear: curveLinear,
      'Monotone Y': monotoneY,
      Natural: natural,
      Step: step,
      'Step After': stepAfter,
      'Step Before': stepBefore
    }; //get vertical scale

    const yScale = linear$2().domain(extent(data, d => d.value)).nice().range([chartHeight, 0]); // prepare the data

    const nestedData = rollups(data, v => ({
      group: v[0].group,
      color: v[0].color,
      bins: bin().domain(yScale.domain()).thresholds(binsNumber)(v.map(e => e.value)),
      totalValue: sum(v, d => d.value)
    }), d => d.group); // sort series

    nestedData.sort((a, b) => {
      return {
        valueDescending: descending(a[1].totalValue, b[1].totalValue),
        valueAscending: ascending(a[1].totalValue, b[1].totalValue),
        name: ascending(a[0], b[0])
      }[sortGroupsBy];
    });
    console.log(nestedData); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');
    const groupsDomain = nestedData.map(d => d[0]);
    const xScale = band().range([0, chartWidth]).domain(groupsDomain).padding(padding / (chartWidth / groupsDomain.length)); // convert padding from pixel to percentage @TODO: not working, check
    // get the max value in the bins

    const maxValue = max(nestedData.map(d => d[1].bins.map(e => e.length)).flat(1)); // compute the scale used to draw shapes

    const shapeScale = linear$2().range([0, xScale.bandwidth()]).domain([-maxValue, maxValue]); // append scales

    svg.append('g').attr('id', 'y axis').call(axisLeft(yScale)).append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['value'].value).styles(styles.axisLabel);
    svg.append('g').attr('id', 'x axis').attr('transform', 'translate(0,' + chartHeight + ')').call(axisBottom(xScale)).append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['group'].value).styles(styles.axisLabel);
    let shapes = svg.append('g').attr('id', 'shapes').selectAll('g').data(nestedData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + xScale(d[0]) + ' ,0)').style('fill', d => colorScale(d[1].color));
    shapes.append('path').datum(d => {
      const delta = d[1].bins[0].x1 - d[1].bins[0].x0;
      const completeShape = [...d[1].bins]; // make a copy
      //add a first and last element to be sure to 'close' the path with a 0 value
      //@TODO could be maybe improved, not really nice

      completeShape.unshift([]);
      completeShape[0].x0 = d[1].bins[0].x0 - delta;
      completeShape[0].x1 = d[1].bins[0].x0;
      completeShape.push([]);
      completeShape[completeShape.length - 1].x0 = completeShape[completeShape.length - 2].x0 + delta;
      completeShape[completeShape.length - 1].x1 = completeShape[completeShape.length - 2].x0 + delta * 2;
      return completeShape;
    }) // So now we are working bin per bin
    .style('stroke', 'none').attr('teest', d => {// console.log(d)
    }).attr('d', area$3().x0(d => shapeScale(-d.length)).x1(d => shapeScale(d.length)).y(d => yScale((d.x0 + d.x1) / 2)).curve(curveType[interpolation]));

    if (showDots) {
      shapes.selectAll('circle').data(d => // merge down bins keeping x position
      d[1].bins.map((bin, index) => bin.map(elm => ({
        value: elm,
        index: index,
        length: bin.length,
        x0: bin.x0,
        x1: bin.x1
      }))).flat(1)).join('circle').attr('cy', d => yScale(d.value)).attr('cx', xScale.bandwidth() / 2).attr('r', dotsDiameter / 2).attr('fill', 'black');
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$h = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 30,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 10,
      group: 'chart'
    },
    binsNumber: {
      type: 'number',
      label: 'Number of bins',
      default: 10,
      group: 'chart'
    },
    sortGroupsBy: {
      type: 'text',
      label: 'Sort violins by',
      group: 'chart',
      options: [{
        label: 'Total value (descending)',
        value: 'valueDescending'
      }, {
        label: 'Total value (ascending)',
        value: 'valueAscending'
      }, {
        label: 'Name',
        value: 'name'
      }, {
        label: 'Original',
        value: 'none'
      }],
      default: 'valueDescending'
    },
    interpolation: {
      type: 'text',
      label: 'Type de courbe',
      default: 'Monotone Y',
      options: ['Basis', 'Bundle', 'Cardinal', 'Catmull–Rom', 'Linear', 'Monotone Y', 'Natural', 'Step', 'Step After', 'Step Before'],
      group: 'chart'
    },
    showDots: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart'
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      disabled: {
        showDots: false
      },
      default: 2,
      group: 'chart'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'schemeCategory10'
      },
      group: 'colors'
    }
  };

  var violinplot = {
    metadata: metadata$h,
    dimensions: dimensions$h,
    mapData: mapData$h,
    render: render$h,
    visualOptions: visualOptions$h,
    styles: styles$1
  };

  var img$y = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpolygon class='cls-1' points='41 31 44 31 44 41 42 41 42 42 44 42 45 42 47 42 47 41 45 41 45 31 48 31 48 29 41 29 41 31'/%3e %3cpolygon class='cls-1' points='45 17 45 14 47 14 47 13 42 13 42 14 44 14 44 17 41 17 41 28 48 28 48 17 45 17'/%3e %3cpolygon class='cls-1' points='17 21 19 21 19 20 14 20 14 21 16 21 16 24 13 24 13 29 20 29 20 24 17 24 17 21'/%3e %3cpolygon class='cls-1' points='13 36 16 36 16 40 14 40 14 41 19 41 19 40 17 40 17 36 20 36 20 30 13 30 13 36'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 48.5 8 48.5 8 9.939 9.195 11.135 9.195 9.695'/%3e %3cpolygon class='cls-2' points='31 13 33 13 33 12 28 12 28 13 30 13 30 17 27 17 27 29 34 29 34 17 31 17 31 13'/%3e %3cpolygon class='cls-2' points='27 36 30 36 30 42 28 42 28 43 30 43 31 43 33 43 33 42 31 42 31 36 34 36 34 30 27 30 27 36'/%3e %3c/g%3e%3c/svg%3e";

  var img$z = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-2%2c .cls-4%2c .cls-5 %7b fill: none%3b %7d .cls-1 %7b stroke: black%3b %7d .cls-2%2c .cls-5 %7b stroke: %23ccc%3b %7d .cls-2 %7b stroke-dasharray: 3 3%3b %7d .cls-3 %7b fill: %239e0142%3b %7d .cls-4 %7b stroke: white%3b %7d .cls-6 %7b fill: %235e4fa2%3b %7d .cls-7 %7b fill: %2369bda9%3b %7d .cls-8 %7b fill: %23e0f3a1%3b %7d .cls-9 %7b fill: %23fedd8d%3b %7d .cls-10%2c .cls-11 %7b font-size: 12px%3b font-family: Helvetica%3b %7d .cls-11 %7b letter-spacing: -0.05469em%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cpath class='cls-1' d='M21.70371%2c144.46069v-6.13431H318.5039v6.13431'/%3e %3cline class='cls-1' x1='51.38372' y1='137.76872' x2='51.38372' y2='144.46069'/%3e %3cline class='cls-1' x1='110.74376' y1='137.76872' x2='110.74376' y2='144.46069'/%3e %3cline class='cls-1' x1='170.1038' y1='137.76872' x2='170.1038' y2='144.46069'/%3e %3cline class='cls-1' x1='229.46384' y1='137.76872' x2='229.46384' y2='144.46069'/%3e %3cline class='cls-1' x1='288.82388' y1='137.76872' x2='288.82388' y2='144.46069'/%3e %3cpath class='cls-1' d='M14.8137%2c138.32638h6.89V6.00177h-6.89'/%3e %3cline class='cls-1' x1='21.17371' y1='135.77482' x2='14.8137' y2='135.77482'/%3e %3cline class='cls-1' x1='21.17371' y1='123.97727' x2='14.8137' y2='123.97727'/%3e %3cline class='cls-1' x1='21.17371' y1='112.17972' x2='14.8137' y2='112.17972'/%3e %3cline class='cls-1' x1='21.17371' y1='100.38217' x2='14.8137' y2='100.38217'/%3e %3cline class='cls-1' x1='21.17371' y1='88.58462' x2='14.8137' y2='88.58462'/%3e %3cline class='cls-1' x1='21.17371' y1='76.78707' x2='14.8137' y2='76.78707'/%3e %3cline class='cls-1' x1='21.17371' y1='64.98952' x2='14.8137' y2='64.98952'/%3e %3cline class='cls-1' x1='21.17371' y1='53.19197' x2='14.8137' y2='53.19197'/%3e %3cline class='cls-1' x1='21.17371' y1='41.39442' x2='14.8137' y2='41.39442'/%3e %3cline class='cls-1' x1='21.17371' y1='29.59687' x2='14.8137' y2='29.59687'/%3e %3cline class='cls-1' x1='21.17371' y1='17.79932' x2='14.8137' y2='17.79932'/%3e %3cline class='cls-2' x1='50.85372' y1='125.3662' x2='50.85372' y2='82.12228'/%3e %3crect class='cls-3' x='40.25372' y='98.92789' width='21.20001' height='22.30825'/%3e %3cline class='cls-4' x1='40.25372' y1='117.686' x2='61.45373' y2='117.686'/%3e %3cline class='cls-5' x1='40.25372' y1='125.3662' x2='61.45373' y2='125.3662'/%3e %3cline class='cls-5' x1='40.25372' y1='82.12228' x2='61.45373' y2='82.12228'/%3e %3cline class='cls-2' x1='110.21376' y1='87.58272' x2='110.21376' y2='3.9293'/%3e %3crect class='cls-6' x='99.61376' y='27.0691' width='21.20001' height='45.6098'/%3e %3cline class='cls-4' x1='99.61376' y1='62.32678' x2='120.81377' y2='62.32678'/%3e %3cline class='cls-5' x1='99.61376' y1='87.58272' x2='120.81377' y2='87.58272'/%3e %3cline class='cls-5' x1='99.61376' y1='3.9293' x2='120.81377' y2='3.9293'/%3e %3cline class='cls-2' x1='169.5738' y1='135.51563' x2='169.5738' y2='64.28058'/%3e %3crect class='cls-7' x='158.9738' y='100.93521' width='21.20001' height='29.07392'/%3e %3cline class='cls-4' x1='158.9738' y1='127.173' x2='180.17381' y2='127.173'/%3e %3cline class='cls-5' x1='158.9738' y1='135.51563' x2='180.17381' y2='135.51563'/%3e %3cline class='cls-5' x1='158.9738' y1='64.28058' x2='180.17381' y2='64.28058'/%3e %3cline class='cls-2' x1='228.93384' y1='135.76859' x2='228.93384' y2='121.58534'/%3e %3crect class='cls-8' x='218.33383' y='123.27443' width='21.20001' height='10.86174'/%3e %3cline class='cls-4' x1='218.33383' y1='130.21818' x2='239.53385' y2='130.21818'/%3e %3cline class='cls-5' x1='218.33383' y1='135.76859' x2='239.53385' y2='135.76859'/%3e %3cline class='cls-5' x1='218.33383' y1='121.58534' x2='239.53385' y2='121.58534'/%3e %3cline class='cls-2' x1='288.29388' y1='131.72987' x2='288.29388' y2='76.4192'/%3e %3crect class='cls-9' x='277.69387' y='102.68031' width='21.20001' height='26.90716'/%3e %3cline class='cls-4' x1='277.69387' y1='121.06845' x2='298.89389' y2='121.06845'/%3e %3cline class='cls-5' x1='277.69387' y1='131.72987' x2='298.89389' y2='131.72987'/%3e %3cline class='cls-5' x1='277.69387' y1='76.4192' x2='298.89389' y2='76.4192'/%3e %3ctext class='cls-10' transform='translate(6.67382 139.31954)'%3e2%3c/text%3e %3ctext class='cls-10' transform='translate(6.67382 127.52169)'%3e4%3c/text%3e %3ctext class='cls-10' transform='translate(6.67382 115.72384)'%3e6%3c/text%3e %3ctext class='cls-10' transform='translate(6.67382 103.92696)'%3e8%3c/text%3e %3ctext class='cls-10' transform='translate(0 92.12911)'%3e10%3c/text%3e %3ctext class='cls-10' transform='translate(0 80.33223)'%3e12%3c/text%3e %3ctext class='cls-10' transform='translate(0 68.53438)'%3e14%3c/text%3e %3ctext class='cls-10' transform='translate(0 56.73653)'%3e16%3c/text%3e %3ctext class='cls-10' transform='translate(0 44.93966)'%3e18%3c/text%3e %3ctext class='cls-10' transform='translate(0 33.1418)'%3e20%3c/text%3e %3ctext class='cls-10' transform='translate(0 21.34395)'%3e22%3c/text%3e %3ctext class='cls-10' transform='translate(0 9.54708)'%3e24%3c/text%3e %3ctext class='cls-11' transform='translate(47.70996 155.70137)'%3eA%3c/text%3e %3ctext class='cls-10' transform='translate(106.74219 155.7004)'%3eB%3c/text%3e %3ctext class='cls-10' transform='translate(165.77051 155.7004)'%3eC%3c/text%3e %3ctext class='cls-10' transform='translate(225.13086 155.7004)'%3eD%3c/text%3e %3ctext class='cls-10' transform='translate(284.82227 155.7004)'%3eE%3c/text%3e %3c/g%3e %3ccircle class='cls-5' cx='50.85371' cy='43.32604' r='5'/%3e %3ccircle class='cls-5' cx='228.9338' cy='96.57779' r='5'/%3e %3ccircle class='cls-5' cx='228.9338' cy='94.40557' r='5'/%3e%3c/svg%3e";

  const metadata$i = {
    name: 'Box plot',
    id: 'rawgraphs.boxplot',
    thumbnail: img$z,
    icon: img$y,
    categories: ['distributions'],
    description: 'It summarize a quantitative distribution with five standard statistics: the smallest value, lower quartile, median, upper quartile, and largest value.',
    code: 'https://observablehq.com/@d3/box-plot' // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$i = [{
    id: 'value',
    name: 'Axe Y',
    validTypes: ['number'],
    required: true
  }, {
    id: 'group',
    name: 'Groups',
    validTypes: ['number', 'date', 'string'],
    required: false
  }, {
    id: 'color',
    name: 'Couleur',
    operation: 'get',
    validTypes: ['number', 'string', 'date'],
    required: false,
    aggregation: true,
    aggregationDefault: {
      number: 'sum',
      string: 'csvDistinct',
      date: 'csvDistinct'
    }
  }];

  const mapData$i = function (data, mapping, dataTypes, dimensions) {
    // define aggregators
    // you should provide the dimension name (defined in dimensions.js)
    // and pass mapping, dataTypes, and dimensions.
    const colorAggregator = getDimensionAggregator('color', mapping, dataTypes, dimensions); // add the non-compulsory dimensions.

    'group' in mapping ? null : mapping.group = {
      value: undefined
    };
    'color' in mapping ? null : mapping.color = {
      value: undefined
    }; // we will use rollup to populate a flat array of objects
    // that will be passed to the render

    let results = [];
    rollups(data, v => {
      v.map(d => {
        const item = {
          group: d[mapping.group.value],
          value: d[mapping.value.value],
          color: colorAggregator(v.map(e => e[mapping.color.value]))
        };
        results.push(item);
        return item;
      });
      return v;
    }, d => d[mapping.group.value] // groups grouping
    );
    return results;
  };

  function render$i(svgNode, data, visualOptions, mapping, originalData, styles) {
    let {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // charts options
      barsWidth,
      iqrMultiplier,
      // to compute otuliers
      dotsDiameter,
      yOrigin,
      //legend
      showLegend,
      legendWidth,
      // color
      colorScale,
      // labels
      showValues
    } = visualOptions; // Margin convention

    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'viz');
    const yDomain = yOrigin ? [0, max(data, d => d.value)] : extent(data, d => d.value);
    const yScale = linear$2().domain(yDomain).nice().range([chartHeight, 0]);
    const groupsDomain = [...new Set(data.map(d => d.group))];
    const xScale = point().rangeRound([0, chartWidth]).domain(groupsDomain).padding(0.5); // if series is exposed, recreate the nested structure

    const nestedData = rollups(data, v => {
      const values = v.map(d => d.value).sort(ascending);
      const min = values[0];
      const max = values[values.length - 1];
      const q1 = quantile(values, 0.25);
      const q2 = quantile(values, 0.5);
      const q3 = quantile(values, 0.75);
      const iqr = q3 - q1; // interquartile range

      const r0 = Math.max(min, q1 - iqr * iqrMultiplier);
      const r1 = Math.min(max, q3 + iqr * iqrMultiplier);
      return {
        group: v[0].group,
        color: v[0].color,
        values: v,
        quartiles: [q1, q2, q3],
        range: [r0, r1],
        outliers: v.filter(d => d.value < r0 || d.value > r1)
      };
    }, d => d.group); // append scales

    svg.append('g').attr('id', 'y axis').call(axisLeft(yScale)).append('text').styles(styles.axisLabel).attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['value'].value);
    svg.append('g').attr('id', 'x axis').attr('transform', 'translate(0,' + chartHeight + ')').call(axisBottom(xScale)); //append boxplots

    const boxplots = svg.append('g').attr('id', 'boxplots').selectAll('g').data(nestedData).join('g'); // add the line between quartiles

    boxplots.append('line').attr('x1', d => xScale(d[1].group)).attr('x2', d => xScale(d[1].group)).attr('y1', d => yScale(d[1].range[1])).attr('y2', d => yScale(d[1].range[0])).attr('stroke', d => colorScale(d[1].color)).attr('stroke-dasharray', 4); // add lines at top and bottom

    boxplots.append('line').attr('x1', d => xScale(d[1].group) - barsWidth / 2).attr('x2', d => xScale(d[1].group) + barsWidth / 2).attr('y1', d => yScale(d[1].range[1])).attr('y2', d => yScale(d[1].range[1])).attr('stroke', d => colorScale(d[1].color));
    boxplots.append('line').attr('x1', d => xScale(d[1].group) - barsWidth / 2).attr('x2', d => xScale(d[1].group) + barsWidth / 2).attr('y1', d => yScale(d[1].range[0])).attr('y2', d => yScale(d[1].range[0])).attr('stroke', d => colorScale(d[1].color)); // add the boxes

    boxplots.append('rect').attr('x', d => xScale(d[1].group) - barsWidth / 2).attr('y', d => yScale(d[1].quartiles[2])).attr('width', barsWidth).attr('height', d => yScale(d[1].quartiles[0]) - yScale(d[1].quartiles[2])).attr('fill', d => colorScale(d[1].color)); //add the half line

    boxplots.append('line').attr('x1', d => xScale(d[1].group) - barsWidth / 2).attr('y1', d => yScale(d[1].quartiles[1])).attr('x2', d => xScale(d[1].group) + barsWidth / 2).attr('y2', d => yScale(d[1].quartiles[1])).attr('stroke', background);
    boxplots.selectAll('circle').data(d => d[1].outliers).join('circle').attr('r', dotsDiameter / 2).attr('cx', d => xScale(d.group)).attr('cy', d => yScale(d.value)).attr('fill', background).attr('stroke', d => colorScale(d.color));

    if (showValues) {
      const valuesLabels = svg.append('g').attr('id', 'boxplots').selectAll('g').data(nestedData).join('g');
      valuesLabels.append('text').styles(styles.labelSecondary).attr('x', d => xScale(d[1].group) + barsWidth / 2 + 4).attr('y', d => yScale(d[1].range[1])).attr('dominant-baseline', 'middle').text(d => d[1].range[1]);
      valuesLabels.append('text').styles(styles.labelSecondary).attr('x', d => xScale(d[1].group) + barsWidth / 2 + 4).attr('y', d => yScale(d[1].range[0])).attr('dominant-baseline', 'middle').text(d => d[1].range[0]);
      valuesLabels.append('text').styles(styles.labelSecondary).attr('x', d => xScale(d[1].group) + barsWidth / 2 + 4).attr('y', d => yScale(d[1].quartiles[1])).attr('dominant-baseline', 'middle').text(d => d[1].quartiles[1]);
      valuesLabels.append('text').styles(styles.labelSecondary).attr('x', d => xScale(d[1].group) - barsWidth / 2 - 4).attr('y', d => yScale(d[1].quartiles[0])).attr('dominant-baseline', 'middle').attr('text-anchor', 'end').text(d => d[1].quartiles[0]);
      valuesLabels.append('text').styles(styles.labelSecondary).attr('x', d => xScale(d[1].group) - 4).attr('y', d => yScale(d[1].quartiles[2])).attr('dominant-baseline', 'middle').attr('text-anchor', 'end').text(d => d[1].quartiles[2]);
    }

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$i = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 10,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 30,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    barsWidth: {
      type: 'number',
      label: 'Bars width',
      default: 20,
      group: 'chart'
    },
    iqrMultiplier: {
      type: 'number',
      label: 'Interquartile range multiplier',
      default: 1.5,
      group: 'chart'
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart'
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'schemeCategory10'
      },
      group: 'colors'
    },
    showValues: {
      type: 'boolean',
      label: 'Show boxpot values',
      default: true,
      group: 'labels'
    }
  };

  var boxplot = {
    metadata: metadata$i,
    dimensions: dimensions$i,
    mapData: mapData$i,
    render: render$i,
    visualOptions: visualOptions$i,
    styles: styles$1
  };

  var img$A = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M25%2c19.79l-6.5-3.7143L12%2c19.79v7.42l6.5%2c3.7143L25%2c27.21ZM17%2c20a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c17%2c20Z'/%3e %3cpath class='cls-1' d='M9%2c29.5043V41.4957l2.5%2c1.4286L18%2c39.21V31.79l-6.5-3.7143ZM16%2c35a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c16%2c35Z'/%3e %3cpath class='cls-1' d='M26%2c43.79V47H39V43.79l-6.5-3.7143ZM34%2c43a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c34%2c43Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3cpath class='cls-2' d='M32%2c31.79l-6.5-3.7143L19%2c31.79v7.42l6.5%2c3.7143L32%2c39.21ZM21%2c33a1%2c1%2c0%2c1%2c1%2c1%2c1A1%2c1%2c0%2c0%2c1%2c21%2c33Zm2%2c6a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c23%2c39Zm3-5a1%2c1%2c0%2c1%2c1%2c1%2c1A1%2c1%2c0%2c0%2c1%2c26%2c34Zm2%2c6a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c28%2c40Z'/%3e %3cpath class='cls-2' d='M32.5%2c16.0757%2c26%2c19.79v7.42l6.5%2c3.7143L39%2c27.21V19.79ZM28%2c22a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c28%2c22Zm5%2c0a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c33%2c22Zm3%2c5a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c36%2c27Z'/%3e %3c/g%3e%3c/svg%3e";

  var img$B = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-19 %7b fill: none%3b %7d .cls-2 %7b clip-path: url(%23clip-path)%3b %7d .cls-3 %7b fill: %2369bda9%3b %7d .cls-3%2c .cls-4 %7b opacity: 0.25%3b %7d .cls-20%2c .cls-3%2c .cls-4%2c .cls-5%2c .cls-6 %7b isolation: isolate%3b %7d .cls-16%2c .cls-4%2c .cls-5%2c .cls-6 %7b fill: %239e0142%3b %7d .cls-5 %7b opacity: 0.5%3b %7d .cls-6 %7b opacity: 0.75%3b %7d .cls-7 %7b clip-path: url(%23clip-path-5)%3b %7d .cls-8 %7b clip-path: url(%23clip-path-7)%3b %7d .cls-9 %7b fill: %23f6cc86%3b %7d .cls-10 %7b fill: %23fedd8d%3b %7d .cls-11 %7b fill: %23e6a978%3b %7d .cls-12 %7b fill: %23cd7663%3b %7d .cls-13 %7b fill: %23de9871%3b %7d .cls-14 %7b fill: %23d6876a%3b %7d .cls-15 %7b fill: %23c4645d%3b %7d .cls-17 %7b fill: %23bb5256%3b %7d .cls-18 %7b fill: %23eeba7f%3b %7d .cls-19 %7b stroke: black%3b %7d .cls-20 %7b font-size: 10px%3b font-family: ArialMT%2c Arial%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' y='211.00006' width='320' height='21.66667'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-5'%3e %3crect class='cls-1' y='235.66692' width='320' height='21.66667'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-7'%3e %3crect class='cls-1' x='20' y='1' width='300' height='140'/%3e %3c/clipPath%3e %3c/defs%3e %3cg%3e %3cg%3e %3cg class='cls-2'%3e %3cpath class='cls-3' d='M0%2c160.39739c15.99124%2c0%2c15.99124%2c123.4529%2c31.98248%2c123.4529S47.97371%2c189.02235%2c63.965%2c189.02235c16.035%2c0%2c16.035%2c93.1051%2c32.0701%2c93.1051%2c15.99123%2c0%2c15.99123-118.83865%2c31.98247-118.83865s15.99124-.06693%2c31.98248-.06693%2c15.99124%2c46.58451%2c31.98248%2c46.58451c16.035%2c0%2c16.035-14.0354%2c32.07009-14.0354%2c15.99124%2c0%2c15.99124%2c6.891%2c31.98246%2c6.891s15.99125-56.66193%2c31.98249-56.66193S304.00876%2c170.74812%2c320%2c170.74812v61.91861H0Z'/%3e %3c/g%3e %3cg class='cls-2'%3e %3cpath class='cls-4' d='M0%2c138.73073c15.99124%2c0%2c15.99124%2c123.45289%2c31.98248%2c123.45289S47.97371%2c167.35569%2c63.965%2c167.35569c16.035%2c0%2c16.035%2c93.10509%2c32.0701%2c93.10509%2c15.99123%2c0%2c15.99123-118.83865%2c31.98247-118.83865S144.00876%2c141.5552%2c160%2c141.5552s15.99124%2c46.58451%2c31.98248%2c46.58451c16.035%2c0%2c16.035-14.0354%2c32.07009-14.0354%2c15.99124%2c0%2c15.99124%2c6.891%2c31.98246%2c6.891s15.99125-56.66193%2c31.98249-56.66193S304.00876%2c149.08145%2c320%2c149.08145v61.91861H0Z'/%3e %3c/g%3e %3cg class='cls-2'%3e %3cpath class='cls-5' d='M0%2c117.06406c15.99124%2c0%2c15.99124%2c123.4529%2c31.98248%2c123.4529S47.97371%2c145.689%2c63.965%2c145.689c16.035%2c0%2c16.035%2c93.1051%2c32.0701%2c93.1051%2c15.99123%2c0%2c15.99123-118.83865%2c31.98247-118.83865s15.99124-.06693%2c31.98248-.06693%2c15.99124%2c46.5845%2c31.98248%2c46.5845c16.035%2c0%2c16.035-14.03539%2c32.07009-14.03539%2c15.99124%2c0%2c15.99124%2c6.891%2c31.98246%2c6.891s15.99125-56.66192%2c31.98249-56.66192S304.00876%2c127.41479%2c320%2c127.41479v61.9186H0Z'/%3e %3c/g%3e %3cg class='cls-2'%3e %3cpath class='cls-6' d='M0%2c95.39739c15.99124%2c0%2c15.99124%2c123.4529%2c31.98248%2c123.4529S47.97371%2c124.02235%2c63.965%2c124.02235c16.035%2c0%2c16.035%2c93.1051%2c32.0701%2c93.1051%2c15.99123%2c0%2c15.99123-118.83865%2c31.98247-118.83865S144.00876%2c98.22187%2c160%2c98.22187s15.99124%2c46.58451%2c31.98248%2c46.58451c16.035%2c0%2c16.035-14.0354%2c32.07009-14.0354%2c15.99124%2c0%2c15.99124%2c6.891%2c31.98246%2c6.891s15.99125-56.66192%2c31.98249-56.66192S304.00876%2c105.74812%2c320%2c105.74812v61.91861H0Z'/%3e %3c/g%3e %3c/g%3e %3cg%3e %3cg class='cls-7'%3e %3cpath class='cls-4' d='M0%2c153.53923c15.99124%2c0%2c15.99124%2c7.81562%2c31.98248%2c7.81562s15.99123%2c80.513%2c31.98247%2c80.513c16.035%2c0%2c16.035-40.4657%2c32.0701-40.4657%2c15.99123%2c0%2c15.99123%2c22.22969%2c31.98247%2c22.22969S144.00876%2c213.53575%2c160%2c213.53575s15.99124-54.05453%2c31.98248-54.05453c16.035%2c0%2c16.035%2c69.90757%2c32.07009%2c69.90757%2c15.99124%2c0%2c15.99124%2c33.73491%2c31.98246%2c33.73491s15.99125-49.05008%2c31.98249-49.05008S304.00876%2c149.00025%2c320%2c149.00025v86.66667H0Z'/%3e %3c/g%3e %3cg class='cls-7'%3e %3cpath class='cls-5' d='M0%2c131.87257c15.99124%2c0%2c15.99124%2c7.81562%2c31.98248%2c7.81562s15.99123%2c80.513%2c31.98247%2c80.513c16.035%2c0%2c16.035-40.4657%2c32.0701-40.4657%2c15.99123%2c0%2c15.99123%2c22.2297%2c31.98247%2c22.2297S144.00876%2c191.86908%2c160%2c191.86908s15.99124-54.05452%2c31.98248-54.05452c16.035%2c0%2c16.035%2c69.90757%2c32.07009%2c69.90757%2c15.99124%2c0%2c15.99124%2c33.7349%2c31.98246%2c33.7349S272.02628%2c192.407%2c288.01752%2c192.407%2c304.00876%2c127.33359%2c320%2c127.33359v86.66666H0Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg%3e %3cg class='cls-8'%3e %3cg%3e %3cpath class='cls-9' d='M41.56922%2c8l13.8564%2c8V32l-13.8564%2c8L27.71281%2c32V16Z'/%3e %3cpath class='cls-10' d='M55.42562%2c80%2c69.282%2c88v16l-13.85641%2c8-13.8564-8V88Z'/%3e %3cpath class='cls-10' d='M69.282%2c8l13.8564%2c8V32L69.282%2c40%2c55.42563%2c32V16Z'/%3e %3cpath class='cls-10' d='M69.282%2c104l13.8564%2c8v16L69.282%2c136l-13.85641-8V112Z'/%3e %3cpath class='cls-11' d='M83.13844%2c80l13.8564%2c8v16l-13.8564%2c8L69.282%2c104V88Z'/%3e %3cpath class='cls-12' d='M96.99484%2c56l13.85641%2c8V80L96.99484%2c88l-13.8564-8V64Z'/%3e %3cpath class='cls-10' d='M96.99484%2c104l13.85641%2c8v16l-13.85641%2c8-13.8564-8V112Z'/%3e %3cpath class='cls-13' d='M96.99484%2c8l13.85641%2c8V32L96.99484%2c40l-13.8564-8V16Z'/%3e %3cpath class='cls-10' d='M83.13844%2c32l13.8564%2c8V56l-13.8564%2c8L69.282%2c56V40Z'/%3e %3cpath class='cls-13' d='M110.85125%2c32l13.85641%2c8V56l-13.85641%2c8L96.99484%2c56V40Z'/%3e %3cpath class='cls-10' d='M110.85125%2c80l13.85641%2c8v16l-13.85641%2c8-13.85641-8V88Z'/%3e %3cpath class='cls-12' d='M124.70766%2c56l13.8564%2c8V80l-13.8564%2c8-13.85641-8V64Z'/%3e %3cpath class='cls-14' d='M124.70766%2c8l13.8564%2c8V32l-13.8564%2c8-13.85641-8V16Z'/%3e %3cpath class='cls-15' d='M138.56407%2c80l13.85641%2c8v16l-13.85641%2c8-13.8564-8V88Z'/%3e %3cpath class='cls-16' d='M138.56407%2c32l13.85641%2c8V56l-13.85641%2c8-13.8564-8V40Z'/%3e %3cpath class='cls-17' d='M152.42047%2c56l13.85641%2c8V80l-13.85641%2c8-13.85641-8V64Z'/%3e %3cpath class='cls-15' d='M166.27687%2c32l13.85641%2c8V56l-13.85641%2c8-13.85641-8V40Z'/%3e %3cpath class='cls-15' d='M166.27687%2c80l13.85641%2c8v16l-13.85641%2c8-13.85641-8V88Z'/%3e %3cpath class='cls-10' d='M152.42047%2c8l13.85641%2c8V32l-13.85641%2c8-13.85641-8V16Z'/%3e %3cpath class='cls-10' d='M152.42047%2c104l13.85641%2c8v16l-13.85641%2c8-13.85641-8V112Z'/%3e %3cpath class='cls-17' d='M180.13329%2c56l13.8564%2c8V80l-13.8564%2c8-13.85641-8V64Z'/%3e %3cpath class='cls-11' d='M180.13329%2c8l13.8564%2c8V32l-13.8564%2c8-13.85641-8V16Z'/%3e %3cpath class='cls-18' d='M180.13329%2c104l13.8564%2c8v16l-13.8564%2c8-13.85641-8V112Z'/%3e %3cpath class='cls-12' d='M193.98969%2c32l13.8564%2c8V56l-13.8564%2c8-13.85641-8V40Z'/%3e %3cpath class='cls-12' d='M193.98969%2c80l13.8564%2c8v16l-13.8564%2c8-13.85641-8V88Z'/%3e %3cpath class='cls-9' d='M193.98969-16l13.8564%2c8V8l-13.8564%2c8L180.13328%2c8V-8Z'/%3e %3cpath class='cls-11' d='M207.8461%2c8l13.85641%2c8V32L207.8461%2c40l-13.85641-8V16Z'/%3e %3cpath class='cls-14' d='M207.8461%2c56l13.85641%2c8V80L207.8461%2c88l-13.85641-8V64Z'/%3e %3cpath class='cls-12' d='M221.7025%2c32l13.85641%2c8V56L221.7025%2c64l-13.85641-8V40Z'/%3e %3cpath class='cls-12' d='M221.7025%2c80l13.85641%2c8v16l-13.85641%2c8-13.85641-8V88Z'/%3e %3cpath class='cls-15' d='M235.55891%2c8l13.85641%2c8V32l-13.85641%2c8-13.8564-8V16Z'/%3e %3cpath class='cls-17' d='M235.55891%2c56l13.85641%2c8V80l-13.85641%2c8-13.8564-8V64Z'/%3e %3cpath class='cls-11' d='M249.41531%2c32l13.85641%2c8V56l-13.85641%2c8-13.8564-8V40Z'/%3e %3cpath class='cls-10' d='M249.41531%2c80l13.85641%2c8v16l-13.85641%2c8-13.8564-8V88Z'/%3e %3cpath class='cls-10' d='M235.55891%2c104l13.85641%2c8v16l-13.85641%2c8-13.8564-8V112Z'/%3e %3cpath class='cls-14' d='M263.27173%2c56l13.8564%2c8V80l-13.8564%2c8-13.85641-8V64Z'/%3e %3cpath class='cls-10' d='M263.27173%2c104l13.8564%2c8v16l-13.8564%2c8-13.85641-8V112Z'/%3e %3cpath class='cls-18' d='M263.27173%2c8l13.8564%2c8V32l-13.8564%2c8-13.85641-8V16Z'/%3e %3cpath class='cls-17' d='M277.12814%2c32l13.85641%2c8V56l-13.85641%2c8-13.8564-8V40Z'/%3e %3cpath class='cls-9' d='M277.12814%2c80l13.85641%2c8v16l-13.85641%2c8-13.8564-8V88Z'/%3e %3cpath class='cls-10' d='M290.98453%2c8l13.8564%2c8V32l-13.8564%2c8-13.85641-8V16Z'/%3e %3cpath class='cls-14' d='M290.98453%2c56l13.8564%2c8V80l-13.8564%2c8-13.85641-8V64Z'/%3e %3cpath class='cls-18' d='M304.84094%2c32l13.85641%2c8V56l-13.85641%2c8-13.8564-8V40Z'/%3e %3cpath class='cls-10' d='M332.55374%2c32l13.85641%2c8V56l-13.85641%2c8-13.8564-8V40Z'/%3e %3c/g%3e %3c/g%3e %3ccircle cx='38.32304' cy='21.59011' r='1'/%3e %3ccircle cx='52.49576' cy='23.40932' r='1'/%3e %3ccircle cx='60.44576' cy='83.39714' r='1'/%3e %3ccircle cx='65.61005' cy='31.1316' r='1'/%3e %3ccircle cx='74.60188' cy='111.85838' r='1'/%3e %3ccircle cx='77.76858' cy='90.94259' r='1'/%3e %3ccircle cx='86.61999' cy='74.25496' r='1'/%3e %3ccircle cx='86.6712' cy='83.70636' r='1'/%3e %3ccircle cx='87.42301' cy='109.35522' r='1'/%3e %3ccircle cx='88.92403' cy='24.47722' r='1'/%3e %3ccircle cx='90.39632' cy='66.83188' r='1'/%3e %3ccircle cx='91.98116' cy='42.52938' r='1'/%3e %3ccircle cx='92.47073' cy='25.87473' r='1'/%3e %3ccircle cx='92.61495' cy='88.46284' r='1'/%3e %3ccircle cx='93.02405' cy='94.83081' r='1'/%3e %3ccircle cx='94.22984' cy='67.54187' r='1'/%3e %3ccircle cx='96.94691' cy='58.4642' r='1'/%3e %3ccircle cx='100.42859' cy='82.48258' r='1'/%3e %3ccircle cx='102.52311' cy='35.11887' r='1'/%3e %3ccircle cx='103.24899' cy='38.21585' r='1'/%3e %3ccircle cx='103.36072' cy='75.21193' r='1'/%3e %3ccircle cx='103.78277' cy='60.32384' r='1'/%3e %3ccircle cx='105.33926' cy='32.87811' r='1'/%3e %3ccircle cx='107.0835' cy='91.84366' r='1'/%3e %3ccircle cx='108.5004' cy='21.95532' r='1'/%3e %3ccircle cx='113.01394' cy='73.88742' r='1'/%3e %3ccircle cx='113.41276' cy='19.67751' r='1'/%3e %3ccircle cx='114.19029' cy='45.92928' r='1'/%3e %3ccircle cx='118.76965' cy='23.94542' r='1'/%3e %3ccircle cx='119.43156' cy='60.12417' r='1'/%3e %3ccircle cx='119.77742' cy='25.44837' r='1'/%3e %3ccircle cx='121.20637' cy='57.13057' r='1'/%3e %3ccircle cx='123.49448' cy='36.78326' r='1'/%3e %3ccircle cx='123.69561' cy='46.00414' r='1'/%3e %3ccircle cx='123.99655' cy='49.204' r='1'/%3e %3ccircle cx='124.6083' cy='36.1407' r='1'/%3e %3ccircle cx='126.08316' cy='76.35784' r='1'/%3e %3ccircle cx='126.22024' cy='98.07559' r='1'/%3e %3ccircle cx='130.09554' cy='100.19208' r='1'/%3e %3ccircle cx='130.87027' cy='90.20223' r='1'/%3e %3ccircle cx='131.0865' cy='66.85661' r='1'/%3e %3ccircle cx='131.21321' cy='38.97204' r='1'/%3e %3ccircle cx='131.93437' cy='62.47405' r='1'/%3e %3ccircle cx='132.31859' cy='42.89193' r='1'/%3e %3ccircle cx='132.32964' cy='49.67204' r='1'/%3e %3ccircle cx='133.2731' cy='54.61587' r='1'/%3e %3ccircle cx='133.77255' cy='90.07927' r='1'/%3e %3ccircle cx='133.80344' cy='32.68693' r='1'/%3e %3ccircle cx='133.9249' cy='101.40845' r='1'/%3e %3ccircle cx='134.72356' cy='106.09485' r='1'/%3e %3ccircle cx='135.37085' cy='64.2074' r='1'/%3e %3ccircle cx='136.16492' cy='40.41228' r='1'/%3e %3ccircle cx='136.40849' cy='61.49956' r='1'/%3e %3ccircle cx='136.68027' cy='86.60569' r='1'/%3e %3ccircle cx='136.87006' cy='49.71107' r='1'/%3e %3ccircle cx='137.74294' cy='80.37561' r='1'/%3e %3ccircle cx='140.3351' cy='97.18262' r='1'/%3e %3ccircle cx='140.87508' cy='50.70391' r='1'/%3e %3ccircle cx='141.57964' cy='48.53189' r='1'/%3e %3ccircle cx='142.03073' cy='47.16108' r='1'/%3e %3ccircle cx='144.50058' cy='51.84983' r='1'/%3e %3ccircle cx='145.42189' cy='77.10619' r='1'/%3e %3ccircle cx='146.08997' cy='61.58826' r='1'/%3e %3ccircle cx='146.94292' cy='82.83745' r='1'/%3e %3ccircle cx='147.34398' cy='63.22549' r='1'/%3e %3ccircle cx='149.25877' cy='62.20906' r='1'/%3e %3ccircle cx='150.77028' cy='62.8127' r='1'/%3e %3ccircle cx='151.98093' cy='42.36312' r='1'/%3e %3ccircle cx='152.823' cy='69.39218' r='1'/%3e %3ccircle cx='153.22781' cy='50.84964' r='1'/%3e %3ccircle cx='154.60042' cy='105.42798' r='1'/%3e %3ccircle cx='154.77328' cy='57.07066' r='1'/%3e %3ccircle cx='154.81825' cy='12.60605' r='1'/%3e %3ccircle cx='157.89113' cy='101.19066' r='1'/%3e %3ccircle cx='160.114' cy='87.40966' r='1'/%3e %3ccircle cx='161.47189' cy='61.61201' r='1'/%3e %3ccircle cx='161.71721' cy='39.96188' r='1'/%3e %3ccircle cx='165.65215' cy='77.71542' r='1'/%3e %3ccircle cx='165.72305' cy='121.53084' r='1'/%3e %3ccircle cx='166.34642' cy='77.38549' r='1'/%3e %3ccircle cx='166.9825' cy='52.1261' r='1'/%3e %3ccircle cx='167.19795' cy='52.6883' r='1'/%3e %3ccircle cx='168.95061' cy='67.56242' r='1'/%3e %3ccircle cx='169.14148' cy='35.49652' r='1'/%3e %3ccircle cx='169.7359' cy='87.85641' r='1'/%3e %3ccircle cx='169.78708' cy='24.64887' r='1'/%3e %3ccircle cx='170.70462' cy='87.20129' r='1'/%3e %3ccircle cx='173.07762' cy='89.27888' r='1'/%3e %3ccircle cx='174.33919' cy='24.05409' r='1'/%3e %3ccircle cx='174.64963' cy='73.96477' r='1'/%3e %3ccircle cx='174.7056' cy='49.59632' r='1'/%3e %3ccircle cx='174.87241' cy='78.03171' r='1'/%3e %3ccircle cx='175.52103' cy='58.93037' r='1'/%3e %3ccircle cx='175.70824' cy='68.96045' r='1'/%3e %3ccircle cx='176.99036' cy='103.52292' r='1'/%3e %3ccircle cx='177.54295' cy='94.58658' r='1'/%3e %3ccircle cx='178.91647' cy='84.58635' r='1'/%3e %3ccircle cx='179.25645' cy='71.96732' r='1'/%3e %3ccircle cx='179.97984' cy='31.36624' r='1'/%3e %3ccircle cx='181.87665' cy='14.14998' r='1'/%3e %3ccircle cx='182.87769' cy='118.43027' r='1'/%3e %3ccircle cx='186.50861' cy='113.32676' r='1'/%3e %3ccircle cx='186.8208' cy='54.89283' r='1'/%3e %3ccircle cx='187.77008' cy='44.21973' r='1'/%3e %3ccircle cx='188.59694' cy='84.49614' r='1'/%3e %3ccircle cx='188.82339' cy='12.5896' r='1'/%3e %3ccircle cx='189.82109' cy='92.87805' r='1'/%3e %3ccircle cx='189.82338' cy='41.45876' r='1'/%3e %3ccircle cx='191.26877' cy='81.20064' r='1'/%3e %3ccircle cx='191.78523' r='1'/%3e %3ccircle cx='192.60437' cy='113.95029' r='1'/%3e %3ccircle cx='193.30939' cy='78.82208' r='1'/%3e %3ccircle cx='193.55406' cy='49.28883' r='1'/%3e %3ccircle cx='196.43811' cy='37.29371' r='1'/%3e %3ccircle cx='196.99081' cy='107.28347' r='1'/%3e %3ccircle cx='197.70358' cy='16.64383' r='1'/%3e %3ccircle cx='201.13907' cy='48.16805' r='1'/%3e %3ccircle cx='201.74266' cy='90.48852' r='1'/%3e %3ccircle cx='204.56349' cy='91.96473' r='1'/%3e %3ccircle cx='204.94' cy='62.8555' r='1'/%3e %3ccircle cx='205.54945' cy='42.53102' r='1'/%3e %3ccircle cx='206.48604' cy='85.98101' r='1'/%3e %3ccircle cx='206.95169' cy='37.81148' r='1'/%3e %3ccircle cx='206.97296' cy='94.87657' r='1'/%3e %3ccircle cx='207.34442' cy='93.82526' r='1'/%3e %3ccircle cx='207.97401' cy='50.26892' r='1'/%3e %3ccircle cx='210.34674' cy='93.73812' r='1'/%3e %3ccircle cx='211.01447' cy='15.12615' r='1'/%3e %3ccircle cx='211.21385' cy='60.4245' r='1'/%3e %3ccircle cx='211.36311' cy='29.83943' r='1'/%3e %3ccircle cx='214.50754' cy='98.21217' r='1'/%3e %3ccircle cx='214.65407' cy='70.84876' r='1'/%3e %3ccircle cx='215.18466' cy='81.12201' r='1'/%3e %3ccircle cx='216.43739' cy='35.68865' r='1'/%3e %3ccircle cx='216.47025' cy='56.91173' r='1'/%3e %3ccircle cx='217.02846' cy='67.11412' r='1'/%3e %3ccircle cx='217.42155' cy='41.28229' r='1'/%3e %3ccircle cx='219.084' cy='59.86183' r='1'/%3e %3ccircle cx='220.30133' cy='87.2547' r='1'/%3e %3ccircle cx='221.41441' cy='90.66864' r='1'/%3e %3ccircle cx='222.07625' cy='32.90704' r='1'/%3e %3ccircle cx='224.03835' cy='38.66934' r='1'/%3e %3ccircle cx='225.72844' cy='89.99196' r='1'/%3e %3ccircle cx='227.83069' cy='51.31975' r='1'/%3e %3ccircle cx='228.17136' cy='90.39344' r='1'/%3e %3ccircle cx='230.02266' cy='35.07605' r='1'/%3e %3ccircle cx='232.414' cy='81.09338' r='1'/%3e %3ccircle cx='234.08897' cy='98.90989' r='1'/%3e %3ccircle cx='235.07846' cy='32.54391' r='1'/%3e %3ccircle cx='235.29201' cy='72.77258' r='1'/%3e %3ccircle cx='237.09044' cy='28.48392' r='1'/%3e %3ccircle cx='237.68578' cy='43.5965' r='1'/%3e %3ccircle cx='238.19859' cy='35.17629' r='1'/%3e %3ccircle cx='238.4971' cy='85.15779' r='1'/%3e %3ccircle cx='239.32925' cy='81.05579' r='1'/%3e %3ccircle cx='239.52365' cy='72.70513' r='1'/%3e %3ccircle cx='240.0152' cy='23.24623' r='1'/%3e %3ccircle cx='241.3036' cy='91.93377' r='1'/%3e %3ccircle cx='241.32759' cy='63.01525' r='1'/%3e %3ccircle cx='241.49347' cy='77.62574' r='1'/%3e %3ccircle cx='241.69844' cy='67.28675' r='1'/%3e %3ccircle cx='243.40215' cy='75.10258' r='1'/%3e %3ccircle cx='244.67767' cy='28.65452' r='1'/%3e %3ccircle cx='244.71338' cy='111.62005' r='1'/%3e %3ccircle cx='249.21855' cy='31.44456' r='1'/%3e %3ccircle cx='250.4653' cy='36.55717' r='1'/%3e %3ccircle cx='251.43118' cy='36.06714' r='1'/%3e %3ccircle cx='255.25816' cy='60.1146' r='1'/%3e %3ccircle cx='259.49341' cy='61.9194' r='1'/%3e %3ccircle cx='260.64539' cy='70.75118' r='1'/%3e %3ccircle cx='261.1203' cy='66.2985' r='1'/%3e %3ccircle cx='263.62469' cy='108.00381' r='1'/%3e %3ccircle cx='266.69278' cy='33.42341' r='1'/%3e %3ccircle cx='268.05728' cy='38.05266' r='1'/%3e %3ccircle cx='268.12283' cy='75.59389' r='1'/%3e %3ccircle cx='268.42709' cy='14.44066' r='1'/%3e %3ccircle cx='269.60773' cy='60.48765' r='1'/%3e %3ccircle cx='270.6351' cy='50.92056' r='1'/%3e %3ccircle cx='272.01401' cy='91.03019' r='1'/%3e %3ccircle cx='273.73779' cy='76.68768' r='1'/%3e %3ccircle cx='275.45755' cy='53.92678' r='1'/%3e %3ccircle cx='276.69852' cy='28.57115' r='1'/%3e %3ccircle cx='277.9133' cy='49.51331' r='1'/%3e %3ccircle cx='278.15622' cy='26.34691' r='1'/%3e %3ccircle cx='279.41553' cy='87.46078' r='1'/%3e %3ccircle cx='281.14722' cy='53.95106' r='1'/%3e %3ccircle cx='281.36905' cy='39.35709' r='1'/%3e %3ccircle cx='282.95462' cy='69.15512' r='1'/%3e %3ccircle cx='283.33459' cy='58.45011' r='1'/%3e %3ccircle cx='288.10764' cy='63.43238' r='1'/%3e %3ccircle cx='289.0979' cy='41.32912' r='1'/%3e %3ccircle cx='290.58533' cy='39.29733' r='1'/%3e %3ccircle cx='291.59796' cy='65.10077' r='1'/%3e %3ccircle cx='295.14908' cy='79.89216' r='1'/%3e %3ccircle cx='296.42517' cy='56.1131' r='1'/%3e %3ccircle cx='296.88855' cy='60.54775' r='1'/%3e %3ccircle cx='298.17368' cy='52.00466' r='1'/%3e %3ccircle cx='302.94003' cy='65.00423' r='1'/%3e %3ccircle cx='305.71429' cy='59.70079' r='1'/%3e %3ccircle cx='320' cy='53.3843' r='1'/%3e %3cg%3e %3cpath class='cls-19' d='M14%2c140.5h6.5V.5H14'/%3e %3cg%3e %3cline class='cls-19' x1='20' y1='140.5' x2='14' y2='140.5'/%3e %3ctext class='cls-20' transform='translate(5.43848 143.69998)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='123.68075' x2='14' y2='123.68075'/%3e %3ctext class='cls-20' transform='translate(-0.12305 126.88074)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='106.86152' x2='14' y2='106.86152'/%3e %3ctext class='cls-20' transform='translate(-0.12305 110.06152)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='90.04227' x2='14' y2='90.04227'/%3e %3ctext class='cls-20' transform='translate(-0.12305 93.24228)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='73.22304' x2='14' y2='73.22304'/%3e %3ctext class='cls-20' transform='translate(-0.12305 76.42303)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='56.40379' x2='14' y2='56.40379'/%3e %3ctext class='cls-20' transform='translate(-0.12305 59.60379)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='39.58455' x2='14' y2='39.58455'/%3e %3ctext class='cls-20' transform='translate(-0.12305 42.78455)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='22.76531' x2='14' y2='22.76531'/%3e %3ctext class='cls-20' transform='translate(-0.12305 25.9653)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='20' y1='5.94607' x2='14' y2='5.94607'/%3e %3ctext class='cls-20' transform='translate(-0.12305 9.14609)'%3e80%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-19' d='M20.5%2c146v-5.5h300V146'/%3e %3cg%3e %3cline class='cls-19' x1='20.5' y1='140' x2='20.5' y2='146'/%3e %3ctext class='cls-20' transform='translate(17.71924 156.10001)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='57.5048' y1='140' x2='57.5048' y2='146'/%3e %3ctext class='cls-20' transform='translate(51.94324 156.10001)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='94.50961' y1='140' x2='94.50961' y2='146'/%3e %3ctext class='cls-20' transform='translate(88.94812 156.10001)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='131.5144' y1='140' x2='131.5144' y2='146'/%3e %3ctext class='cls-20' transform='translate(125.95288 156.10001)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='168.51921' y1='140' x2='168.51921' y2='146'/%3e %3ctext class='cls-20' transform='translate(162.95764 156.10001)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='205.524' y1='140' x2='205.524' y2='146'/%3e %3ctext class='cls-20' transform='translate(199.96252 156.10001)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='242.52881' y1='140' x2='242.52881' y2='146'/%3e %3ctext class='cls-20' transform='translate(236.96729 156.10001)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='279.5336' y1='140' x2='279.5336' y2='146'/%3e %3ctext class='cls-20' transform='translate(273.97205 156.10001)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-19' x1='316.53842' y1='140' x2='316.53842' y2='146'/%3e %3ctext class='cls-20' transform='translate(310.97693 156.10001)'%3e80%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$j = {
    name: 'Hexagonal binning',
    id: 'rawgraphs.hexagonalbinning',
    thumbnail: img$B,
    icon: img$A,
    categories: ['correlations', 'distributions'],
    description: 'Hexagonal Binning is a way to manage the problem of having too many points that start to overlap. Hexagonal binning plots density, rather than points. Points are binned into gridded hexagons and distribution (the number of points per hexagon) is displayed using either the color or the area of the hexagons.',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions$j = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date'],
    required: true
  }];

  const mapData$j = {
    x: 'get',
    y: 'get'
  };

  var thirdPi = Math.PI / 3,
      angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

  function pointX$1(d) {
    return d[0];
  }

  function pointY$1(d) {
    return d[1];
  }

  function hexbin() {
    var x0 = 0,
        y0 = 0,
        x1 = 1,
        y1 = 1,
        x = pointX$1,
        y = pointY$1,
        r,
        dx,
        dy;

    function hexbin(points) {
      var binsById = {}, bins = [], i, n = points.length;

      for (i = 0; i < n; ++i) {
        if (isNaN(px = +x.call(null, point = points[i], i, points))
            || isNaN(py = +y.call(null, point, i, points))) continue;

        var point,
            px,
            py,
            pj = Math.round(py = py / dy),
            pi = Math.round(px = px / dx - (pj & 1) / 2),
            py1 = py - pj;

        if (Math.abs(py1) * 3 > 1) {
          var px1 = px - pi,
              pi2 = pi + (px < pi ? -1 : 1) / 2,
              pj2 = pj + (py < pj ? -1 : 1),
              px2 = px - pi2,
              py2 = py - pj2;
          if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
        }

        var id = pi + "-" + pj, bin = binsById[id];
        if (bin) bin.push(point);
        else {
          bins.push(bin = binsById[id] = [point]);
          bin.x = (pi + (pj & 1) / 2) * dx;
          bin.y = pj * dy;
        }
      }

      return bins;
    }

    function hexagon(radius) {
      var x0 = 0, y0 = 0;
      return angles.map(function(angle) {
        var x1 = Math.sin(angle) * radius,
            y1 = -Math.cos(angle) * radius,
            dx = x1 - x0,
            dy = y1 - y0;
        x0 = x1, y0 = y1;
        return [dx, dy];
      });
    }

    hexbin.hexagon = function(radius) {
      return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
    };

    hexbin.centers = function() {
      var centers = [],
          j = Math.round(y0 / dy),
          i = Math.round(x0 / dx);
      for (var y = j * dy; y < y1 + r; y += dy, ++j) {
        for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
          centers.push([x, y]);
        }
      }
      return centers;
    };

    hexbin.mesh = function() {
      var fragment = hexagon(r).slice(0, 4).join("l");
      return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
    };

    hexbin.x = function(_) {
      return arguments.length ? (x = _, hexbin) : x;
    };

    hexbin.y = function(_) {
      return arguments.length ? (y = _, hexbin) : y;
    };

    hexbin.radius = function(_) {
      return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
    };

    hexbin.size = function(_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
    };

    hexbin.extent = function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
    };

    return hexbin.radius(1);
  }

  function colorDomain(data, mapping, visualOptions) {
    const {
      width,
      height,
      diameter,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      xOrigin,
      yOrigin
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    if (!data) {
      return {
        domain: [],
        type: 'number'
      };
    } // x scale


    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice();
    const hexbin$1 = hexbin().x(d => x(d.x)).y(d => y(d.y)).radius(diameter / 2).extent([[margin.left, margin.top], [chartWidth, chartHeight]]);
    const bins = hexbin$1(data);
    const domain = bins.map(d => d.length);
    return {
      domain,
      type: 'number'
    };
  }
  function render$j(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      xOrigin,
      yOrigin,
      diameter,
      weightSize,
      showPoints,
      dotsDiameter,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      colorScale,
      showCountLabels,
      showLabelsOutline,
      autoHideLabels
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // x scale

    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType.type === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType.type === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice();

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(x)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(y)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['y'].value).styles(styles.axisLabel));
    };

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis);
    const vizLayer = svg.append('g').attr('id', 'viz');
    const hexbin$1 = hexbin().x(d => x(d.x)).y(d => y(d.y)).radius(diameter / 2).extent([[margin.left, margin.top], [chartWidth, chartHeight]]);
    const bins = hexbin$1(data);
    const size = sqrt$1().domain([0, max(bins, d => d.length)]).rangeRound([weightSize ? 0 : diameter / 2, diameter / 2]);
    const hex = vizLayer.selectAll('g').data(bins).join('g');
    hex.append('path').attr('d', d => hexbin$1.hexagon(size(d.length))).attr('transform', d => `translate(${d.x},${d.y})`).attr('fill', d => colorScale(d.length)).attr('stroke', 'white');

    if (showPoints) {
      hex.selectAll('circle').data(d => d).join('circle').attr('cx', d => x(d.x)).attr('cy', d => y(d.y)).attr('fill', 'black').attr('r', dotsDiameter / 2);
    }

    if (showCountLabels) {
      hex.append('text').attr('text-anchor', 'middle').attr('dominant-baseline', 'middle').attr('x', d => d.x).attr('y', d => d.y).text(d => d.length).styles(styles.labelSecondary);
    }

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      hex.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(hex.selectAll('text'), d => d.length);
    }

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (colorScale.domain().length) {
        chartLegend.addColor('count', colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$j = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      },
      requiredDimensions: ['x', 'y']
    },
    xOrigin: {
      type: 'boolean',
      label: 'Origine des X à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    diameter: {
      type: 'number',
      label: 'Bin diameter',
      default: 8,
      step: 1,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    weightSize: {
      type: 'boolean',
      label: 'Scale hexagons area',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      },
      requiredDimensions: ['x', 'y']
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      //dimension: 'color',
      domain: 'colorDomain',
      default: {
        scaleType: 'sequential',
        interpolator: 'interpolateBlues'
      },
      group: 'colors',
      requiredDimensions: ['x', 'y']
    },
    showCountLabels: {
      type: 'boolean',
      label: 'Show count labels',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y']
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y']
    }
  };

  var hexagonalBinning = {
    metadata: metadata$j,
    dimensions: dimensions$j,
    mapData: mapData$j,
    render: render$j,
    visualOptions: visualOptions$j,
    styles: styles$1,
    colorDomain
  };

  var img$C = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M28.0254%2c19.15a5.3777%2c5.3777%2c0%2c0%2c0-1.1025-.1138%2c4.7429%2c4.7429%2c0%2c0%2c0-4.4849%2c2.9287c-.8335%2c1.8345-1.3682%2c2.5152-4.0947%2c2.9581-5.1436.1757-7.3677%2c4.0483-7.3189%2c7.811.0532%2c4.0791%2c2.811%2c8.2285%2c7.979%2c8.2661a8.2277%2c8.2277%2c0%2c0%2c0%2c8.0943-7.8311c.07-3.1079.562-3.7363%2c2.47-4.8789A5.0592%2c5.0592%2c0%2c0%2c0%2c32%2c24.0029%2c4.8548%2c4.8548%2c0%2c0%2c0%2c28.0254%2c19.15ZM24.9912%2c33.0933C24.3091%2c36.6816%2c21.9575%2c39%2c19%2c39a6.0377%2c6.0377%2c0%2c0%2c1-6-5.9873%2c6.3225%2c6.3225%2c0%2c0%2c1%2c1.9824-4.9409%2c4.8185%2c4.8185%2c0%2c0%2c1%2c4.1016-1.0645c2.6738.4566%2c4.4116%2c1.31%2c5.313%2c2.6074A4.4407%2c4.4407%2c0%2c0%2c1%2c24.9912%2c33.0933ZM27%2c27a3%2c3%2c0%2c1%2c1%2c3-3A3.0033%2c3.0033%2c0%2c0%2c1%2c27%2c27Z'/%3e %3cpath class='cls-1' d='M18.916%2c27.9927a4.7526%2c4.7526%2c0%2c0%2c0-.7978-.0694%2c3.7068%2c3.7068%2c0%2c0%2c0-2.4815.9048A5.3167%2c5.3167%2c0%2c0%2c0%2c14%2c32.9873%2c5.0429%2c5.0429%2c0%2c0%2c0%2c19%2c38c2.979%2c0%2c4.5405-2.6309%2c5.0088-5.0933a3.4386%2c3.4386%2c0%2c0%2c0-.4336-2.7216C22.8354%2c29.1191%2c21.311%2c28.4019%2c18.916%2c27.9927ZM19%2c36a3%2c3%2c0%2c1%2c1%2c3-3A3.0033%2c3.0033%2c0%2c0%2c1%2c19%2c36Z'/%3e %3cpath class='cls-1' d='M39%2c33a5%2c5%2c0%2c1%2c0%2c5%2c5A5.0059%2c5.0059%2c0%2c0%2c0%2c39%2c33Zm0%2c8a3%2c3%2c0%2c1%2c1%2c3-3A3.0033%2c3.0033%2c0%2c0%2c1%2c39%2c41Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3ccircle class='cls-2' cx='19' cy='33' r='2'/%3e %3ccircle class='cls-2' cx='27' cy='24' r='2'/%3e %3ccircle class='cls-2' cx='39' cy='38' r='2'/%3e %3c/g%3e%3c/svg%3e";

  var img$D = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-18 %7b fill: none%3b %7d .cls-2 %7b clip-path: url(%23clip-path)%3b %7d .cls-3 %7b fill: %23fee89a%3b %7d .cls-4 %7b fill: %23f8da93%3b %7d .cls-5 %7b fill: %23f2cb8d%3b %7d .cls-6 %7b fill: %23ecbd86%3b %7d .cls-7 %7b fill: %23e6af80%3b %7d .cls-8 %7b fill: %23dfa179%3b %7d .cls-9 %7b fill: %23d99273%3b %7d .cls-10 %7b fill: %23d2846d%3b %7d .cls-11 %7b fill: %23cb7666%3b %7d .cls-12 %7b fill: %23c46760%3b %7d .cls-13 %7b fill: %23bd585a%3b %7d .cls-14 %7b fill: %23b54954%3b %7d .cls-15 %7b fill: %23ae384e%3b %7d .cls-16 %7b fill: %23a62448%3b %7d .cls-17 %7b fill: %239e0142%3b %7d .cls-18 %7b stroke: black%3b %7d .cls-19 %7b isolation: isolate%3b font-size: 9.93099px%3b font-family: ArialMT%2c Arial%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' x='19.98424' y='2.36511' width='297.93069' height='139.03432'/%3e %3c/clipPath%3e %3c/defs%3e %3cg%3e %3cg class='cls-2'%3e %3cg%3e %3cpath class='cls-3' d='M187.2012%2c132.46151l3.59664-.58367%2c3.97241-1.39208%2c3.35721-1.99666.6152-.3862%2c3.97241-3.53965.04549-.04656%2c3.92692-3.81056.17763-.16184%2c3.79478-2.13132%2c3.97241-1.7273.54621-.11379%2c3.4262-.44353%2c3.97241.04206%2c3.05983.40147.91258.22068%2c3.97241%2c1.39722%2c3.9724%2c1.7889%2c1.85668.56561%2c2.11573.7373%2c3.97241.64%2c3.97241.03083%2c3.97241-.45412%2c3.56349-.954.40892-.11035%2c3.97241-1.15506%2c3.97241-1.30011%2c3.44546-1.40689.52695-.25565%2c3.97241-2.521%2c1.30205-1.19577%2c2.67036-2.40331%2c1.72429-1.5691%2c2.24812-1.74854%2c2.45466-2.22387%2c1.51775-1.07975%2c3.84827-2.89266.12414-.09207%2c3.9724-3.5028.46146-.37754%2c3.511-3.21838.87564-.754%2c3.09677-1.94594%2c2.99916-2.02647.97325-.60828%2c3.5412-3.36413.43121-.40211%2c3.59233-3.5703.38008-.35972%2c3.2571-3.61269.71531-.84025%2c2.93612-3.13216%2c1.03629-1.28988%2c3.59057-2.68252.38184-.29447%2c3.97241-1.88325%2c1.9862-1.79469V41.0961l-1.9862-.12338-3.97241.108-3.97241-.24027-3.97241-.95519-3.97241-1.81967-1.69159-.94195-2.28082-1.57064-2.56216-2.40177-1.41025-1.34635-2.28821-2.62606-1.6842-2-1.79763-1.97241-2.17478-2.3375-1.50208-1.63491-2.47033-2.20812-2.14834-1.76429L286.13567%2c15.656l-3.56084-2.36679-.41157-.35413-3.97241-2.59434-2.0607-1.02394-1.91171-.93255L270.246%2c7.603l-3.97241.00967-3.97241.56367L258.3288%2c9.19094l-.34377.12589-3.62864.92494-3.97241.19916-3.97241-.25334L242.43916%2c9.966l-3.97241-.00385-3.97241-.06043-3.9724.04484-3.97241.08182-3.97241-.22608-1.734-.48551-2.23842-.89822L214.6323%2c6.801l-2.76243-1.45655-1.21-.86286L206.68748%2c1.3863l-.016-.01429-3.95639-3.86294-.12195-.10947-3.85046-3.204-1.75448-.76838-2.21793-.8813-3.97241-.52866-3.97241.2732-3.544%2c1.13676-.42839.141-3.9724%2c2.63662-1.4994%2c1.19483-2.473%2c1.6274-3.82606%2c2.345-.14635.072-3.97241%2c1.53309-3.97241.59211-3.97241.38206-3.97241.70985-1.98621.68326-1.9862%2c1.095L148.0812%2c9.31683l-.97986%2c1.67021-1.25058%2c2.3022-2.72183%2c2.75586-3.97241-.24616-3.97241-1.54764-1.84717-.96206L131.2117%2c12.0317l-3.97241-2.32591-.88906-.389-3.08334-1.704-3.97241-1.43079-3.97241-.784-.92691-.05368-3.0455-.25521-3.04552.25521-.92689.05473L103.40484%2c5.86l-3.97241.79287L95.46%2c7.75161%2c91.48761%2c9.07646l-.712.24037L87.5152%2c10.236l-3.97241%2c1.65508L81.2819%2c13.28924%2c79.57038%2c14.369%2c75.598%2c17.17529l-.22068.08635L71.62556%2c18.967l-3.9724.39658-3.97241-1.54216-.68414-.55975-3.28827-2.14452L55.8864%2c13.28924l-.15047-.07524-3.97241-1.48924-3.97241-1.19622-3.97241-.20588-3.97241.7774-3.97241%2c1.57938-.92689.6098-3.04552%2c3.80689-.08275.16551-.72083%2c3.97241.35358%2c3.97241.45%2c1.2%2c1.3442%2c2.77241%2c2.62821%2c2.40919%2c1.89694%2c1.56322%2c2.07547%2c1.45446%2c3.97241%2c2.50471.03009.01324L47.79111%2c39.051l3.97241%2c1.5047%2c1.28929.54036%2c2.68312%2c1.08466%2c3.97241.50712%2c3.97241-.32366%2c3.97241-.073%2c3.9724.43714L75.598%2c44.01092l.60772%2c1.05759%2c1.28454%2c3.97241.00315%2c3.97241-.57449%2c3.97241-1.20126%2c3.97241-.11966.34643-1.72284%2c3.626L71.73266%2c68.903l-.1071.18515-3.69335%2c3.78725-.279.23948-3.97241%2c2.10929L59.70834%2c76.549l-1.0232.29881-2.94921%2c1.47461-2.22777%2c2.4978L52.33427%2c84.7926l.44394%2c3.97241L54.687%2c92.73742l1.0489%2c1.11133%2c2.93086%2c2.86108%2c1.04155%2c1.22009%2c1.66087%2c2.75232%2c1.89073%2c3.97241.42081%2c1.05649.80616%2c2.91592%2c1.12812%2c3.97241%2c1.40192%2c3.97241.63621%2c1.05758%2c2.91482%2c2.91483%2c1.05758.696%2c3.97241%2c1.51558%2c3.97241.70564%2c3.97241-.28122%2c3.97241-1.38085%2c2.61949-1.25516%2c1.35292-.59084%2c3.97241-2.381%2c1.1374-1.00056%2c2.835-2.69672%2c1.42646-1.27569%2c2.54595-1.87956%2c3.97241-.95592%2c3.97241%2c1.33078%2c2.05186%2c1.5047%2c1.92055%2c1.44339%2c3.15637%2c2.529.816.6156%2c3.97241%2c2.33087%2c3.31034%2c1.02594.66206.27586%2c3.97241.88275%2c3.97241.26279%2c3.97241.142%2c3.97241.184%2c3.97241.56184%2c3.97241%2c1.2842.74805.37894%2c3.22436%2c2.08635%2c3.97241%2c1.8703.04053.01576%2c3.93188%2c1.3961%2c3.97241%2c1.04555%2c3.97241.76083%2c3.97241.54266%2c2.28413.22727%2c1.68828.22214%2c3.9724.17752%2c3.97241-.31539Z'/%3e %3cpath class='cls-4' d='M60.3704%2c29.17887l-.66206-1.85378-.963-2.11863-3.0094-2.283-3.34044-1.68942-.632-.25987-3.97241-1.61954-3.97241.979-.7421.90041-.33453%2c3.97241%2c1.07663%2c1.92%2c1.95468%2c2.05241%2c2.01773%2c1.03347%2c3.97241.89131%2c3.97241%2c1.47192L59.70834%2c30.503Zm134.67125%2c95.33782%2c3.701-2.54641%2c1.55927-1.426%2c2.41314-1.91975%2c2.74709-2.05266%2c1.22532-.72226%2c3.97241-1.70724%2c3.97241-1.24378%2c1.57635-.29913%2c2.39606-.32816%2c3.97241-.23254%2c3.97241.04813%2c3.97241.22794%2c2.3427.28463%2c1.6297.31939%2c3.97241.38162%2c3.97241-.1695%2c2.09656-.53151%2c1.87585-.603%2c3.97241-2.38925%2c1.42407-.9802%2c2.54834-3.97241h0l3.97241-3.0486%2c3.97241%2c1.00871%2c3.97241.36346%2c3.97241-.29645%2c3.97241-1.60461.71843-.39492%2c3.254-1.68992%2c2.95094-2.28249%2c1.02147-.88276%2c3.60087-3.08965.37154-.26347%2c3.9724-3.26988.59163-.43906%2c3.38078-2.13762%2c2.86126-1.83479%2c1.11115-.60188%2c3.97241-2.62342.7868-.74711%2c3.18561-2.80306%2c1.21677-1.16935%2c2.75564-2.69311%2c1.14015-1.2793%2c2.73049-3.9724.10177-.19771%2c2.67084-3.7747%2c1.30157-2.06819%2c2.54019-1.90422%2c1.43222-2.09536%2c2.94333-1.877%2c1.02908-2.76636%2c1.9862-1.206-1.9862-.46294-3.97241-1.72213-2.59811-1.78734-1.3743-.4369-3.97241-2.28537L312.331%2c45.06851l-2.36092-1.30135-3.97241-2.306-.49319-.36505-3.47922-2.89717-1.04765-1.07524-2.92476-3.44161-.44457-.5308-3.52784-3.59269-.38975-.37972-3.58266-3.76748-.19269-.20493-3.77971-3.95689-.01892-.01552-3.95349-2.7954-2.55162-1.177-1.42079-.80433-3.97241-1.85916L270.246%2c13.898l-3.97241.18246-3.97241.61077-3.97241.429-3.97241.31324-3.97241-.47168-3.97241-.72585-3.97241-.47838-3.97241-.07364-3.97241.02568-3.9724.22946-3.97241.42042-3.97241.27332-3.97241-.56445-3.97241-.7369-.1589-.04225-3.81351-1.52135-3.97241-2.42742-.02684-.02364-3.94557-3.29912-.80521-.67329-3.1672-2.7412L196.81112%2c1.372%2c194.77025.09353%2c190.79784-.895l-3.97241.1616L182.853.772l-.91428.6-3.05812%2c1.705L175.194%2c5.34442l-.28578.16148L170.9358%2c7.46879l-3.57183%2c1.848-.40058.22379L162.991%2c10.96447l-3.97241%2c2.17429-.18916.15048-3.65832%2c3.9724-.12493.24223-2.095%2c3.73018-1.87737%2c2.56165-3.97241%2c1.38513-3.97241-1.304-3.97241-1.81571-1.68886-.8271-2.28355-1.45-3.83463-2.52241-.13778-.08994-3.97241-2.7674L124.942%2c13.28924l-1.67511-.92382-3.97241-1.566L115.32207%2c9.905l-3.97241-.25371-3.97241.333-3.97241.59437-3.97241.96533L95.46%2c12.91448l-.94582.37476-3.02659%2c1.16835L87.5152%2c16.11705l-2.04639%2c1.14459-1.926%2c1.65088-2.03134%2c2.32153L79.57038%2c25.1608l-.02942.04566-.9994%2c3.97241.56148%2c3.97241.46734.89519.97975%2c3.07722L81.9757%2c41.0961l1.17165%2c3.97241.39544%2c3.12118.09768.85123-.09768.62722-.50244%2c3.34519-.98721%2c3.97241L80.449%2c60.95815l-.87864%2c2.27452-.73358%2c1.69789L77.00436%2c68.903%2c75.598%2c72.38646l-.29425.48891-2.645%2c3.97241-1.03319%2c2.00348-1.84087%2c1.96893-2.13153%2c2.9131L66.8717%2c84.7926l-.921%2c3.97241.48019%2c3.97241%2c1.22228%2c3.17792.2998.79449%2c1.27013%2c3.97241%2c1.34317%2c3.97241%2c1.0593%2c2.57038.681%2c1.402%2c2.77329%2c3.97241.51813.53681%2c3.97241%2c2.6354%2c3.97241.208%2c3.97241-1.64683%2c3.17793-1.73341.79448-.36669%2c3.97241-2.385%2c1.50238-1.22068%2c2.47-1.68264%2c3.10271-2.28977.8697-.60987%2c3.97241-1.02583%2c3.97241%2c1.06276.59586.57294%2c3.37655%2c3.24668.53339.72573%2c3.439%2c3.2659.87.70651%2c3.10243%2c2.33163%2c3.9724%2c1.63054.04845.01024%2c3.924.96337%2c3.97241.24815%2c3.97241-.14059%2c3.97241-.43765%2c3.97241-.29664%2c3.97241.14244%2c3.97241%2c1.0309%2c3.97241%2c1.25007%2c3.06071%2c1.21236.9117.3889%2c3.97241%2c1.82945%2c3.97241%2c1.73148.05441.02257%2c3.918%2c1.46674%2c3.97241%2c1.15262%2c3.9724.55242%2c3.97241-.12626%2c3.97241-.876%2c3.97241-1.97789Z'/%3e %3cpath class='cls-5' d='M194.19731%2c120.54429l.57294-.302%2c3.97241-2.84977%2c1.01441-.82068%2c2.958-2.14709%2c3.23719-1.82532.73522-.28993%2c3.97241-1.15717%2c3.97241-.89321%2c3.97241-.6865%2c3.97241-.50369%2c3.97241-.31911%2c1.757-.1228%2c2.21539-.15079%2c3.9724-.26083%2c3.97241-.82328%2c3.97241-2.059.75339-.67851%2c3.219-3.73407.15848-.23834%2c2.67149-3.97241%2c1.14244-1.50441%2c2.5566-2.468%2c1.41581-1.227%2c3.97241-1.28345%2c3.97241.87666%2c3.97241%2c1.4008.54883.233%2c3.42358%2c1.63643%2c3.97241-.38377%2c2.44966-1.25266%2c1.52275-.71009%2c3.97241-3.14852.16184-.1138%2c3.81057-2.17058%2c2.65238-1.80183%2c1.32-.72782%2c3.97241-2.1419%2c1.8922-1.10269%2c2.08021-.98476%2c3.97241-2.59832.42964-.38933%2c3.54277-3.17336.81308-.799%2c3.12045-3.9724.03888-.0707%2c2.189-3.90171%2c1.593-3.97241.19039-1.8584.377-2.114-.377-1.10606-.7508-2.86635-3.07065-3.97241-.151-.12545-3.97241-3.3033-.599-.54366-3.37342-2.61974-1.54339-1.35267-2.429-2.48609-1.40164-1.48632-2.57077-2.99763-.83071-.97478-3.1417-3.074-.924-.89838-3.04843-3.211-.91-.76138-3.0624-2.58808-2.52237-1.38433-1.45-.73176-3.97241-1.6053L270.246%2c18.38l-3.97241.40591-3.97241.65434-3.97241.029-3.97241-.22139-3.97241-.916-3.97241-1.05047-.10565-.01975-3.86676-.79361-3.97241-.1596-3.97241.08237-3.9724.40862-2.47662.46222-1.49579.2404-3.97241.532-3.97241-.16538-3.97241-.2464-3.59665-.36064-.37576-.057-3.97241-1.096-3.97241-2.31676-.79838-.50268-3.174-2.9702-.79738-1.00221-3.175-2.51433L191.2668%2c5.34442l-.469-.15927-3.97241-.21532-1.12377.37459-2.84864.94129-3.9724%2c2.02187-1.78617%2c1.00925-2.18624%2c1.28766-3.97241%2c2.1423-.89655.54245-3.07586%2c1.7788-3.7931%2c2.1936-.17931.16447-3.13009%2c3.80794-.84232%2c1.562-1.20522%2c2.41044-2.76719%2c2.75382-2.80275%2c1.21859-1.16966.26855-3.50895-.26855-.46346-.04414L143.12893%2c27.444l-3.97241-1.90516-.6753-.33234-3.29711-1.944-3.59843-2.02837-.374-.27167-3.97241-3.011-1.223-.68973-2.74942-1.515-3.97241-1.58046-3.4023-.877-.57011-.15993-3.97241-.31129-3.55225.47122-.42016.05573-3.97241.82037-3.97241%2c1.19721L95.46%2c16.938l-.69381.32363-3.2786%2c2.0812L88.819%2c21.23405%2c87.5152%2c22.6897l-1.819%2c2.51676-1.1864%2c3.97241.193%2c3.97241%2c1.23171%2c3.97241%2c1.4047%2c3.97241.176.65172.84671%2c3.32069.39675%2c3.97241-1.08687%2c3.97241-.15659.37-1.22482%2c3.60243L84.273%2c60.95815l-.73022%2c1.58137-1.06043%2c2.391L80.66858%2c68.903l-1.0982%2c2.82392-.498%2c1.14848-1.79551%2c3.97241L76.0295%2c80.82019l-.43153%2c1.576L74.56775%2c84.7926%2c73.85282%2c88.765l.13011%2c3.97241%2c1.13962%2c3.97241L75.598%2c98.3349l.67242%2c2.34734%2c1.93062%2c3.97241%2c1.36937%2c1.76375%2c3.97241%2c1.988%2c3.97241-.85477%2c3.97241-1.26481%2c3.41266-1.63214.55975-.23682%2c3.97241-2.46891%2c1.73922-1.26668%2c2.23319-1.75206%2c3.97241-1.5888%2c3.97241.42125%2c2.59363%2c2.91961%2c1.37878%2c1.32723%2c1.66982%2c2.64518%2c2.30259%2c2.95673.77051%2c1.01568%2c3.2019%2c2.75807%2c2.47774%2c1.21434%2c1.49466.76274%2c3.97241%2c1.061%2c3.97241.24022%2c3.97241-.32423%2c3.97241-.85%2c3.97241-.7776.93793-.11217%2c3.03448-.38465%2c3.97241.13126%2c2.05241.25339%2c1.92.26181%2c3.97241%2c1.02338%2c3.97241%2c1.31145%2c2.96947%2c1.37577%2c1.00294.62145%2c3.97241%2c2.64931%2c1.067.70165%2c2.90544%2c1.40623%2c3.9724%2c1.09721%2c3.97241.10385%2c3.97241-.86283Z'/%3e %3cpath class='cls-6' d='M193.73049%2c116.57188l1.03976-.59817%2c3.97241-2.84368.75944-.53056%2c3.213-1.64686%2c3.97241-1.3476%2c3.93756-.97795.03485-.00657%2c3.97241-.72761%2c3.97241-.68056%2c3.97241-.637%2c3.97241-.59944%2c3.97241-.74925%2c2.29982-.572%2c1.67258-.4226%2c3.97241-1.71639%2c2.4164-1.83342%2c1.556-1.29867%2c2.3328-2.67374%2c1.63961-1.75128%2c1.8067-2.22113%2c2.16571-2.653%2c1.47774-1.3194%2c2.49467-1.85065%2c3.97241-1.18559%2c3.97241.29339%2c3.97241.62424L270.246%2c87.744l3.97241-.02521%2c3.97241-1.57931%2c2.02463-1.34687%2c1.94778-1.30131%2c3.97241-1.76013%2c1.79493-.911%2c2.17747-.75567%2c3.97241-1.61348%2c3.10284-1.60326.86957-.39544%2c3.97241-2.57861%2c1.08991-.99836%2c2.8825-3.40928.46112-.56312%2c2.30765-3.97241%2c1.20364-3.366.24346-.60644.10265-3.97241-.34611-.8701-1.2769-3.10231L305.99771%2c49.869l-.67318-.828-3.29923-3.04365-.98128-.92876-2.99113-2.65177-1.48965-1.32064-2.48276-2.62329L292.837%2c37.12369l-2.72888-3.15927-.675-.81314-3.29744-3.21679-.99665-.75562-2.97576-2.5312-2.67072-1.44121-1.30169-.74083-3.97241-1.76872-3.97241-.444-3.97241.70293-3.97241.74568-3.97241-.385-3.97241-.69581L250.384%2c21.252l-.04181-.01794-3.9306-1.48471-3.97241-.94209-3.97241-.20576-3.97241.10032-3.9724.43848-3.97241.8248-3.97241.82758-3.97241.11116-3.97241.08262-3.97241.14735-3.97241-.05079-3.97241-.49155-3.97241-.0288-3.97241-2.1302-1.14667-1.17082L190.79784%2c14.037l-.94864-.74774-3.02377-1.58276-3.97241.92876-1.53222.654-2.44018.7908-3.97241%2c1.5468-3.66421%2c1.6348-.3082.1744-3.97241%2c3.44629-.37727.35172-2.88165%2c3.97241-.71349.8496-2.71482%2c3.12281-1.25759.98918L155.04616%2c32.319l-3.97241.29522-3.97241-.8834-3.97241-1.641-1.84731-.91092-2.1251-1.19641-3.97241-2.05561-1.39033-.72039-2.58208-1.59715-3.91835-2.37526-.05406-.04148-3.9724-2.33215-3.65821-1.59878-.3142-.13273-3.97241-1.10231-3.97241-.24524-3.97241.73039-2.882.74989-1.09046.34119-3.97241%2c1.58679-3.736%2c2.04443-.23646.16483-3.73019%2c3.80758-.24222.51368-1.66478%2c3.45873-.099%2c3.97241.99591%2c3.97241.7679%2c2.321.46809%2c1.65145%2c1.12365%2c3.97241.69354%2c3.97241-.96657%2c3.97241-1.31871%2c3.00715-.41985.96526-3.02391%2c3.97241-.52865.7435-1.63191%2c3.22891-1.936%2c3.97241-.4045%2c1.03282-1.15731%2c2.93958L80.7338%2c76.84778l-1.01795%2c3.97241-.14547.73774-.7211%2c3.23467-.157%2c3.97241.51982%2c3.97241.35829.98242%2c1.38343%2c2.99%2c2.56319%2c3.97241.02579.02613%2c3.97241.64269%2c3.97241-.36584.83144-.303%2c3.141-1.047%2c3.97241-2.35793.70869-.56748%2c3.26372-2.63323%2c2.42153-1.33918%2c1.55088-1.31644%2c3.97241-2.10805%2c3.2296%2c3.42449.74281.85389.93207%2c3.11852%2c1.66943%2c3.97241%2c1.37091%2c2.07612%2c1.05687%2c1.89629%2c2.91554%2c3.61128.46393.36113%2c3.50847%2c2.00276%2c3.97241%2c1.09193%2c3.97241.22317%2c3.97241-.46167%2c3.97241-1.19446%2c3.97241-1.24112%2c1.55442-.42061%2c2.418-.827%2c3.97241-.5683%2c3.97241.23936L162.991%2c108.481l.60188.146%2c3.37053.98431%2c3.97241%2c1.608%2c2.42941%2c1.38009%2c1.543.89761%2c3.97241%2c2.9004.286.1744%2c3.6864%2c1.86558%2c3.97241.48573%2c3.97241-.83932Z'/%3e %3cpath class='cls-7' d='M191.62967%2c112.59947l3.14058-1.50594%2c3.97241-1.87865%2c1.48575-.58782%2c2.48666-.6525%2c3.97241-.75513%2c3.97241-.65081%2c3.97241-.72421%2c3.97241-.81%2c1.83471-.37981%2c2.1377-.41832%2c3.97241-.78376%2c3.97241-.9977%2c3.9724-1.52436.45761-.24827%2c3.5148-2.1027%2c2.1395-1.86971%2c1.83291-1.60177%2c2.24552-2.37064%2c1.72689-1.79677%2c1.84052-2.17564%2c2.13189-2.319%2c2.15115-1.65341%2c1.82126-1.49106%2c3.97241-1.38863%2c3.97241-.144%2c3.97241.02426%2c3.97241.52876%2c3.97241-.22131%2c2.71233-1.28045%2c1.26008-.44055%2c3.97241-1.57136%2c3.97241-.81029%2c3.9724-1.12467.06286-.02554%2c3.90955-1.28958%2c3.97241-1.9144%2c1.12094-.76843%2c2.85147-2.46857%2c1.30445-1.50383%2c2.32758-3.97241.34038-1.05377%2c1.05514-2.91864-.158-3.97241-.89718-1.78463-1.0686-2.18778-2.90381-3.46489-.44321-.50752-3.5292-3.35367-.6753-.61874-3.29711-2.93635-1.18021-1.03606-2.7922-3.02928-.80192-.94313-3.17048-3.78838-.1933-.184-3.77911-2.91-2.37656-1.06239-1.59585-.8521-3.97241-1.65168-3.97241-.30885-3.97241%2c1.06144-3.97241.9055-3.97241-.97442-3.97241-1.37351-1.32757-.77879L250.384%2c24.0542l-3.97241-1.85983-3.11047-.96032-.86194-.24128-3.97241-.28725-3.97241.12925-2.94158.39928-1.03082.14017-3.97241.97226-3.97241%2c1.007-3.97241.37228-3.97241.38333-3.97241.65149-2.88563.44588-1.08678.17669-3.97241.54233-3.97241%2c1.12006-3.97241.51829-3.97241-.76086-2.4975-1.59651-1.47491-1.55172L182.853%2c21.43268l-.94993-.19863-3.02247-.44278-2.31725.44278-1.65516.32668-3.97241%2c2.56573-.92407%2c1.08-3.04834%2c3.434-.44914.53843L162.991%2c32.66708l-.66208.4842-3.31033%2c1.64956-3.97241.82317-3.97241-.42741-3.97241-1.12735-2.02954-.918-1.94287-.92119-3.97241-2.09556-1.97382-.95566-1.99859-1.108-3.97241-2.10543-1.46778-.759-2.50463-1.56477-3.9724-1.8361-1.61882-.57154-2.35359-1.01539-3.97241-1.14815-3.97241-.18522-3.97241%2c1.08327L103.862%2c21.23405l-.45714.19659L99.43243%2c23.474l-2.36171%2c1.73249L95.46%2c27.22991l-1.07529%2c1.949-.37445%2c3.97241.691%2c3.97241L95.46%2c39.64228l.56635%2c1.45382%2c1.83936%2c3.97241%2c1.44315%2c3.97241-.67306%2c3.97241-1.69259%2c3.97241L95.46%2c58.17539l-2.43967%2c2.78276-1.53274%2c1.6374-1.70347%2c2.335L87.5152%2c68.25124l-.32671.65173-1.46466%2c3.9724-1.66567%2c3.97241-.51537%2c2.38881-.3301%2c1.5836L82.703%2c84.7926l.2969%2c3.97241.54294%2c1.98621%2c1.14534%2c1.9862%2c2.82707%2c1.95611%2c3.97241.95226L95.46%2c94.99638l3.97241-2.11261.17825-.14635%2c3.57164-3.97241.22252-.26948%2c3.55982-3.70293.41259-.62341%2c2.99878-3.349.97363-1.25181%2c3.97241-1.56789%2c2.10538%2c2.8197L118.629%2c84.7926l.54583%2c3.97241-.17859%2c3.97241.29825%2c1.50567.29754%2c2.46674%2c1.17918%2c3.97241%2c2.42735%2c3.97241.06834.08464%2c3.9724%2c3.22413%2c1.677.66364%2c2.29544.73016%2c3.97241.23661%2c3.97241-.67541.78783-.29136%2c3.18458-1.508%2c3.97241-1.95686%2c1.14917-.50751%2c2.82324-1.56227%2c3.97241-.91849%2c3.97241.4509%2c3.97241%2c1.403%2c2.30582.6269%2c1.66659.49485%2c3.97241%2c1.1333%2c3.97241%2c1.31889%2c2.23643%2c1.02537%2c1.736%2c1.28179%2c3.76248%2c2.69062.20992.1272%2c3.97241.93786%2c3.97241-.63632Z'/%3e %3cpath class='cls-8' d='M209.50126%2c104.65465l1.15863-.12526%2c3.97241-.64%2c3.97241-.80182%2c3.97241-.90989%2c3.97241-1.03678%2c1.47478-.45864%2c2.49763-.87627%2c3.9724-1.89674%2c1.79261-1.1994%2c2.1798-1.52862%2c2.74232-2.44379%2c1.23009-1.12174%2c2.7509-2.85067%2c1.22151-1.19756%2c2.56721-2.77485%2c1.4052-1.67485%2c2.77808-2.29756%2c1.19433-1.128%2c3.97241-1.56889%2c3.97241-.44742%2c3.97241-.49589%2c3.97241-.24948%2c1.80563-.08276%2c2.16678-.08247%2c3.97241-.82143%2c3.97241-.71749%2c3.97241-.26595%2c3.9724-.6943%2c3.97241-1.29954.1836-.09123%2c3.78881-2.26567%2c1.93529-1.70673%2c2.03712-2.61917.833-1.35324%2c1.315-3.97241-.30811-3.97241-1.83985-3.36127-.37932-.61114-3.48365-3.97241-.10944-.104-3.97241-3.639-.26088-.22938-3.71153-3.24638-.77889-.726-3.19351-3.78765-.186-.18476-3.78641-3.60553-.72452-.36688-3.24789-1.38448-3.97241-1.20166-3.97241.06545-3.97241%2c1.6537-2.12119.867-1.85122%2c1.3334-3.34517-1.3334-.62724-.18817-3.97241-2.713-.79448-1.07121L250.384%2c27.15041l-2.78978-1.944-1.18263-.60164-3.97241-1.45353-3.97241-.36541-3.97241.14111-3.9724.58385-3.97241%2c1.13024-1.91173.56538-2.06068.70451-3.97241.64722-3.97241.64436-3.97241%2c1.00237-3.92827.97395-.04414.012-3.97241%2c1.06788-3.97241%2c1.31409-3.97241.86257-3.97241.23534-3.97241-.5566L182.853%2c31.3393l-3.9724-.606-3.97241-.08079-3.97241%2c2.23-.26881.26881-3.7036%2c3.42069-.77891.55172-3.1935%2c1.147-3.97241.27539-3.97241-.15522-3.97241-.84174-1.21131-.42539-2.7611-1.0127-3.97241-1.94378-1.91622-1.01593-2.05619-1.14439-3.97241-1.97234-1.78522-.85568-2.18719-1.19495-3.97241-2.02971-2.03155-.74775-1.94085-.86744-3.97241-1.20473-3.97241-.89955-3.97241-.00758-3.97241%2c1.49429-3.09538%2c1.485-.877.66533-3.83621%2c3.30708-.1362.55429-.6228%2c3.41812.6228%2c3.58486.08635.38755%2c1.95131%2c3.97241%2c1.93475%2c2.82884.541%2c1.14357%2c1.65906%2c3.97241.40507%2c3.97241.79587%2c3.97241-.15826%2c3.97241-3.24278%2c1.485-3.97241.21388L95.46%2c64.51136l-.39164.4192-3.58077%2c3.79453-.12328.17788-1.74861%2c3.9724-1.88825%2c3.97241-.21227%2c2.05978-.17446%2c1.91263.17446%2c3.44274.04318.52967%2c2.458%2c3.97241%2c1.47126%2c1.11585%2c3.97241.01375%2c1.64376-1.1296%2c2.32865-1.796%2c1.779-2.17638%2c2.19346-3.45545.34942-.517%2c1.9286-3.97241.85317-3.97241.84122-1.93252%2c3.97241-1.02132%2c3.97241.87139%2c2.71676%2c2.08245%2c1.25565%2c1.109%2c1.9451%2c2.86336%2c1.19647%2c3.97241-.08588%2c3.97241-.2116%2c3.97241-.477%2c3.97241.34561%2c3.97241%2c1.25177%2c3.97241.008.013%2c3.522%2c3.95942.45036.36712%2c3.97241%2c1.77578%2c3.97241.30357%2c3.97241-.93022%2c2.728-1.51625%2c1.24436-.94754%2c3.97241-2.92521.16751-.09966%2c3.8049-2.871%2c3.97241-.55406%2c3.97241%2c1.13866%2c3.97241%2c1.84154%2c1.42345.44483%2c2.549.8665%2c3.97241.95138%2c3.97241.85865%2c3.97241%2c1.14093.66207.15495L182.853%2c105.695l3.97241.72057%2c3.97241.29682%2c3.97241-.27563%2c3.97241-.52986%2c3.97241-.49721%2c3.97241-.39524ZM250.384%2c58.32l-3.97241.73949-3.97241.25819-3.97241-.49739-3.97241-1.55819-.5341-.27634-.20152-3.97241.73562-.59886%2c3.97241-3.28527.13242-.08828%2c3.84-1.23871%2c3.97241-1.631%2c2.59614-1.10271%2c1.37627-.7375%2c3.97241-.6253%2c1.58224%2c1.3628%2c1.49881%2c3.97241-1.52163%2c3.97241-1.55942%2c2.71495-1.32413%2c1.25746ZM198.74266%2c69.44343l-3.97241.69162L192.0274%2c68.903l-1.22956-1.94873-.50591-2.02368.50591-1.32414%2c3.97241-.38621%2c3.62191%2c1.71035.3505.91671L199.34%2c68.903Z'/%3e %3cpath class='cls-9' d='M96.22109%2c80.82019l2.61806-3.97241L95.46%2c73.6747l-2.00149%2c3.17308%2c1.11633%2c3.97241.88516.81435Zm124.34632%2c19.862%2c2.00971-.6232%2c3.97241-1.31277%2c3.97241-1.54823.94465-.48821%2c3.02775-1.74842%2c3.076-2.224.89637-.67173L242.0651%2c88.765l.37406-.344%2c3.70066-3.62846.27175-.30429%2c3.06246-3.66812.91-1.29136%2c2.85038-2.681%2c1.122-1.49429%2c3.97241-1.76371%2c3.97241-.45306%2c1.73793-.26135%2c2.23448-.36185%2c3.97241-.32066%2c3.97241.2742%2c3.97241-.25988%2c3.97241-.20313%2c3.97241.07387%2c3.9724-.56572%2c3.97241-1.4549%2c1.85131-1.15433%2c2.1211-1.81322%2c1.72514-2.15919%2c1.57539-3.97241-.46806-3.97241-2.53215-3.97241-.30032-.342-3.44312-3.63037-.52929-.48482L290.114%2c45.06851l-.00594-.00519-3.9724-3.67945-.36836-.28777-3.60405-3.578-.75862-.39437-3.21379-1.54778-3.97241-1.09313-3.97241.72232-2.533%2c1.91859-1.43943%2c1.85667-1.39034%2c2.11574-1.60676%2c3.97241-.77922%2c3.97241-.19609.5131-1.53748%2c3.45931-1.78093%2c3.97241-.654%2c1.12505L255.876%2c60.95815l-1.51957%2c1.31379-3.97241.60991-3.97241-.05209-3.97241.02071-3.97241-.27884-3.97241-.5296-3.9724-.38162-3.02515-.70226-.94726-.72438-1.36675-3.248%2c1.16328-3.97241.20347-.22546%2c3.97241-3.22175.63884-.5252%2c3.33356-1.55325%2c3.97241-1.59711%2c2.33415-.822%2c1.63826-.56821%2c3.97241-2.18608L248.236%2c41.0961l2.148-2.85965.98254-1.11276-.082-3.97241-.90053-1.2214-1.50526-2.751-2.46715-1.81609-3.97241-2.03607-.8597-.12025-3.11271-.34816-3.97241.15154-1.24666.19662-2.72574.5024-3.97241%2c1.399-3.97241%2c1.4556-2.88.61538-1.09242.30345-3.97241.959-3.97241%2c1.33359-3.97241%2c1.16638-.66207.21-3.31034%2c1.1863L198.74266%2c35.626l-3.97241.92-3.15665.57769-.81576.18956-3.97241.65038-3.97241.60976-3.9724%2c1.57891-2.89295.9438-1.07946.39724-3.97241.79-3.97241.07392-3.97241-.03508-3.97241-.7118L156.5%2c41.0961l-1.45381-.276L151.07375%2c39.504l-3.97241-1.53938-1.72356-.84094-2.24885-1.17289-3.97241-2.15513-1.34442-.64439-2.628-1.34586-3.97241-1.88716-1.6996-.73939-2.27281-1.13831-3.9724-1.29385-3.97241-.77421-3.97241-.55425-3.97241.43373-3.97241%2c2.60848-.90768.71841-1.20032%2c3.97241.31056%2c3.97241.99281%2c3.97241.80463%2c1.736.73965%2c2.23643%2c1.24655%2c3.97241.59532%2c3.97241%2c1.15383%2c3.97241.23706.639%2c1.35935%2c3.33337%2c2.61306%2c3.818.09579.15437%2c3.43619%2c3.97241.44043.35794%2c3.11858%2c3.61446.85383%2c1.19172%2c1.7757%2c2.78069.9437%2c3.97241-.36786%2c3.97241-.48705%2c3.97241-.77044%2c3.97241.30991%2c3.97241%2c1.70509%2c3.97241.86335.95448%2c3.97241%2c2.42107%2c3.97241.42563%2c3.97241-1.29257%2c3.14807-2.50861.82434-1.16782%2c2.39444-2.80459%2c1.578-3.533.38493-.43942%2c3.58748-3.95543%2c3.97241%2c1.27782%2c2.83933%2c2.67761%2c1.13308.75707%2c3.43071%2c3.21534.5417.29483%2c3.97241%2c1.55626%2c3.97241.81025%2c3.97241.46774%2c3.97241.40136%2c3.9724.07539%2c3.97241-.017%2c1.6864.3836%2c2.286.5314%2c3.97241%2c1.04569%2c3.97241.52682%2c3.97241.171%2c3.97241-.00541%2c3.97241-.28626%2c3.97241-.60164%2c3.97241-.8744Zm-17.85234-25.905-3.97241%2c1.16846-3.97241-.25592-3.97241-1.95494-.75755-.85949-3.21486-3.843-.08214-.12936-1.34859-3.97241L184.68%2c60.95815l1.49156-3.97241.65384-.67916%2c3.97241-.382%2c3.46845%2c1.06113.504.14127%2c3.97241%2c1.60087%2c3.20941%2c2.23027.763.699%2c2.30681%2c3.27336.82558%2c3.97241-1.35618%2c3.9724Z'/%3e %3cpath class='cls-10' d='M216.72684%2c60.95815l1.26357-3.97241.6143-.91672%2c1.18226-3.05569%2c2.79015-3.32443.56748-.648%2c3.40493-2.17537%2c3.97241-1.29744%2c1.25283-.4996%2c2.71957-.9848%2c3.97241-1.325%2c3.97241-1.40116.4358-.26148%2c3.53661-3.47792.40262-.49449.46147-3.97241-.86409-1.52948-1.711-2.44293-2.26146-1.26055-3.97241-.65033-3.97241.15145-3.9724.72349-2.79541%2c1.03594-1.177.65045-3.97241%2c1.97594-3.97241%2c1.12533-.87306.22069-3.09935%2c1.18009-3.97241%2c1.728-3.52552%2c1.0643-.44689.1824L202.71507%2c39.047l-3.97241%2c1.15415-3.65205.895-.32036.1564L190.79784%2c44.149l-1.07946.91954.81464%2c3.97241.26482.12651%2c3.97241%2c2.24725%2c3.40493%2c1.59865.56748.19862%2c3.97241%2c2.04279%2c1.84434%2c1.731%2c2.12807%2c2.44874%2c2.26995%2c1.52367%2c1.70246%2c1.53065%2c3.97241.45555ZM286.89231%2c68.903l3.21576-.39608%2c3.97241-1.84507%2c1.99991-1.73126%2c1.9725-3.40492.2354-.56749-.2354-1.83343-.34329-2.139-3.06507-3.97241-.564-.5965-3.48734-3.37591-.48507-.42114-3.80181-3.55127-.17059-.158-3.97241-3.0174-2.12086-.797-1.85155-.87045-3.97241-.6446-3.16252%2c1.51505-.80989.4485-2.45488%2c3.52391-1.32172%2c3.97241-.19581.59163-1.10345%2c3.38078-1.0679%2c3.97241-.99089%2c3.97241L264.56%2c64.93056l1.71359.79448%2c3.97241.81856%2c3.97241%2c1.35253%2c3.97241.37184%2c3.97241.304%2c3.0377.331.93471.07925Zm-75.40483%2c31.77927%2c3.14482-.55294%2c3.97241-1.08613%2c3.97241-1.26188%2c2.9793-1.07146.99311-.47245%2c3.97241-1.85779%2c2.81052-1.64217%2c1.16188-.73124%2c3.97241-2.96088.30558-.28029%2c3.66683-3.3717.61266-.60071%2c3.35975-3.76217.17553-.21024%2c2.65284-3.97241%2c1.144-2.82249.7838-1.14992.8633-3.9724L250.384%2c67.965l-3.97241-1.57225-3.97241-.44927-3.97241-.35546-3.97241-.1789-3.9724.45742-3.97241%2c1.05018-3.97241-.40261-3.97241-.127L216.24609%2c68.903l-1.61379%2c1.16048-2.5279%2c2.81192-1.44451.7901-3.97241%2c3.16118-.01956.02113-3.95285%2c2.83544-3.97241.8779-3.97241-.03575-3.97241-1.99495-1.21937-1.68264-2.753-3.11812-.5648-.85429L183.7229%2c68.903l-.86988-2.03135-1.2795-1.94106-2.405-3.97241-.28785-.85124-1.27768-3.12117-2.2975-3.97241-.39723-.34377-3.97241-2.9085-1.00938-.72014-2.963-1.61379L162.991%2c45.9292l-1.55547-.86069-2.41694-.84466-3.97241-1.25957L151.07375%2c41.43l-.694-.33391-3.27844-1.463-3.97241-1.99236-1.00722-.51709-2.96519-1.67064-3.97241-1.90347-.931-.3983-3.04138-1.42079-3.97241-1.61616-3.66286-.93546-.30954-.08994-3.97241-.2495-3.97241.15628-.67616.18316-3.29625%2c2.64827-.64822%2c1.32414-.51444%2c3.97241.1239%2c3.97241%2c1.03876%2c3.97241h0l.956%2c3.97241.64338%2c3.97241%2c1.34982%2c3.97241%2c1.0232%2c1.76937%2c1.23348%2c2.203%2c2.73893%2c3.84955.07623.12286%2c2.87734%2c3.97241%2c1.01884%2c1.15328%2c2.33331%2c2.81912%2c1.63909%2c2.42047%2c1.4579%2c1.55194%2c1.32138%2c3.97241-.6339%2c3.97241-.82582%2c3.97241-1.23533%2c3.97241.48535%2c3.97241%2c3.02148%2c3.97241.38135.24075%2c3.97241.50286%2c2.06784-.74361%2c1.90457-1.209%2c1.98621-2.76341%2c1.32852-3.97241.65768-3.54679.10592-.42562L145.448%2c84.7926l1.65337-1.7088%2c3.97241-.76676%2c3.97241%2c1.59488.86437.88068%2c3.108%2c2.85675.81931%2c1.11566%2c3.09511%2c3.97241.058.05517%2c3.97241%2c2.73326%2c3.97241%2c1.1148.81786.06918%2c3.15455.24885%2c3.97241-.0465%2c1.23731-.20235%2c2.73509-.49655%2c3.97241-.97685%2c3.97241.13161%2c2.76975%2c1.34179%2c1.20266.58%2c3.97241%2c2.01677%2c3.97241%2c1.187%2c1.27417.18863%2c2.69824.23444%2c3.97241-.11515Z'/%3e %3cpath class='cls-11' d='M232.08252%2c41.0961l2.41182-.70936%2c3.97241-1.34753%2c3.95781-1.91552.0146-.03894.68937-3.93347-.68937-.95074-3.97241-1.83327-3.97241.08481-3.9724%2c1.0049-3.31448%2c1.6943-.65793.816-3.77011%2c3.15637%2c1.86666%2c3.97241%2c1.90345.21754%2c3.97241.14782Zm57.40132%2c23.83446.62423-.10115%2c3.97241-3.36171.31095-.50955-.31095-2.37376-.30628-1.59865-3.66613-3.75384-.24169-.21857-3.73071-3.77061-.2207-.2018L282.16326%2c46.164l-2.87418-1.09553-1.09823-.33221-3.97241.25614-.11759.07607-2.94225%2c3.97241-.91257%2c2.91081-.24828%2c1.0616-.11553%2c3.97241.36381.93025%2c1.613%2c3.04216%2c2.35944%2c1.47095%2c3.97241%2c1.23351%2c3.97241.88515%2c1.87979.3828%2c2.09262.35085ZM137.10241%2c92.73742%2c135.5695%2c88.765l-.38539-.99311-.20492.99311-2.23465%2c3.97241%2c2.43957%2c3.34986Zm81.8019%2c3.97241%2c3.67281-1.656%2c3.97241-1.8295%2c1.09025-.48691%2c2.88216-1.48548%2c3.9724-2.33376.20593-.15317%2c3.76648-2.88025%2c1.19283-1.09216%2c2.77958-3.10965.76056-.86276%2c2.5886-3.97241.62325-3.06346.19018-.90895-.19018-.4469-3.97241-3.27064L241.553%2c68.903l-3.08626-.46117-3.97241-.04137-2.10656.50254-1.86584.59015-3.97241%2c2.37747-2.669%2c1.00478-1.30344.61641-3.97241%2c2.50477-1.562.85123-2.41044.96606-3.97241%2c1.53537-2.815%2c1.471-1.15743.47319-3.97241%2c2.2001-3.97241%2c1.175-.61866.12414-3.35375%2c2.22369-3.97241.62607-.36014-2.84976L188.2%2c80.82019%2c186.82543%2c78.813l-.91709-1.96519L183.319%2c72.87537l-.466-.72292L179.92633%2c68.903l-1.04571-1.49672-2.00912-2.47569L174.90821%2c62.258l-1.07947-1.29987L170.9358%2c57.021l-.027-.03526-3.73811-3.97241-.20734-.16337L162.991%2c50.13263l-1.17058-1.09171-2.80183-1.85613-3.97241-2.11228-.00621-.004-3.9662-1.8394-3.97241-1.93018-.34679-.20283L143.12893%2c39.151l-3.94887-2.02728-.02354-.01326-3.97241-1.90125-3.97241-1.66929-1.24137-.38861-2.731-.97828-3.9724-.50723-3.97241.82946-1.48286.65605-2.48955%2c2.61493-.68366%2c1.35748L113.641%2c41.0961l.43095%2c3.97241.80916%2c3.97241.44093%2c2.2852.28738%2c1.68721%2c1.375%2c3.97241%2c2.31%2c3.5973.21368.37511%2c2.50941%2c3.97241%2c1.24932%2c1.62307%2c1.85177%2c2.34934%2c2.12063%2c2.50969%2c1.69991%2c1.46271%2c2.2725%2c2.40236%2c2.04366%2c1.57%2c1.92875%2c3.15377%2c2.24368.81864%2c1.72873%2c1.72873%2c1.0147-1.72873%2c2.95771-.95813%2c3.97241-1.748%2c3.97241-.37841%2c3.97241.81349%2c2.95924%2c2.271%2c1.01317%2c1.03406L160.778%2c84.7926l2.213%2c3.00008.74008.97233%2c3.23233%2c3.21187%2c1.68063.76054%2c2.29178.81523%2c3.97241.37063%2c3.97241-.27356%2c3.27911-.9123.69329-.2363%2c3.97241-2.05358%2c3.97241-1.53064%2c3.97241%2c1.24709%2c1.885%2c2.57343%2c2.08741%2c1.5606%2c3.24668%2c2.41181.72573.31624%2c3.97241%2c1.16553%2c3.97241.19433%2c3.97241-.53021%2c3.97241-1.04926Z'/%3e %3cpath class='cls-12' d='M286.2692%2c56.98574l-.13353-.11432-3.97241-1.47466-2.45912%2c1.589%2c2.45912%2c1.14759%2c3.97241-.72944ZM182.28554%2c88.765l.56748-.54791%2c1.82557-3.4245-.24764-3.97241L182.853%2c76.87537l-.0151-.02759-3.61247-3.97241-.34483-.38492L175.47778%2c68.903l-.56957-.69473-3.35286-3.27768-.61955-.75454-2.69159-3.21787-1.28082-1.692-1.72632-2.28045-2.24609-2.099-1.312-1.87345L159.01857%2c50.499l-1.6274-1.45808-2.345-1.46563-3.88552-2.50678-.08689-.0403-3.97241-2.08289-3.16171-1.84922-.8107-.43494-3.97241-2.08529-3.43979-1.45218-.53262-.25491L131.2117%2c35.339l-3.97241-1.04477-3.9724.09727-3.97241%2c2.584-.14445.14822-2.38169%2c3.97241-.12992%2c3.97241.53078%2c3.97241.71384%2c3.97241%2c1.41144%2c3.60115.123.37126%2c2.28008%2c3.97241%2c1.56935%2c2.28745%2c1.27519%2c1.685%2c2.69721%2c3.32463.74621.64778%2c3.2262%2c2.80742%2c1.654%2c1.165%2c2.31837%2c1.856%2c3.97241%2c1.42963%2c3.97241-.12782%2c3.97241-.97881%2c3.97241-.42856%2c3.97241-.02568%2c3.97241.87905%2c1.75128%2c1.36864%2c1.8751%2c3.97241.346.63255%2c1.56059%2c3.33986%2c2.41182%2c3.10487%2c1.21734.86754%2c2.75507%2c1.42741%2c3.97241.472%2c3.97241-.51767Zm38.16069%2c3.97241%2c2.13089-1.44939%2c3.97241-2.24128.72888-.28174%2c3.24353-1.43135%2c3.9724-2.0592.66208-.48186%2c3.31033-3.12009.744-.85232%2c2.00058-3.97241-1.61765-3.97241-1.12693-.52614-3.97241-.29741-2.36951.82355-1.60289.90015-3.23145%2c3.07226-.741.97284-3.97241%2c1.9444-2.13256%2c1.05517-1.83985.80547-3.97241.845-3.97241.98137-3.54913%2c1.34053-.42328.28219L203.01731%2c88.765l.95456%2c3.97241%2c2.71561%2c1.78685%2c3.97241.90456%2c3.97241-.51936%2c3.97241-1.41847Z'/%3e %3cpath class='cls-13' d='M145.30349%2c72.87537l1.79785-.42648%2c3.97241-.65484%2c3.97241-.73217%2c3.97241-1.03826L161.6455%2c68.903l.56747-3.97241-.02278-3.97241-1.36033-3.97241-1.81129-2.51013-1.00113-1.46228-2.97128-2.70846-1.309-1.264-2.66343-1.8396-3.06458-2.13281-.90783-.4768L143.12893%2c42.244%2c141.156%2c41.0961l-1.99951-1.05634-3.97241-1.62369-3.97241-1.27864-.10345-.01374-3.869-.65161-3.2869.65161-.6855.18576-3.52463%2c3.78665-.44778%2c2.53932-.222%2c1.43309.222%2c2.63288.0882%2c1.33953.6186%2c3.97241%2c1.33782%2c3.97241%2c1.92779%2c3.09788.60823.87453%2c3.08209%2c3.97241.28208.3477%2c3.97241%2c3.461.22543.16368%2c3.747%2c2.72052%2c3.07156%2c1.25188.90085.38518%2c3.97241.14812ZM178.93288%2c84.7926l1.10289-3.97241-1.15515-2.30069-1.09621-1.67172-2.8762-2.82981-1.6867-1.1426L170.9358%2c70.993l-3.97241-1.46937-1.07256%2c3.35172.23745%2c3.97241.334%2c3.97241.50108%2c1.099L169.22%2c84.7926l1.71584%2c1.23205%2c3.97241.474%2c3.97241-1.65507Z'/%3e %3cpath class='cls-14' d='M151.28441%2c68.903l3.76175-2.113%2c1.762-1.85942L158.31%2c60.95815l-.83968-3.97241-2.42419-3.46313-.33026-.50928-3.64215-3.525-.46017-.44746-3.51224-2.49275-1.9297-1.47966-2.04271-1.21236-3.97241-2.284-1.07-.476L135.18411%2c39.943l-3.97241-1.08857-3.97241-.23079-3.9724%2c1.66276-.7537.80972-1.2601%2c3.97241.03064%2c3.97241.58148%2c3.97241%2c1.39552%2c3.97241.00616.00988%2c2.75594%2c3.96253%2c1.21646%2c1.55213%2c2.78271%2c2.42028%2c1.1897%2c1.044%2c3.97241%2c2.88572.08988.04272%2c3.88253%2c1.76188%2c3.97241.24406%2c3.97241-.99863%2c3.97241-.944Z'/%3e %3cpath class='cls-15' d='M151.652%2c64.93056l3.02061-3.97241-.35181-3.97241-2.55354-3.97241-.69352-.6712-3.39486-3.30121-.57755-.40991-3.97241-3.028-.762-.53448L139.15652%2c43.282l-3.97241-1.70508-1.76679-.48084-2.20562-.52471-3.97241.19254-.698.33217-3.08185%2c3.97241-.19251%2c2.39514-.08213%2c1.57727.08213.5893.52716%2c3.38311%2c1.49474%2c3.97241%2c1.9505%2c2.73786%2c1.246%2c1.23455L131.2117%2c63.357l2.25917%2c1.5736%2c1.71324%2c1.26006%2c3.97241%2c1.9019%2c3.97241.29745%2c3.97241-1.30007%2c3.97241-1.75626Z'/%3e %3cpath class='cls-16' d='M145.045%2c64.93056l2.0563-.98749%2c3.84241-2.98492.13-1.19171.20447-2.7807-.20447-.32085-2.327-3.65156-1.64543-1.59842-2.28164-2.374-1.69077-1.28276-3.83475-2.68965-.13766-.07661-3.97241-1.45076-3.97241-.72788-3.97241%2c1.24532-.84518%2c1.00993-.882%2c3.97241.40753%2c3.97241%2c1.3196%2c3.741.10984.2314%2c3.86257%2c3.8273.1853.14511%2c3.78711%2c2.64019%2c2.86222%2c1.33222%2c1.11019.53749%2c3.97241.18157Z'/%3e %3cpath class='cls-17' d='M146.30514%2c60.95815l.7962-1.5654.78245-2.407-.78245-1.32106-1.47679-2.65135-2.49562-2.6106-1.52275-1.36181-2.44966-1.61033-3.97241-1.64684-3.97241-.28852-2.91863%2c3.54569.1689%2c3.97241%2c1.74748%2c3.97241%2c1.00225.9931%2c3.80448%2c2.97931.16793.11707%2c3.97241%2c1.74154%2c3.97241-.08726Z'/%3e %3c/g%3e %3c/g%3e %3ccircle cx='38.18089' cy='22.8132' r='0.9931'/%3e %3ccircle cx='52.25586' cy='24.61986' r='0.9931'/%3e %3ccircle cx='60.15102' cy='84.1939' r='0.9931'/%3e %3ccircle cx='65.27969' cy='32.28887' r='0.9931'/%3e %3ccircle cx='74.2095' cy='112.45883' r='0.9931'/%3e %3ccircle cx='77.35435' cy='91.68731' r='0.9931'/%3e %3ccircle cx='86.14471' cy='75.11478' r='0.9931'/%3e %3ccircle cx='86.19557' cy='84.50099' r='0.9931'/%3e %3ccircle cx='86.94219' cy='109.97293' r='0.9931'/%3e %3ccircle cx='88.43286' cy='25.6804' r='0.9931'/%3e %3ccircle cx='89.89499' cy='67.7429' r='0.9931'/%3e %3ccircle cx='91.4689' cy='43.60803' r='0.9931'/%3e %3ccircle cx='91.9551' cy='27.06827' r='0.9931'/%3e %3ccircle cx='92.09832' cy='89.22466' r='0.9931'/%3e %3ccircle cx='92.5046' cy='95.54871' r='0.9931'/%3e %3ccircle cx='93.70207' cy='68.448' r='0.9931'/%3e %3ccircle cx='96.4004' cy='59.43294' r='0.9931'/%3e %3ccircle cx='99.85806' cy='83.28565' r='0.9931'/%3e %3ccircle cx='101.93814' cy='36.24864' r='0.9931'/%3e %3ccircle cx='102.65901' cy='39.32426' r='0.9931'/%3e %3ccircle cx='102.76997' cy='76.06515' r='0.9931'/%3e %3ccircle cx='103.18911' cy='61.27976' r='0.9931'/%3e %3ccircle cx='104.73486' cy='34.02334' r='0.9931'/%3e %3ccircle cx='106.46707' cy='92.58216' r='0.9931'/%3e %3ccircle cx='107.87419' cy='23.17589' r='0.9931'/%3e %3ccircle cx='112.3566' cy='74.74978' r='0.9931'/%3e %3ccircle cx='112.75267' cy='20.91379' r='0.9931'/%3e %3ccircle cx='113.52484' cy='46.98448' r='0.9931'/%3e %3ccircle cx='118.07262' cy='25.15226' r='0.9931'/%3e %3ccircle cx='118.72996' cy='61.08147' r='0.9931'/%3e %3ccircle cx='119.07343' cy='26.64484' r='0.9931'/%3e %3ccircle cx='120.49252' cy='58.10851' r='0.9931'/%3e %3ccircle cx='122.76485' cy='37.90155' r='0.9931'/%3e %3ccircle cx='122.9646' cy='47.05883' r='0.9931'/%3e %3ccircle cx='123.26346' cy='50.23662' r='0.9931'/%3e %3ccircle cx='123.87099' cy='37.26342' r='0.9931'/%3e %3ccircle cx='125.33568' cy='77.20316' r='0.9931'/%3e %3ccircle cx='125.47181' cy='98.77111' r='0.9931'/%3e %3ccircle cx='129.32038' cy='100.873' r='0.9931'/%3e %3ccircle cx='130.08977' cy='90.95205' r='0.9931'/%3e %3ccircle cx='130.30451' cy='67.76746' r='0.9931'/%3e %3ccircle cx='130.43034' cy='40.07523' r='0.9931'/%3e %3ccircle cx='131.14653' cy='63.41513' r='0.9931'/%3e %3ccircle cx='131.52809' cy='43.96809' r='0.9931'/%3e %3ccircle cx='131.53907' cy='50.70142' r='0.9931'/%3e %3ccircle cx='132.47602' cy='55.61116' r='0.9931'/%3e %3ccircle cx='132.97203' cy='90.82994' r='0.9931'/%3e %3ccircle cx='133.0027' cy='33.83347' r='0.9931'/%3e %3ccircle cx='133.12332' cy='102.08097' r='0.9931'/%3e %3ccircle cx='133.91647' cy='106.73506' r='0.9931'/%3e %3ccircle cx='134.5593' cy='65.13652' r='0.9931'/%3e %3ccircle cx='135.34789' cy='41.50554' r='0.9931'/%3e %3ccircle cx='135.58979' cy='62.44736' r='0.9931'/%3e %3ccircle cx='135.85969' cy='87.38032' r='0.9931'/%3e %3ccircle cx='136.04817' cy='50.74019' r='0.9931'/%3e %3ccircle cx='136.91503' cy='81.19321' r='0.9931'/%3e %3ccircle cx='139.48931' cy='97.8843' r='0.9931'/%3e %3ccircle cx='140.02556' cy='51.72618' r='0.9931'/%3e %3ccircle cx='140.72526' cy='49.56914' r='0.9931'/%3e %3ccircle cx='141.17325' cy='48.20778' r='0.9931'/%3e %3ccircle cx='143.62606' cy='52.86419' r='0.9931'/%3e %3ccircle cx='144.54101' cy='77.94635' r='0.9931'/%3e %3ccircle cx='145.20448' cy='62.53546' r='0.9931'/%3e %3ccircle cx='146.05155' cy='83.63808' r='0.9931'/%3e %3ccircle cx='146.44984' cy='64.16139' r='0.9931'/%3e %3ccircle cx='148.35143' cy='63.15197' r='0.9931'/%3e %3ccircle cx='149.85251' cy='63.75145' r='0.9931'/%3e %3ccircle cx='151.05481' cy='43.44292' r='0.9931'/%3e %3ccircle cx='151.89107' cy='70.28554' r='0.9931'/%3e %3ccircle cx='152.29309' cy='51.87091' r='0.9931'/%3e %3ccircle cx='153.65623' cy='106.07278' r='0.9931'/%3e %3ccircle cx='153.82791' cy='58.04902' r='0.9931'/%3e %3ccircle cx='153.87256' cy='13.8911' r='0.9931'/%3e %3ccircle cx='156.92424' cy='101.86469' r='0.9931'/%3e %3ccircle cx='159.13178' cy='88.17874' r='0.9931'/%3e %3ccircle cx='160.48031' cy='62.55904' r='0.9931'/%3e %3ccircle cx='160.72393' cy='41.05825' r='0.9931'/%3e %3ccircle cx='164.63173' cy='78.55137' r='0.9931'/%3e %3ccircle cx='164.70215' cy='122.06457' r='0.9931'/%3e %3ccircle cx='165.32121' cy='78.22372' r='0.9931'/%3e %3ccircle cx='165.9529' cy='53.13856' r='0.9931'/%3e %3ccircle cx='166.16687' cy='53.69688' r='0.9931'/%3e %3ccircle cx='167.90744' cy='68.46841' r='0.9931'/%3e %3ccircle cx='168.09699' cy='36.62369' r='0.9931'/%3e %3ccircle cx='168.68731' cy='88.62242' r='0.9931'/%3e %3ccircle cx='168.73814' cy='25.85086' r='0.9931'/%3e %3ccircle cx='169.64935' cy='87.97181' r='0.9931'/%3e %3ccircle cx='172.00598' cy='90.03507' r='0.9931'/%3e %3ccircle cx='173.25885' cy='25.26018' r='0.9931'/%3e %3ccircle cx='173.56715' cy='74.8266' r='0.9931'/%3e %3ccircle cx='173.62273' cy='50.62623' r='0.9931'/%3e %3ccircle cx='173.78839' cy='78.86548' r='0.9931'/%3e %3ccircle cx='174.43254' cy='59.89589' r='0.9931'/%3e %3ccircle cx='174.61846' cy='69.8568' r='0.9931'/%3e %3ccircle cx='175.89173' cy='104.18086' r='0.9931'/%3e %3ccircle cx='176.44052' cy='95.30617' r='0.9931'/%3e %3ccircle cx='177.80456' cy='85.37491' r='0.9931'/%3e %3ccircle cx='178.1422' cy='72.84292' r='0.9931'/%3e %3ccircle cx='178.8606' cy='32.52189' r='0.9931'/%3e %3ccircle cx='180.74432' cy='15.42438' r='0.9931'/%3e %3ccircle cx='181.73845' cy='118.98539' r='0.9931'/%3e %3ccircle cx='185.34433' cy='113.91707' r='0.9931'/%3e %3ccircle cx='185.65437' cy='55.88621' r='0.9931'/%3e %3ccircle cx='186.5971' cy='45.28672' r='0.9931'/%3e %3ccircle cx='187.41826' cy='85.28533' r='0.9931'/%3e %3ccircle cx='187.64315' cy='13.87477' r='0.9931'/%3e %3ccircle cx='188.63396' cy='93.60942' r='0.9931'/%3e %3ccircle cx='188.63624' cy='42.5448' r='0.9931'/%3e %3ccircle cx='190.07166' cy='82.01256' r='0.9931'/%3e %3ccircle cx='190.58456' cy='1.37201' r='0.9931'/%3e %3ccircle cx='191.39804' cy='114.53631' r='0.9931'/%3e %3ccircle cx='192.0982' cy='79.6504' r='0.9931'/%3e %3ccircle cx='192.34119' cy='50.32086' r='0.9931'/%3e %3ccircle cx='195.20534' cy='38.40848' r='0.9931'/%3e %3ccircle cx='195.75423' cy='107.91547' r='0.9931'/%3e %3ccircle cx='196.46208' cy='17.90103' r='0.9931'/%3e %3ccircle cx='199.87387' cy='49.20781' r='0.9931'/%3e %3ccircle cx='200.4733' cy='91.23637' r='0.9931'/%3e %3ccircle cx='203.27468' cy='92.70239' r='0.9931'/%3e %3ccircle cx='203.64859' cy='63.79395' r='0.9931'/%3e %3ccircle cx='204.25384' cy='43.60966' r='0.9931'/%3e %3ccircle cx='205.18396' cy='86.75995' r='0.9931'/%3e %3ccircle cx='205.6464' cy='38.92268' r='0.9931'/%3e %3ccircle cx='205.66753' cy='95.59415' r='0.9931'/%3e %3ccircle cx='206.03642' cy='94.55009' r='0.9931'/%3e %3ccircle cx='206.66167' cy='51.29419' r='0.9931'/%3e %3ccircle cx='209.01803' cy='94.46355' r='0.9931'/%3e %3ccircle cx='209.68115' cy='16.39382' r='0.9931'/%3e %3ccircle cx='209.87916' cy='61.37972' r='0.9931'/%3e %3ccircle cx='210.0274' cy='31.00561' r='0.9931'/%3e %3ccircle cx='213.15013' cy='98.90674' r='0.9931'/%3e %3ccircle cx='213.29565' cy='71.73208' r='0.9931'/%3e %3ccircle cx='213.82258' cy='81.93446' r='0.9931'/%3e %3ccircle cx='215.06667' cy='36.81449' r='0.9931'/%3e %3ccircle cx='215.0993' cy='57.89118' r='0.9931'/%3e %3ccircle cx='215.65366' cy='68.0232' r='0.9931'/%3e %3ccircle cx='216.04405' cy='42.36954' r='0.9931'/%3e %3ccircle cx='217.69503' cy='60.82093' r='0.9931'/%3e %3ccircle cx='218.90396' cy='88.02485' r='0.9931'/%3e %3ccircle cx='220.00937' cy='91.41524' r='0.9931'/%3e %3ccircle cx='220.66663' cy='34.05206' r='0.9931'/%3e %3ccircle cx='222.6152' cy='39.77462' r='0.9931'/%3e %3ccircle cx='224.29363' cy='90.74323' r='0.9931'/%3e %3ccircle cx='226.38138' cy='52.33777' r='0.9931'/%3e %3ccircle cx='226.7197' cy='91.14194' r='0.9931'/%3e %3ccircle cx='228.55823' cy='36.20612' r='0.9931'/%3e %3ccircle cx='230.93308' cy='81.90603' r='0.9931'/%3e %3ccircle cx='232.5965' cy='99.59966' r='0.9931'/%3e %3ccircle cx='233.57916' cy='33.69144' r='0.9931'/%3e %3ccircle cx='233.79124' cy='73.64263' r='0.9931'/%3e %3ccircle cx='235.57726' cy='29.65945' r='0.9931'/%3e %3ccircle cx='236.16849' cy='44.66779' r='0.9931'/%3e %3ccircle cx='236.67777' cy='36.30567' r='0.9931'/%3e %3ccircle cx='236.97422' cy='85.94241' r='0.9931'/%3e %3ccircle cx='237.80063' cy='81.8687' r='0.9931'/%3e %3ccircle cx='237.99369' cy='73.57564' r='0.9931'/%3e %3ccircle cx='238.48185' cy='24.4579' r='0.9931'/%3e %3ccircle cx='239.76137' cy='92.67165' r='0.9931'/%3e %3ccircle cx='239.78519' cy='63.9526' r='0.9931'/%3e %3ccircle cx='239.94992' cy='78.46231' r='0.9931'/%3e %3ccircle cx='240.15348' cy='68.19464' r='0.9931'/%3e %3ccircle cx='241.84543' cy='75.95655' r='0.9931'/%3e %3ccircle cx='243.11216' cy='29.82888' r='0.9931'/%3e %3ccircle cx='243.14762' cy='112.22214' r='0.9931'/%3e %3ccircle cx='247.62172' cy='32.59968' r='0.9931'/%3e %3ccircle cx='248.85987' cy='37.67702' r='0.9931'/%3e %3ccircle cx='249.81909' cy='37.19037' r='0.9931'/%3e %3ccircle cx='253.61967' cy='61.07196' r='0.9931'/%3e %3ccircle cx='257.8257' cy='62.86431' r='0.9931'/%3e %3ccircle cx='258.96973' cy='71.63517' r='0.9931'/%3e %3ccircle cx='259.44137' cy='67.2132' r='0.9931'/%3e %3ccircle cx='261.92849' cy='108.63085' r='0.9931'/%3e %3ccircle cx='264.97542' cy='34.56487' r='0.9931'/%3e %3ccircle cx='266.33051' cy='39.16219' r='0.9931'/%3e %3ccircle cx='266.3956' cy='76.44448' r='0.9931'/%3e %3ccircle cx='266.69777' cy='15.71306' r='0.9931'/%3e %3ccircle cx='267.87026' cy='61.44244' r='0.9931'/%3e %3ccircle cx='268.89054' cy='51.94134' r='0.9931'/%3e %3ccircle cx='270.25994' cy='91.77431' r='0.9931'/%3e %3ccircle cx='271.97183' cy='77.53072' r='0.9931'/%3e %3ccircle cx='273.67973' cy='54.92682' r='0.9931'/%3e %3ccircle cx='274.91214' cy='29.74608' r='0.9931'/%3e %3ccircle cx='276.11854' cy='50.54379' r='0.9931'/%3e %3ccircle cx='276.35978' cy='27.53719' r='0.9931'/%3e %3ccircle cx='277.61041' cy='88.22951' r='0.9931'/%3e %3ccircle cx='279.33015' cy='54.95093' r='0.9931'/%3e %3ccircle cx='279.55045' cy='40.45763' r='0.9931'/%3e %3ccircle cx='281.12509' cy='70.05012' r='0.9931'/%3e %3ccircle cx='281.50244' cy='59.41894' r='0.9931'/%3e %3ccircle cx='286.24256' cy='64.36686' r='0.9931'/%3e %3ccircle cx='287.22599' cy='42.41605' r='0.9931'/%3e %3ccircle cx='288.70316' cy='40.39828' r='0.9931'/%3e %3ccircle cx='289.70881' cy='66.02374' r='0.9931'/%3e %3ccircle cx='293.23543' cy='80.7131' r='0.9931'/%3e %3ccircle cx='294.50272' cy='57.09806' r='0.9931'/%3e %3ccircle cx='294.9629' cy='61.50212' r='0.9931'/%3e %3ccircle cx='296.23917' cy='53.01796' r='0.9931'/%3e %3ccircle cx='300.97265' cy='65.92786' r='0.9931'/%3e %3ccircle cx='303.72777' cy='60.661' r='0.9931'/%3e %3ccircle cx='317.91494' cy='54.38808' r='0.9931'/%3e %3cg%3e %3cpath class='cls-18' d='M14.02563%2c140.90288H20.4808V1.86856H14.02563'/%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='140.90288' x2='14.02563' y2='140.90288'/%3e %3ctext class='cls-19' transform='translate(5.49328 144.05646)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='124.19965' x2='14.02563' y2='124.19965'/%3e %3ctext class='cls-19' transform='translate(-0.03016 127.35334)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='107.49643' x2='14.02563' y2='107.49643'/%3e %3ctext class='cls-19' transform='translate(-0.03016 110.65021)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='90.7932' x2='14.02563' y2='90.7932'/%3e %3ctext class='cls-19' transform='translate(-0.03016 93.94709)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='74.08998' x2='14.02563' y2='74.08998'/%3e %3ctext class='cls-19' transform='translate(-0.03016 77.24445)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='57.38675' x2='14.02563' y2='57.38675'/%3e %3ctext class='cls-19' transform='translate(-0.03016 60.54132)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='40.68352' x2='14.02563' y2='40.68352'/%3e %3ctext class='cls-19' transform='translate(-0.03016 43.8382)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='23.98029' x2='14.02563' y2='23.98029'/%3e %3ctext class='cls-19' transform='translate(-0.03016 27.13507)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='19.98424' y1='7.27707' x2='14.02563' y2='7.27707'/%3e %3ctext class='cls-19' transform='translate(-0.03016 10.43146)'%3e80%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-18' d='M20.4808%2c146.365v-5.46207H318.41149V146.365'/%3e %3cg%3e %3cline class='cls-18' x1='20.4808' y1='140.40633' x2='20.4808' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(17.68859 156.3714)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='57.23035' y1='140.40633' x2='57.23035' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(51.67687 156.3714)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='93.97991' y1='140.40633' x2='93.97991' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(88.42687 156.3714)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='130.72946' y1='140.40633' x2='130.72946' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(125.1759 156.3714)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='167.47902' y1='140.40633' x2='167.47902' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(161.92492 156.3714)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='204.22856' y1='140.40633' x2='204.22856' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(198.67492 156.3714)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='240.97812' y1='140.40633' x2='240.97812' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(235.42394 156.3714)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='277.72766' y1='140.40633' x2='277.72766' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(272.17394 156.3714)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-18' x1='314.47724' y1='140.40633' x2='314.47724' y2='146.36495'/%3e %3ctext class='cls-19' transform='translate(308.92297 156.3714)'%3e80%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$k = {
    name: 'Traçé de contours',
    id: 'rawgraphs.contourplot',
    thumbnail: img$D,
    icon: img$C,
    categories: ['correlations', 'distributions'],
    description: 'Il montre la densité estimée des nuages de points, ce qui est particulièrement utile pour éviter le sur-traçage dans les grands ensembles de données. ',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions$k = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date'],
    required: true
  } // {
  //   id: 'weight',
  //   name: 'Density weight',
  //   validTypes: ['number'],
  //   required: false,
  // },
  ];

  const mapData$k = {
    x: 'get',
    y: 'get',
    weight: 'get'
  };

  function colorDomain$1(data, mapping, visualOptions) {
    const {
      width,
      height,
      bandwidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      xOrigin,
      yOrigin
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    if (!data) {
      return {
        domain: [],
        type: 'number'
      };
    } // x scale


    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice();
    const contours = density().x(d => x(d.x)).y(d => y(d.y)).size([chartWidth, chartHeight]).bandwidth(bandwidth)(data);
    const domain = contours.map(d => d.value);
    return {
      domain,
      type: 'number'
    };
  }
  function render$k(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      xOrigin,
      yOrigin,
      showPoints,
      dotsDiameter,
      bandwidth,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      colorScale,
      showBandLabels,
      labelThresholds,
      showLabelsOutline,
      autoHideLabels
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // x scale

    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType.type === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType.type === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice();

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(x)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(y)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['y'].value).styles(styles.axisLabel));
    };

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    svg.append('clipPath').attr('id', 'plotClipPath').append('rect').attr('x', 0).attr('y', 0).attr('width', chartWidth).attr('height', chartHeight);
    const vizLayer = svg.append('g').attr('id', 'viz').attr('clip-path', 'url(#plotClipPath)');
    const contours = density().x(d => x(d.x)).y(d => y(d.y)).size([chartWidth, chartHeight]).bandwidth(bandwidth)(data);
    const contourBand = vizLayer.selectAll('g').data(contours).join('g');
    contourBand.append('path').attr('fill', d => colorScale(d.value)).attr('stroke', d => lab(colorScale(d.value)).darker(1)).attr('stroke-opacity', (d, i) => i % labelThresholds === 0 ? 1 : 0.3).attr('d', index$2());

    if (showPoints) {
      vizLayer.selectAll('circle').data(data).join('circle').attr('cx', d => x(d.x)).attr('cy', d => y(d.y)).attr('fill', 'black').attr('r', dotsDiameter / 2);
    }

    const labelsLayer = svg.append('g').attr('id', 'labels');
    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis);
    const steps = 40;

    if (showBandLabels) {
      // adapted from https://observablehq.com/@fil/contour-labels-svg
      contours.forEach((cont, index) => {
        if (index % labelThresholds === 0) {
          cont.coordinates.forEach(polygon => {
            polygon.forEach((ring, j) => {
              const p = ring.slice(1, Infinity),
                    // best number of steps to divide ring.length
              possibilities = sequence(steps, steps * 1.4),
                    scores = possibilities.map(d => -((p.length - 1) % d)),
                    n = possibilities[scan(scores)],
                    // best starting point: bottom for first rings, top for holes
              start = 1 + scan(p.map(xy => (j === 0 ? -1 : 1) * xy[1])) % n,
                    margin = 2;
              p.forEach((xy, i) => {
                if (i % n === start && xy[0] > margin && xy[0] < chartWidth - margin && xy[1] > margin && xy[1] < chartHeight - margin) {
                  const a = (i - 2 + p.length) % p.length,
                        b = (i + 2) % p.length,
                        dx = p[b][0] - p[a][0],
                        dy = p[b][1] - p[a][1];
                  if (dx === 0 && dy === 0) return;
                  const angle = (Math.cos(Math.atan2(dy, dx)) < 0 ? Math.PI : 0) + Math.atan2(dy, dx);
                  labelsLayer.append('text').attr('stroke', 'none').attr('text-anchor', 'middle').attr('dy', '0.3em').attr('transform', `translate(${xy})rotate(${angle * 180 / Math.PI})`).text(cont.value).styles(styles.labelSecondary); //.styles(styles.labelOutline)
                }
              });
            });
          });
        }
      });
    }

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(labelsLayer.selectAll('text'), (d, i) => i);
    }

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (colorScale.domain().length) {
        chartLegend.addColor('density', colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$k = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    xOrigin: {
      type: 'boolean',
      label: 'Origine des X à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    bandwidth: {
      type: 'number',
      label: 'Bandwidth',
      default: 20,
      step: 1,
      min: 1,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      },
      requiredDimensions: ['x', 'y']
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      domain: 'colorDomain',
      default: {
        scaleType: 'sequential',
        interpolator: 'interpolateBlues'
      },
      group: 'colors',
      requiredDimensions: ['x', 'y']
    },
    showBandLabels: {
      type: 'boolean',
      label: 'Show band labels',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y']
    },
    labelThresholds: {
      type: 'number',
      label: 'Labels threshold steps',
      default: 5,
      step: 1,
      min: 1,
      group: 'labels',
      disabled: {
        showBandLabels: false
      },
      requiredDimensions: ['x', 'y']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels',
      disabled: {
        showBandLabels: false
      },
      requiredDimensions: ['x', 'y']
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels',
      disabled: {
        showBandLabels: false
      },
      requiredDimensions: ['x', 'y']
    }
  };

  var contourPlot = {
    metadata: metadata$k,
    dimensions: dimensions$k,
    mapData: mapData$k,
    render: render$k,
    visualOptions: visualOptions$k,
    styles: styles$1,
    colorDomain: colorDomain$1
  };

  var img$E = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M32%2c34c-4%2c0-4%2c3-8%2c3s-4-3-8-3-4-2-8-2v1c4%2c0%2c4%2c3%2c8%2c3s4%2c8%2c8%2c8%2c4-9%2c8-9%2c4%2c5%2c8%2c5%2c4-7%2c8-7V32c-4%2c0-4%2c4-8%2c4S36%2c34%2c32%2c34Z'/%3e %3cpath class='cls-1' d='M32%2c29c-4%2c0-4%2c1-8%2c1s-4-1-8-1H8v2c4%2c0%2c4%2c2%2c8%2c2s4%2c3%2c8%2c3%2c4-3%2c8-3%2c4%2c2%2c8%2c2%2c4-4%2c8-4V29c-4%2c0-4%2c2-8%2c2S36%2c29%2c32%2c29Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 7.5 48 7.5 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3cpath class='cls-2' d='M40%2c16c-4%2c0-4%2c5-8%2c5s-4-9-8-9-4%2c8-8%2c8-4%2c3-8%2c3v2c4%2c0%2c4-2%2c8-2s4-3%2c8-3%2c4%2c3%2c8%2c3h8c4%2c0%2c4%2c2%2c8%2c2V23C44%2c23%2c44%2c16%2c40%2c16Z'/%3e %3cpath class='cls-2' d='M32%2c24c-4%2c0-4-3-8-3s-4%2c3-8%2c3-4%2c2-8%2c2v2h8c4%2c0%2c4%2c1%2c8%2c1s4-1%2c8-1%2c4%2c2%2c8%2c2%2c4-2%2c8-2V26c-4%2c0-4-2-8-2Z'/%3e %3c/g%3e%3c/svg%3e";

  var img$F = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2369bda9%3b %7d .cls-2 %7b fill: %239e0142%3b %7d .cls-3 %7b fill: %23f0704a%3b %7d .cls-4 %7b fill: %23fedd8d%3b %7d .cls-5 %7b fill: %23e0f3a1%3b %7d .cls-6 %7b fill: %235e4fa2%3b %7d .cls-7 %7b fill: none%3b stroke: black%3b %7d .cls-8 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d %3c/style%3e %3c/defs%3e %3cg id='viz'%3e %3cg%3e %3cg%3e %3cpath class='cls-1' d='M0%2c81.8476a44.8176%2c44.8176%2c0%2c0%2c1%2c6.952-.7647c2.3176-.0107%2c4.6357.3452%2c6.9519.3117s4.6306-.4563%2c6.952.2238%2c4.65%2c2.4633%2c6.971%2c2.8949%2c4.6354-.4883%2c6.952-1.735%2c4.6354-2.82%2c6.952-3.5848a22.7508%2c22.7508%2c0%2c0%2c1%2c6.9519-.7612%2c20.7412%2c20.7412%2c0%2c0%2c0%2c6.971-1.0168%2c33.4834%2c33.4834%2c0%2c0%2c0%2c6.952-4.0253c2.3165-1.5934%2c4.6354-3.2%2c6.952-4.9575s4.6306-3.6642%2c6.9519-4.4336%2c4.65-.401%2c6.971-.0848%2c4.6355.58%2c6.952.77a27.9579%2c27.9579%2c0%2c0%2c0%2c6.952-.0846c2.3165-.3892%2c4.6307-1.2825%2c6.9519-1.4822a18.96%2c18.96%2c0%2c0%2c1%2c6.9711.9819%2c17.8348%2c17.8348%2c0%2c0%2c1%2c6.9519%2c3.544c2.3166%2c1.9743%2c4.6355%2c5.0413%2c6.952%2c6.9918s4.6307%2c2.7849%2c6.952%2c4.4485a35.5993%2c35.5993%2c0%2c0%2c1%2c6.971%2c7.1607c2.3213%2c3.004%2c4.6354%2c6.5189%2c6.9519%2c9.5321a54.6629%2c54.6629%2c0%2c0%2c0%2c6.952%2c7.5834%2c18.8771%2c18.8771%2c0%2c0%2c0%2c6.952%2c4.3218c2.3213.6579%2c4.65.368%2c6.971%2c1.8429s4.6354%2c4.7143%2c6.952%2c7.5659%2c4.6354%2c5.3154%2c6.9519%2c6.6151a11.5921%2c11.5921%2c0%2c0%2c0%2c6.952%2c1.2444%2c20.2873%2c20.2873%2c0%2c0%2c0%2c6.971-1.7839%2c46.1506%2c46.1506%2c0%2c0%2c0%2c6.952-4.3566c2.3165-1.6472%2c4.6354-3.3075%2c6.9519-3.46s4.6307%2c1.2019%2c6.952%2c1.41%2c4.65-.7319%2c6.971-1.7575%2c4.6355-2.1372%2c6.952-3.4274a25.8593%2c25.8593%2c0%2c0%2c0%2c6.952-5.2888c2.3165-2.53%2c4.6306-6.1212%2c6.9519-8.0687s4.65-2.251%2c6.971-3.2405%2c4.6355-2.6649%2c6.952-3.303%2c4.6354-.2392%2c6.952-.3373%2c4.6306-.6931%2c6.9519-.8874%2c4.65.012%2c6.9711-.2727%2c4.6354-1.06%2c6.9519-1.4624a18.9441%2c18.9441%2c0%2c0%2c1%2c6.952.0263%2c30.6138%2c30.6138%2c0%2c0%2c1%2c6.952%2c2.4854c2.3212%2c1.09%2c4.65%2c2.33%2c6.971%2c3.2826s4.6358%2c1.618%2c6.9519%2c2.5319%2c4.6341%2c2.0761%2c6.952%2c3.2384h0c-2.3179-1.1623-4.6358-2.3246-6.952-3.2384s-4.6306-1.5792-6.9519-2.5319-4.65-2.1928-6.971-3.2826a30.6138%2c30.6138%2c0%2c0%2c0-6.952-2.4854%2c18.9441%2c18.9441%2c0%2c0%2c0-6.952-.0263c-2.3165.4019-4.6306%2c1.1777-6.9519%2c1.4624s-4.65.0783-6.9711.2727-4.6354.7894-6.9519.8874-4.6355-.3009-6.952.3373-4.6307%2c2.3133-6.952%2c3.303-4.65%2c1.2938-6.971%2c3.2469-4.6354%2c5.5552-6.9519%2c8.0843a26.31%2c26.31%2c0%2c0%2c1-6.952%2c5.2947q-3.4747%2c1.9643-6.952%2c3.5017a16.3514%2c16.3514%2c0%2c0%2c1-6.971%2c1.8464c-2.3213-.08-4.6354-1.136-6.952-.7056s-4.6354%2c2.3474-6.9519%2c4.3418-4.6307%2c4.0664-6.952%2c5.7059-4.65%2c2.8467-6.971%2c4.2365-4.6354%2c2.9623-6.952%2c3.3228-4.6354-.4909-6.9519-2.609-4.6307-5.5027-6.952-5.9987-4.65%2c1.8966-6.971%2c2.7741-4.6355.24-6.952.73-4.6354%2c2.1065-6.952.4484-4.6306-6.5912-6.9519-9.0665-4.65-2.4929-6.971-3.9662-4.6355-4.4024-6.952-5.1788-4.6354.6-6.952.1356-4.6306-2.7692-6.9519-3.5277-4.65.0292-6.9711-.1482a14.2982%2c14.2982%2c0%2c0%2c1-6.9519-2.9648c-2.3165-1.6447-4.6355-3.7914-6.952-5.0549a11.3631%2c11.3631%2c0%2c0%2c0-6.952-1.37c-2.3212.2738-4.65%2c1.2014-6.971.8959s-4.6354-1.8441-6.9519-2.821-4.6355-1.3921-6.952-.3153-4.6307%2c3.6454-6.952%2c4.6576-4.65.4677-6.971.7366-4.6354%2c1.3512-6.9519%2c4.5259-4.6355%2c8.4422-6.952%2c9.7021-4.6307-1.4876-6.952-4.2622a50.3391%2c50.3391%2c0%2c0%2c0-6.971-7.3615%2c13.6136%2c13.6136%2c0%2c0%2c0-6.952-2.824%2c33.4483%2c33.4483%2c0%2c0%2c0-6.9519.17c-2.3177.2129-4.6348.4112-6.952.6095Z'/%3e %3cpath class='cls-2' d='M0%2c81.8476a44.8176%2c44.8176%2c0%2c0%2c1%2c6.952-.7647c2.3176-.0107%2c4.6357.3452%2c6.9519.3117s4.6306-.4563%2c6.952.2238%2c4.65%2c2.4633%2c6.971%2c2.8949%2c4.6354-.4882%2c6.952-1.735%2c4.6354-2.82%2c6.952-3.5848a22.8161%2c22.8161%2c0%2c0%2c1%2c6.9519-.7612%2c20.9421%2c20.9421%2c0%2c0%2c0%2c6.971-1.0168%2c32.2254%2c32.2254%2c0%2c0%2c0%2c6.952-4.0253c2.3165-1.6164%2c4.6354-3.2865%2c6.952-5.2206s4.6306-4.1324%2c6.9519-5.685%2c4.65-2.46%2c6.971-4.0844a40.3827%2c40.3827%2c0%2c0%2c0%2c6.952-6.6433c2.3165-2.6761%2c4.6355-5.686%2c6.952-8.5265a39.4057%2c39.4057%2c0%2c0%2c1%2c6.9519-7.15c2.3213-1.6385%2c4.65-2.2447%2c6.9711-3.77s4.6354-3.97%2c6.9519-4.9651%2c4.6355-.54%2c6.952-1.6166%2c4.6307-3.6842%2c6.952-4.9667%2c4.65-1.24%2c6.971-3.6425%2c4.6354-7.2514%2c6.9519-8.9231%2c4.6355-.1666%2c6.952.3245%2c4.6307-.0318%2c6.952.9206%2c4.65%2c3.38%2c6.971%2c3.3915%2c4.6354-2.3939%2c6.952-4.4215%2c4.6354-3.6776%2c6.9519-3.9241%2c4.6307.9106%2c6.952%2c2.304%2c4.65%2c3.023%2c6.971%2c4.654%2c4.6354%2c3.2631%2c6.952%2c5.2154%2c4.6354%2c4.2245%2c6.9519%2c5.178%2c4.6307.5882%2c6.952%2c2.36%2c4.65%2c5.6814%2c6.971%2c8.584%2c4.6355%2c4.7987%2c6.952%2c7.8714%2c4.6354%2c7.3222%2c6.952%2c10.7529a40.4025%2c40.4025%2c0%2c0%2c0%2c6.9519%2c8.0521%2c47.3735%2c47.3735%2c0%2c0%2c0%2c6.971%2c4.812%2c48.715%2c48.715%2c0%2c0%2c0%2c6.952%2c3.6914c2.3165.9122%2c4.6354%2c1.3532%2c6.952%2c2.3406s4.6306%2c2.5214%2c6.9519%2c3.6227a29.2081%2c29.2081%2c0%2c0%2c0%2c6.9711%2c2.2273c2.3213.4573%2c4.6354.7034%2c6.9519%2c1.1018a22.35%2c22.35%2c0%2c0%2c1%2c6.952%2c2.1826c2.3165%2c1.2333%2c4.6307%2c3.1491%2c6.952%2c4.6s4.65%2c2.4382%2c6.971%2c3.8837%2c4.6358%2c3.3494%2c6.9519%2c4.8742A62.973%2c62.973%2c0%2c0%2c0%2c320%2c96.6121v3.6651c-2.3179-1.1623-4.6358-2.3246-6.952-3.2384s-4.6306-1.5792-6.9519-2.5319-4.65-2.1928-6.971-3.2826a30.6138%2c30.6138%2c0%2c0%2c0-6.952-2.4854%2c18.9441%2c18.9441%2c0%2c0%2c0-6.952-.0263c-2.3165.4019-4.6306%2c1.1777-6.9519%2c1.4624s-4.65.0783-6.9711.2727-4.6354.7894-6.9519.8874-4.6355-.3009-6.952.3373-4.6307%2c2.3135-6.952%2c3.303-4.65%2c1.2931-6.971%2c3.2405-4.6354%2c5.5387-6.9519%2c8.0687a25.8593%2c25.8593%2c0%2c0%2c1-6.952%2c5.2888c-2.3165%2c1.29-4.6307%2c2.4018-6.952%2c3.4274s-4.65%2c1.9651-6.971%2c1.7575-4.6354-1.5623-6.952-1.41-4.6354%2c1.8132-6.9519%2c3.46a46.1506%2c46.1506%2c0%2c0%2c1-6.952%2c4.3566%2c20.2873%2c20.2873%2c0%2c0%2c1-6.971%2c1.7839%2c11.5921%2c11.5921%2c0%2c0%2c1-6.952-1.2444c-2.3165-1.3-4.6354-3.7635-6.9519-6.6151s-4.6307-6.0911-6.952-7.5659-4.65-1.185-6.971-1.8429a18.8771%2c18.8771%2c0%2c0%2c1-6.952-4.3218%2c54.6629%2c54.6629%2c0%2c0%2c1-6.952-7.5834c-2.3165-3.0132-4.6306-6.5281-6.9519-9.5321a35.5993%2c35.5993%2c0%2c0%2c0-6.971-7.1607c-2.3213-1.6636-4.6355-2.4979-6.952-4.4485s-4.6354-5.0175-6.952-6.9918a17.8348%2c17.8348%2c0%2c0%2c0-6.9519-3.544%2c18.96%2c18.96%2c0%2c0%2c0-6.9711-.9819c-2.3212.2-4.6354%2c1.093-6.9519%2c1.4822a27.9579%2c27.9579%2c0%2c0%2c1-6.952.0846c-2.3165-.1895-4.6307-.4535-6.952-.77s-4.65-.6846-6.971.0848-4.6354%2c2.6765-6.9519%2c4.4336-4.6355%2c3.3641-6.952%2c4.9575a33.4834%2c33.4834%2c0%2c0%2c1-6.952%2c4.0253%2c20.7412%2c20.7412%2c0%2c0%2c1-6.971%2c1.0168%2c22.7508%2c22.7508%2c0%2c0%2c0-6.9519.7612c-2.3166.7648-4.6355%2c2.3382-6.952%2c3.5848s-4.6307%2c2.1666-6.952%2c1.735-4.65-2.2147-6.971-2.8949-4.6357-.2573-6.952-.2238S9.27%2c81.0722%2c6.952%2c81.0829A44.8176%2c44.8176%2c0%2c0%2c0%2c0%2c81.8476Z'/%3e %3cpath class='cls-3' d='M0%2c81.8476a44.8176%2c44.8176%2c0%2c0%2c1%2c6.952-.7647c2.3176-.0107%2c4.6357.3452%2c6.9519.3117s4.6306-.4563%2c6.952.2238%2c4.65%2c2.4633%2c6.971%2c2.8949%2c4.6354-.4882%2c6.952-1.735%2c4.6354-2.82%2c6.952-3.5848a22.8161%2c22.8161%2c0%2c0%2c1%2c6.9519-.7612%2c20.9421%2c20.9421%2c0%2c0%2c0%2c6.971-1.0168%2c32.2254%2c32.2254%2c0%2c0%2c0%2c6.952-4.0253c2.3165-1.6164%2c4.6354-3.2865%2c6.952-5.2206s4.6306-4.1324%2c6.9519-5.685%2c4.65-2.46%2c6.971-4.0844a40.3827%2c40.3827%2c0%2c0%2c0%2c6.952-6.6433c2.3165-2.6761%2c4.6355-5.686%2c6.952-8.5265a39.4057%2c39.4057%2c0%2c0%2c1%2c6.9519-7.15c2.3213-1.6385%2c4.65-2.2447%2c6.9711-3.77s4.6354-3.97%2c6.9519-4.9651%2c4.6355-.54%2c6.952-1.6166%2c4.6307-3.6842%2c6.952-4.9667%2c4.65-1.24%2c6.971-3.6425%2c4.6354-7.2514%2c6.9519-8.9231%2c4.6355-.1666%2c6.952.3245%2c4.6307-.0318%2c6.952.9206%2c4.65%2c3.38%2c6.971%2c3.3915%2c4.6354-2.3939%2c6.952-4.4215%2c4.6354-3.6774%2c6.9519-3.9241%2c4.6307.91%2c6.952%2c2.304%2c4.65%2c3.0266%2c6.971%2c4.654%2c4.6354%2c3.25%2c6.952%2c5.2154%2c4.6354%2c4.2734%2c6.9519%2c5.178%2c4.6307.4059%2c6.952.88%2c4.65%2c1.9223%2c6.971%2c2.8545%2c4.6355%2c1.3489%2c6.952%2c2.6133a34.4756%2c34.4756%2c0%2c0%2c1%2c6.952%2c5.64c2.3165%2c2.2638%2c4.6306%2c4.6792%2c6.9519%2c6.629a65.3792%2c65.3792%2c0%2c0%2c0%2c6.971%2c4.9281%2c32.6228%2c32.6228%2c0%2c0%2c0%2c6.952%2c3.7628c2.3165.7637%2c4.6354.7865%2c6.952%2c1.5051a53.2377%2c53.2377%2c0%2c0%2c1%2c6.9519%2c3.2619c2.3213%2c1.1291%2c4.65%2c1.9728%2c6.9711%2c3.1434s4.6354%2c2.6682%2c6.9519%2c3.7693%2c4.6354%2c1.806%2c6.952%2c3.76%2c4.6307%2c5.1578%2c6.952%2c7.7314%2c4.65%2c4.517%2c6.971%2c6.8892%2c4.6358%2c5.1729%2c6.9519%2c7.2968A44.6159%2c44.6159%2c0%2c0%2c0%2c320%2c91.5228v5.0893a62.973%2c62.973%2c0%2c0%2c1-6.952-3.8161c-2.3161-1.5248-4.6306-3.4288-6.9519-4.8742s-4.65-2.4323-6.971-3.8837-4.6355-3.3671-6.952-4.6a22.35%2c22.35%2c0%2c0%2c0-6.952-2.1826c-2.3165-.3984-4.6306-.6445-6.9519-1.1018a29.2081%2c29.2081%2c0%2c0%2c1-6.9711-2.2273c-2.3213-1.1013-4.6354-2.6352-6.9519-3.6227s-4.6355-1.4284-6.952-2.3406a48.715%2c48.715%2c0%2c0%2c1-6.952-3.6914%2c47.3735%2c47.3735%2c0%2c0%2c1-6.971-4.812%2c40.4025%2c40.4025%2c0%2c0%2c1-6.9519-8.0521c-2.3166-3.4307-4.6355-7.68-6.952-10.7529s-4.6307-4.9687-6.952-7.8714-4.65-6.812-6.971-8.584-4.6354-1.4067-6.952-2.36-4.6354-3.2258-6.9519-5.178-4.6307-3.5845-6.952-5.2154-4.65-3.2606-6.971-4.654-4.6354-2.55-6.952-2.304-4.6354%2c1.8965-6.9519%2c3.9241-4.6307%2c4.4328-6.952%2c4.4215-4.65-2.4391-6.971-3.3915-4.6355-.4295-6.952-.9206-4.6354-1.9962-6.952-.3245-4.6306%2c6.52-6.9519%2c8.9231-4.65%2c2.36-6.971%2c3.6425-4.6355%2c3.89-6.952%2c4.9667-4.6354.6217-6.952%2c1.6166-4.6306%2c3.44-6.9519%2c4.9651-4.65%2c2.1316-6.9711%2c3.77a39.4057%2c39.4057%2c0%2c0%2c0-6.9519%2c7.15c-2.3165%2c2.84-4.6355%2c5.85-6.952%2c8.5265A40.3827%2c40.3827%2c0%2c0%2c1%2c83.4807%2c58.4c-2.3212%2c1.6247-4.65%2c2.5318-6.971%2c4.0844s-4.6354%2c3.7509-6.9519%2c5.685-4.6355%2c3.6042-6.952%2c5.2206a32.2254%2c32.2254%2c0%2c0%2c1-6.952%2c4.0253%2c20.9421%2c20.9421%2c0%2c0%2c1-6.971%2c1.0168%2c22.8161%2c22.8161%2c0%2c0%2c0-6.9519.7612c-2.3166.7643-4.6355%2c2.338-6.952%2c3.5848s-4.6307%2c2.1667-6.952%2c1.735-4.65-2.2147-6.971-2.8949-4.6357-.2573-6.952-.2238S9.27%2c81.0722%2c6.952%2c81.0829A44.8176%2c44.8176%2c0%2c0%2c0%2c0%2c81.8476Z'/%3e %3cpath class='cls-4' d='M0%2c81.8476a44.8176%2c44.8176%2c0%2c0%2c1%2c6.952-.7647c2.3176-.0107%2c4.6357.3452%2c6.9519.3117s4.6306-.4563%2c6.952.2238%2c4.65%2c2.4633%2c6.971%2c2.8949%2c4.6354-.4882%2c6.952-1.735%2c4.6354-2.82%2c6.952-3.5848a22.8161%2c22.8161%2c0%2c0%2c1%2c6.9519-.7612%2c20.9421%2c20.9421%2c0%2c0%2c0%2c6.971-1.0168%2c32.2213%2c32.2213%2c0%2c0%2c0%2c6.952-4.0253c2.3165-1.6165%2c4.6354-3.2868%2c6.952-5.2206s4.6306-4.131%2c6.9519-5.685S81.16%2c60.02%2c83.4807%2c58.4a39.5227%2c39.5227%2c0%2c0%2c0%2c6.952-6.6433c2.3165-2.6944%2c4.6355-5.7543%2c6.952-8.5265a53.8073%2c53.8073%2c0%2c0%2c1%2c6.9519-7.15c2.3213-1.8932%2c4.65-3.1952%2c6.9711-5.1878s4.6354-4.6758%2c6.9519-5.5555%2c4.6355.0441%2c6.952-.9293%2c4.6307-3.8441%2c6.952-5.3548%2c4.65-1.6616%2c6.971-4.1822%2c4.6354-7.4108%2c6.9519-9.05%2c4.6355-.0269%2c6.952.4979%2c4.6307-.0377%2c6.952.83%2c4.65%2c3.1665%2c6.971%2c2.61%2c4.6354-3.97%2c6.952-6.0948%2c4.6354-2.9635%2c6.9519-2.621%2c4.6307%2c1.8657%2c6.952%2c3.2546%2c4.65%2c2.6434%2c6.971%2c4.2645%2c4.6354%2c3.609%2c6.952%2c5.5846%2c4.6354%2c3.939%2c6.9519%2c4.3151%2c4.6307-.835%2c6.952-.6915%2c4.65%2c1.6417%2c6.971%2c3.0112%2c4.6355%2c2.61%2c6.952%2c3.9644a25.5894%2c25.5894%2c0%2c0%2c1%2c6.952%2c5.4785c2.3165%2c2.6573%2c4.6306%2c6.5045%2c6.9519%2c8.5968s4.65%2c2.43%2c6.971%2c3.59%2c4.6355%2c3.1446%2c6.952%2c4.1258%2c4.6354.96%2c6.952%2c1.7414%2c4.6306%2c2.3671%2c6.9519%2c3.5718%2c4.65%2c2.0289%2c6.9711%2c3.2314%2c4.6354%2c2.7833%2c6.9519%2c3.9167%2c4.6354%2c1.8193%2c6.952%2c3.7731%2c4.6307%2c5.1753%2c6.952%2c7.7854%2c4.65%2c4.6088%2c6.971%2c6.9382%2c4.6358%2c4.99%2c6.9519%2c7.0781A53.9479%2c53.9479%2c0%2c0%2c0%2c320%2c89.6959v1.8269a44.6159%2c44.6159%2c0%2c0%2c1-6.952-5.0182c-2.3161-2.1239-4.6306-4.9247-6.9519-7.2968s-4.65-4.3156-6.971-6.8892-4.6355-5.7772-6.952-7.7314-4.6354-2.6591-6.952-3.76-4.6306-2.5986-6.9519-3.7693-4.65-2.0143-6.9711-3.1434a53.2377%2c53.2377%2c0%2c0%2c0-6.9519-3.2619c-2.3166-.7186-4.6355-.7414-6.952-1.5051a32.6228%2c32.6228%2c0%2c0%2c1-6.952-3.7628%2c65.3792%2c65.3792%2c0%2c0%2c1-6.971-4.9281c-2.3213-1.95-4.6354-4.3652-6.9519-6.629a34.4756%2c34.4756%2c0%2c0%2c0-6.952-5.64c-2.3165-1.2644-4.6307-1.6811-6.952-2.6133s-4.65-2.38-6.971-2.8545-4.6354.0243-6.952-.88-4.6354-3.2127-6.9519-5.178-4.6307-3.588-6.952-5.2154-4.65-3.26-6.971-4.654-4.6354-2.5507-6.952-2.304-4.6354%2c1.8966-6.9519%2c3.9241-4.6307%2c4.4327-6.952%2c4.4215-4.65-2.4391-6.971-3.3915-4.6355-.4295-6.952-.9206-4.6354-1.9962-6.952-.3245-4.6306%2c6.52-6.9519%2c8.9231-4.65%2c2.36-6.971%2c3.6425-4.6355%2c3.89-6.952%2c4.9667-4.6354.6217-6.952%2c1.6166-4.6306%2c3.44-6.9519%2c4.9651-4.65%2c2.1316-6.9711%2c3.77a39.4057%2c39.4057%2c0%2c0%2c0-6.9519%2c7.15c-2.3165%2c2.84-4.6355%2c5.85-6.952%2c8.5265A40.3827%2c40.3827%2c0%2c0%2c1%2c83.4807%2c58.4c-2.3212%2c1.6247-4.65%2c2.5318-6.971%2c4.0844s-4.6354%2c3.7509-6.9519%2c5.685-4.6355%2c3.6042-6.952%2c5.2206a32.2254%2c32.2254%2c0%2c0%2c1-6.952%2c4.0253%2c20.9421%2c20.9421%2c0%2c0%2c1-6.971%2c1.0168%2c22.8161%2c22.8161%2c0%2c0%2c0-6.9519.7612c-2.3166.7643-4.6355%2c2.338-6.952%2c3.5848s-4.6307%2c2.1667-6.952%2c1.735-4.65-2.2147-6.971-2.8949-4.6357-.2573-6.952-.2238S9.27%2c81.0722%2c6.952%2c81.0829A44.8176%2c44.8176%2c0%2c0%2c0%2c0%2c81.8476Z'/%3e %3cpath class='cls-5' d='M0%2c81.8476a44.8176%2c44.8176%2c0%2c0%2c1%2c6.952-.7647c2.3176-.0107%2c4.6357.3452%2c6.9519.3117s4.6306-.4563%2c6.952.2238%2c4.65%2c2.4633%2c6.971%2c2.8949%2c4.6354-.4882%2c6.952-1.735%2c4.6354-2.82%2c6.952-3.5848a22.8161%2c22.8161%2c0%2c0%2c1%2c6.9519-.7612%2c20.9421%2c20.9421%2c0%2c0%2c0%2c6.971-1.0168%2c32.2213%2c32.2213%2c0%2c0%2c0%2c6.952-4.0253c2.3165-1.6165%2c4.6354-3.2868%2c6.952-5.2206s4.6306-4.131%2c6.9519-5.685S81.16%2c60.02%2c83.4807%2c58.4a39.5227%2c39.5227%2c0%2c0%2c0%2c6.952-6.6433c2.3165-2.6944%2c4.6355-5.7543%2c6.952-8.5265a53.8073%2c53.8073%2c0%2c0%2c1%2c6.9519-7.15c2.3213-1.8932%2c4.65-3.1952%2c6.9711-5.1878s4.6354-4.6758%2c6.9519-5.5555%2c4.6355.0441%2c6.952-.9293%2c4.6307-3.8441%2c6.952-5.3548%2c4.65-1.6616%2c6.971-4.1822%2c4.6354-7.4108%2c6.9519-9.05%2c4.6355-.0269%2c6.952.4979%2c4.6307-.0376%2c6.952.83%2c4.65%2c3.1665%2c6.971%2c2.61%2c4.6354-3.9694%2c6.952-6.0948S178.5489.7%2c180.8654%2c1.043s4.6307%2c1.8667%2c6.952%2c3.2546%2c4.65%2c2.64%2c6.971%2c4.2645%2c4.6354%2c3.6233%2c6.952%2c5.5846%2c4.6354%2c3.8859%2c6.9519%2c4.3151%2c4.6307-.6368%2c6.952-.7472a16.0385%2c16.0385%2c0%2c0%2c1%2c6.971%2c1.744%2c77.2661%2c77.2661%2c0%2c0%2c1%2c6.952%2c3.4814%2c25.15%2c25.15%2c0%2c0%2c1%2c6.952%2c5.299c2.3165%2c2.5762%2c4.6306%2c6.3047%2c6.9519%2c8.3083s4.65%2c2.2821%2c6.971%2c3.296%2c4.6355%2c2.7629%2c6.952%2c3.4694%2c4.6354.37%2c6.952.54%2c4.6306.8455%2c6.9519%2c1.1456%2c4.65.2243%2c6.9711.5723%2c4.6354%2c1.12%2c6.9519%2c1.6693a18.6794%2c18.6794%2c0%2c0%2c0%2c6.952.5489%2c26.0028%2c26.0028%2c0%2c0%2c0%2c6.952-2.3781c2.3212-1.0648%2c4.65-2.2095%2c6.971-3.1173s4.6358-1.5788%2c6.9519-2.4088%2c4.6341-1.8192%2c6.952-2.8084v52.62a53.9479%2c53.9479%2c0%2c0%2c1-6.952-5.1225c-2.3161-2.0886-4.6306-4.7487-6.9519-7.0781s-4.65-4.3281-6.971-6.9382-4.6355-5.8317-6.952-7.7854-4.6354-2.64-6.952-3.7731-4.6306-2.7142-6.9519-3.9167-4.65-2.0267-6.9711-3.2314-4.6354-2.79-6.9519-3.5718-4.6355-.76-6.952-1.7414-4.6307-2.9652-6.952-4.1258-4.65-1.498-6.971-3.59-4.6354-5.9395-6.9519-8.5968a25.5894%2c25.5894%2c0%2c0%2c0-6.952-5.4785c-2.3165-1.3541-4.6307-2.5949-6.952-3.9644s-4.65-2.8677-6.971-3.0112-4.6354%2c1.0676-6.952.6915-4.6354-2.34-6.9519-4.3151-4.6307-3.9634-6.952-5.5846-4.65-2.8757-6.971-4.2645-4.6354-2.9121-6.952-3.2546-4.6354.4957-6.9519%2c2.621-4.6307%2c5.5378-6.952%2c6.0948-4.65-1.7416-6.971-2.61-4.6355-.3055-6.952-.83-4.6354-2.1369-6.952-.4979-4.6306%2c6.5294-6.9519%2c9.05-4.65%2c2.6714-6.971%2c4.1822-4.6355%2c4.3814-6.952%2c5.3548-4.6354.05-6.952.9293-4.6306%2c3.5629-6.9519%2c5.5555-4.65%2c3.2946-6.9711%2c5.1878a53.8073%2c53.8073%2c0%2c0%2c0-6.9519%2c7.15c-2.3165%2c2.7722-4.6355%2c5.8321-6.952%2c8.5265A39.5227%2c39.5227%2c0%2c0%2c1%2c83.4807%2c58.4c-2.3212%2c1.62-4.65%2c2.53-6.971%2c4.0844s-4.6354%2c3.7512-6.9519%2c5.685-4.6355%2c3.6041-6.952%2c5.2206a32.2213%2c32.2213%2c0%2c0%2c1-6.952%2c4.0253%2c20.9421%2c20.9421%2c0%2c0%2c1-6.971%2c1.0168%2c22.8161%2c22.8161%2c0%2c0%2c0-6.9519.7612c-2.3166.7643-4.6355%2c2.338-6.952%2c3.5848s-4.6307%2c2.1667-6.952%2c1.735-4.65-2.2147-6.971-2.8949-4.6357-.2573-6.952-.2238S9.27%2c81.0722%2c6.952%2c81.0829A44.8176%2c44.8176%2c0%2c0%2c0%2c0%2c81.8476Z'/%3e %3cpath class='cls-6' d='M0%2c32.5809c2.3172.1983%2c4.6343.3966%2c6.952.6095a33.4483%2c33.4483%2c0%2c0%2c0%2c6.9519.17%2c13.6136%2c13.6136%2c0%2c0%2c0%2c6.952-2.824%2c50.334%2c50.334%2c0%2c0%2c0%2c6.971-7.3615c2.3213-2.7746%2c4.6354-5.5221%2c6.952-4.2622s4.6354%2c6.5273%2c6.952%2c9.7021%2c4.6306%2c4.257%2c6.9519%2c4.5259%2c4.65-.2755%2c6.971.7366%2c4.6355%2c3.5809%2c6.952%2c4.6576%2c4.6354.6616%2c6.952-.3153%2c4.6306-2.5155%2c6.9519-2.821%2c4.65.6221%2c6.971.8959a11.3631%2c11.3631%2c0%2c0%2c0%2c6.952-1.37c2.3165-1.2634%2c4.6355-3.41%2c6.952-5.0548a14.2984%2c14.2984%2c0%2c0%2c1%2c6.9519-2.9649c2.3213-.1774%2c4.65.61%2c6.9711-.1482s4.6354-3.0634%2c6.9519-3.5277%2c4.6355.912%2c6.952.1356%2c4.6307-3.7055%2c6.952-5.1788%2c4.65-1.4908%2c6.971-3.9661%2c4.6354-7.4084%2c6.9519-9.0666%2c4.6355-.0413%2c6.952.4484%2c4.6307-.148%2c6.952.7295%2c4.65%2c3.27%2c6.971%2c2.7741%2c4.6354-3.8807%2c6.952-5.9987%2c4.6354-2.9695%2c6.9519-2.609%2c4.6307%2c1.933%2c6.952%2c3.3228%2c4.65%2c2.5969%2c6.971%2c4.2365%2c4.6354%2c3.7114%2c6.952%2c5.7059%2c4.6354%2c3.9115%2c6.9519%2c4.3419%2c4.6307-.6259%2c6.952-.7057a16.3514%2c16.3514%2c0%2c0%2c1%2c6.971%2c1.8464q3.482%2c1.5444%2c6.952%2c3.5017a26.3126%2c26.3126%2c0%2c0%2c1%2c6.952%2c5.2947c2.3165%2c2.5291%2c4.6306%2c6.1312%2c6.9519%2c8.0843s4.65%2c2.2572%2c6.971%2c3.2469%2c4.6355%2c2.6649%2c6.952%2c3.3031%2c4.6354.2391%2c6.952.3372%2c4.6306.6931%2c6.9519.8874%2c4.65-.012%2c6.9711.2727%2c4.6354%2c1.0606%2c6.9519%2c1.4624a18.9441%2c18.9441%2c0%2c0%2c0%2c6.952-.0263%2c30.6138%2c30.6138%2c0%2c0%2c0%2c6.952-2.4854c2.3212-1.09%2c4.65-2.33%2c6.971-3.2826s4.6358-1.618%2c6.9519-2.5319%2c4.6341-2.0761%2c6.952-3.2384V37.076c-2.3179.9892-4.6358%2c1.9783-6.952%2c2.8084s-4.6306%2c1.5009-6.9519%2c2.4088-4.65%2c2.0525-6.971%2c3.1173a26.0028%2c26.0028%2c0%2c0%2c1-6.952%2c2.3781%2c18.6794%2c18.6794%2c0%2c0%2c1-6.952-.5489c-2.3165-.55-4.6306-1.3213-6.9519-1.6693s-4.65-.2723-6.9711-.5723-4.6354-.9759-6.9519-1.1456-4.6355.1666-6.952-.54-4.6307-2.4556-6.952-3.4694-4.65-1.2925-6.971-3.296-4.6354-5.7321-6.9519-8.3083a25.15%2c25.15%2c0%2c0%2c0-6.952-5.299%2c77.2661%2c77.2661%2c0%2c0%2c0-6.952-3.4814%2c16.0385%2c16.0385%2c0%2c0%2c0-6.971-1.744c-2.3213.11-4.6354%2c1.1764-6.952.7472s-4.6354-2.3537-6.9519-4.3151-4.6307-3.96-6.952-5.5846-4.65-2.8767-6.971-4.2645-4.6354-2.9118-6.952-3.2546-4.6354.4956-6.9519%2c2.621-4.6307%2c5.5378-6.952%2c6.0948-4.65-1.7416-6.971-2.61-4.6355-.3055-6.952-.83-4.6354-2.1369-6.952-.4979-4.6306%2c6.5294-6.9519%2c9.05-4.65%2c2.6714-6.971%2c4.1822-4.6355%2c4.3814-6.952%2c5.3548-4.6354.05-6.952.9293-4.6306%2c3.5629-6.9519%2c5.5555-4.65%2c3.2946-6.9711%2c5.1878a53.8073%2c53.8073%2c0%2c0%2c0-6.9519%2c7.15c-2.3165%2c2.7722-4.6355%2c5.8321-6.952%2c8.5265A39.5227%2c39.5227%2c0%2c0%2c1%2c83.4807%2c58.4c-2.3212%2c1.62-4.65%2c2.53-6.971%2c4.0844s-4.6354%2c3.7512-6.9519%2c5.685-4.6355%2c3.6041-6.952%2c5.2206a32.2213%2c32.2213%2c0%2c0%2c1-6.952%2c4.0253%2c20.9421%2c20.9421%2c0%2c0%2c1-6.971%2c1.0168%2c22.8161%2c22.8161%2c0%2c0%2c0-6.9519.7612c-2.3166.7643-4.6355%2c2.338-6.952%2c3.5848s-4.6307%2c2.1667-6.952%2c1.735-4.65-2.2147-6.971-2.8949-4.6357-.2573-6.952-.2238S9.27%2c81.0722%2c6.952%2c81.0829A44.8176%2c44.8176%2c0%2c0%2c0%2c0%2c81.8476Z'/%3e %3c/g%3e %3cg id='xAxis'%3e %3cpath class='cls-7' d='M.5%2c139.174h320'/%3e %3cg%3e %3cline class='cls-7' x1='14.4039' y1='138.674' x2='14.4039' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(3.281 154.774)'%3e1975%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='49.1828' y1='138.674' x2='49.1828' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(38.0598 154.774)'%3e1980%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='83.9807' y1='138.674' x2='83.9807' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(72.8577 154.774)'%3e1985%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='118.7596' y1='138.674' x2='118.7596' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(107.6365 154.774)'%3e1990%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='153.5385' y1='138.674' x2='153.5385' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(142.4155 154.774)'%3e1995%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='188.3174' y1='138.674' x2='188.3174' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(177.1943 154.774)'%3e2000%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='223.1153' y1='138.674' x2='223.1153' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(211.9922 154.774)'%3e2005%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='257.8942' y1='138.674' x2='257.8942' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(246.7712 154.774)'%3e2010%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='292.6731' y1='138.674' x2='292.6731' y2='144.674'/%3e %3ctext class='cls-8' transform='translate(281.55 154.774)'%3e2015%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$l = {
    name: 'Streamgraph (area chart)',
    id: 'rawgraphs.streamgraph',
    thumbnail: img$F,
    icon: img$E,
    categories: ['Series temporelles', 'correlations', 'proportions'],
    description: 'It allows the comparison of multiple categories over a continuous dimension.',
    code: 'https://observablehq.com/@d3/streamgraph' // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$l = [{
    id: 'x',
    name: 'Axe X',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    operation: 'get',
    validTypes: ['number'],
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'streams',
    name: 'Streams',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$l = function (data, mapping, dataTypes, dimensions) {
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    let results = [];
    rollups(data, v => rollups(v, vv => {
      const item = {
        x: vv[0][mapping.x.value],
        //get the first one since it's grouped
        size: sizeAggregator(vv.map(d => d[mapping.size.value])),
        // aggregate
        series: vv[0][mapping.series.value],
        //get the first one since it's grouped
        streams: vv[0][mapping.streams.value] //get the first one since it's grouped

      };
      results.push(item);
    }, d => d[mapping.x.value].toString() // sub-group functions. toString() to enable grouping on dates
    ), d => d[mapping.series.value], // series grouping
    d => d[mapping.streams.value] // group functions
    );
    return results;
  };

  function render$l(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      streamsOrder,
      streamsPadding,
      streamsOffset,
      interpolation,
      showYAxis,
      // series options
      columnsNumber,
      useSameScale,
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth,
      // labels
      showLabels,
      labelsType,
      showLabelsOutline
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; //check if there are negative values, in case throw error

    data.forEach(d => {
      if (d.size < 0) {
        throw new Error('Values cannot be negative');
      }
    });
    const streamsDomain = [...new Set(data.map(d => d.streams))]; // create the stack function
    // define the function to retrieve the value
    // inspired by https://observablehq.com/@stevndegwa/stack-chart

    let stack$1 = stack().keys(streamsDomain).value((data, key) => data[1].has(key) ? data[1].get(key).size : 0).order(d3[streamsOrder]).offset(d3[streamsOffset]); // create nest structure

    const nestedData = rollups(data, v => {
      let localStack = Array.from(rollup(v.sort((a, b) => ascending(a.x, b.x)), // check that x axis is properly sorted
      ([e]) => e, e => e.x, e => e.streams));
      return stack$1(localStack);
    }, d => d.series).map(d => ({
      data: d,
      totalSize: sum(d[1], d => d.size)
    })); // series sorting functions

    const seriesSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a.totalValue, b.totalValue);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a.totalValue, b.totalValue);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      }
    }; // sort series

    nestedData.sort(seriesSortings[sortSeriesBy]); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(columnsNumber);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz');
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')'); // calculate global stacks value

    const stacksValues = nestedData.map(d => d.data[1]).flat(2);
    const globalDomain = [min(stacksValues, d => d[0]), max(stacksValues, d => d[1])]; // x scale

    const xDomain = extent(data, e => e.x);
    const xScale = mapping.x.dataType.type === 'date' ? time() : linear$2();
    xScale.domain(xDomain).range([0, griddingData[0].width - margin.right - margin.left]); // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }
    /*
        YOU CAN PUT HERE CODE THAT APPLIES TO ALL THE SERIES
      */


    series.each(function (d, serieIndex) {
      // make a local selection for each serie
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // compute each serie width and height

      const serieWidth = d.width - margin.right - margin.left;
      const serieHeight = d.height - margin.top - margin.bottom;
      const stackedData = d.data[1]; // console.log(Object.assign({}, stackedData))
      //add padding to data

      stackedData[0].map((row, rowIndex) => {
        // get the value for each vertical stack
        let vStack = stackedData.map(d => d[rowIndex]);
        let index = 0;
        console.log(Object.assign({}, vStack)); // re-sort them by initial value

        vStack.sort((a, b) => ascending(a[1], b[1])).sort((a, b) => ascending(a[0], b[0]));
        vStack.forEach((e, i) => {
          const pv = rowIndex > 0 ? stackedData[i][rowIndex - 1] : [null, null]; // const cv = stackedData[i][rowIndex]

          const nv = rowIndex < stackedData[0].length - 1 ? stackedData[i][rowIndex + 1] : ['a', 'b'];
          e.padding = index * streamsPadding;

          if (e[0] != e[1] || nv[0] != nv[1] || pv[0] != pv[1]) {
            index++;
          }
        });
      });
      let localDomain = [min(stackedData, d => min(d, d => d[0])), max(stackedData, d => max(d, d => d[1]))];
      const sizeScale = linear$2().domain(useSameScale ? globalDomain : localDomain).nice().range([serieHeight, 0]);
      selection.append('g').selectAll('path').data(stackedData).join('path').attr('fill', ({
        key
      }) => {
        return colorScale(key);
      }).attr('d', area$3().curve(d3[interpolation]).x(d => xScale(d.data[0])).y0(d => sizeScale(d[0]) - d.padding).y1(d => sizeScale(d[1]) - d.padding)).append('title').text(({
        key
      }) => key);
      selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + serieHeight + ')').call(axisBottom(xScale).tickSizeOuter(0));

      if (showYAxis) {
        selection.append('g').attr('id', 'yAxis') //.attr('transform', 'translate(0,' + serieHeight + ')')
        .call(axisLeft(sizeScale).tickSizeOuter(0));
      }

      if (showSeriesLabels) {
        select(this).append('text').attr('x', 4).attr('y', 4).text(d => d.data[0]).styles(styles.seriesLabel);
      } // add the axes titles


      selection.append('text').styles(styles.axisLabel).attr('y', serieHeight - 4).attr('x', serieWidth).attr('text-anchor', 'end').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping.x.value);
      selection.append('text').styles(styles.axisLabel).attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping['size'].value);

      if (showLabels) {
        // if is on path, add paths to defs and then add texts
        if (labelsType == 'On path') {
          let defs = select(svgNode).append('defs');
          defs.selectAll('path').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('path').attr('id', (d, i) => 'path-' + serieIndex + '-' + i).attr('d', line().curve(d3[interpolation]).x(d => xScale(d.data[0])).y(d => sizeScale((d[0] + d[1]) / 2)));
          selection.append('g').attr('id', 'labels').selectAll('text').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('text').attr('dy', '0.5ex').attr('class', 'label').append('textPath').attr('xlink:xlink:href', (d, i) => '#path-' + serieIndex + '-' + i).attr('startOffset', d => {
            // find max value
            const maxIndex$1 = maxIndex(d, e => e[1] - e[0]); // get x position

            d.offset = Math.round(maxIndex$1 / d.length * 100); //clamp offset between 5% and 95%, return it

            return Math.min(95, Math.max(5, d.offset)) + '%';
          }).attr('alignment-baseline', 'middle').attr('text-anchor', d => d.offset > 90 ? 'end' : d.offset < 10 ? 'start' : 'middle').text(d => d.key).styles(styles.labelPrimary);

          if (showLabelsOutline) {
            labels.styles(styles.labelOutline);
          }
        } // if it is on point, find the maximum point


        if (labelsType == 'On point') {
          let labels = selection.append('g').attr('id', 'labels').selectAll('text').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('text').attr('x', d => {
            // find max value index
            const maxIndex$1 = maxIndex(d, e => e[1] - e[0]);
            d.maxElement = d[maxIndex$1]; // get x position

            return xScale(d.maxElement.data[0]);
          }).attr('y', d => sizeScale((d.maxElement[0] + d.maxElement[1]) / 2)).attr('text-anchor', d => xScale(d.maxElement.data[0]) > serieWidth - 10 ? 'end' : xScale(d.maxElement.data[0]) < 10 ? 'start' : 'middle').attr('alignment-baseline', 'middle').text(d => d.key).styles(styles.labelPrimary);

          if (showLabelsOutline) {
            labels.styles(styles.labelOutline);
          }
        }
      }
    }); // add legend

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);
      chartLegend.addColor('Colors', colorScale);
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$l = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    streamsOrder: {
      type: 'text',
      label: 'Sort streams by',
      group: 'chart',
      options: [{
        label: 'Earliest',
        value: 'stackOrderAppearance'
      }, {
        label: 'Ascending',
        value: 'stackOrderAscending'
      }, {
        label: 'Descending',
        value: 'stackOrderDescending'
      }, {
        label: 'Inside out',
        value: 'stackOrderInsideOut'
      }, {
        label: 'None',
        value: 'stackOrderNone'
      }, {
        label: 'Reverse',
        value: 'stackOrderReverse'
      }],
      default: 'stackOrderNone'
    },
    interpolation: {
      type: 'text',
      label: 'Type de courbe',
      default: 'curveMonotoneX',
      options: [{
        label: 'Basis',
        value: 'curveBasis'
      }, {
        label: 'Cardinal',
        value: 'curveCardinal'
      }, {
        label: 'Catmull–Rom',
        value: 'curveCatmullRom'
      }, {
        label: 'Linear',
        value: 'curveLinear'
      }, {
        label: 'Monotone X',
        value: 'curveMonotoneX'
      }, {
        label: 'Natural',
        value: 'curveNatural'
      }, {
        label: 'Step',
        value: 'curveStep'
      }, {
        label: 'Step After',
        value: 'curveStepAfter'
      }, {
        label: 'Step Before',
        value: 'curveStepBefore'
      }],
      group: 'chart'
    },
    streamsOffset: {
      type: 'text',
      label: 'Streams vertical alignment',
      group: 'chart',
      options: [{
        label: 'Expand',
        value: 'stackOffsetExpand'
      }, // { label: 'Diverging', value: 'stackOffsetDiverging' },
      {
        label: 'Silhouette',
        value: 'stackOffsetSilhouette'
      }, {
        label: 'Wiggle',
        value: 'stackOffsetWiggle'
      }, {
        label: 'None',
        value: 'stackOffsetNone'
      }],
      default: 'stackOffsetNone'
    },
    streamsPadding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    showYAxis: {
      type: 'boolean',
      label: 'Show Y axis',
      default: false,
      group: 'chart'
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Total value (descending)'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: false,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'streams',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    showLabels: {
      type: 'boolean',
      label: 'Show streams labels',
      default: true,
      group: 'Labels'
    },
    labelsType: {
      type: 'text',
      label: 'Labels position',
      group: 'Labels',
      options: ['On path', 'On point'],
      default: 'On point',
      disabled: {
        showLabels: false
      }
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'Labels',
      disabled: {
        showLabels: false
      }
    }
  };

  var streamgraph = {
    metadata: metadata$l,
    dimensions: dimensions$l,
    mapData: mapData$l,
    render: render$l,
    visualOptions: visualOptions$l,
    styles: styles$1
  };

  var img$G = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M44.7314%2c23.7588l-5-11a3%2c3%2c0%2c0%2c0-5.7275%2c1.0835l-1%2c19A3%2c3%2c0%2c0%2c0%2c38.4%2c34.8l6-8A3.0018%2c3.0018%2c0%2c0%2c0%2c44.7314%2c23.7588ZM36%2c34a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c36%2c34Zm1-19a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c37%2c15Zm5%2c11a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c42%2c26Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3cpath class='cls-2' d='M27.8066%2c24.605a3.0043%2c3.0043%2c0%2c0%2c0-2.6308-.49l-7%2c2a3.0008%2c3.0008%2c0%2c0%2c0-2.168%2c2.6709l-1%2c14A3%2c3%2c0%2c0%2c0%2c19.8%2c45.4l8-6A2.9984%2c2.9984%2c0%2c0%2c0%2c29%2c37V27A2.9986%2c2.9986%2c0%2c0%2c0%2c27.8066%2c24.605ZM18%2c44a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c18%2c44Zm1-14a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c19%2c30Zm7%2c8a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c26%2c38Zm0-10a1%2c1%2c0%2c1%2c1%2c1-1A1.0013%2c1.0013%2c0%2c0%2c1%2c26%2c28Z'/%3e %3c/g%3e%3c/svg%3e";

  var img$H = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Generator: Adobe Illustrator 25.1.0%2c SVG Export Plug-In . SVG Version: 6.00 Build 0) --%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 320 160' style='enable-background:new 0 0 320 160%3b' xml:space='preserve'%3e%3cstyle type='text/css'%3e .st0%7bopacity:0.5%3bfill:%231F77B4%3bstroke:%231F77B4%3bstroke-width:10%3bstroke-linejoin:round%3benable-background:new %3b%7d .st1%7bfill:%231F77B4%3b%7d .st2%7bopacity:0.5%3bfill:%23FF7F0E%3bstroke:%23FF7F0E%3bstroke-width:10%3bstroke-linejoin:round%3benable-background:new %3b%7d .st3%7bfill:%23FF7F0E%3b%7d .st4%7bfill:none%3bstroke:black%3b%7d .st5%7bfont-family:'Helvetica'%3b%7d .st6%7bfont-size:15.0329px%3b%7d%3c/style%3e%3cg id='visualization' transform='translate(100%2c50)'%3e %3cg id='viz'%3e %3cg%3e %3cpath class='st0' d='M184.2%2c40l-6-45.1H103L92.5%2c35.5l3%2c15L184.2%2c40z'/%3e %3cg%3e %3ccircle class='st1' cx='103' cy='-5.1' r='3'/%3e %3ccircle class='st1' cx='178.1' cy='-5.1' r='3'/%3e %3ccircle class='st1' cx='116.5' cy='18.9' r='3'/%3e %3ccircle class='st1' cx='179.6' cy='18.9' r='3'/%3e %3ccircle class='st1' cx='92.5' cy='35.5' r='3'/%3e %3ccircle class='st1' cx='95.5' cy='50.5' r='3'/%3e %3ccircle class='st1' cx='184.2' cy='40' r='3'/%3e %3ccircle class='st1' cx='116.5' cy='41.5' r='3'/%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='st2' d='M66.9%2c39.2L15.8%2c16.7l-54.1%2c51.1l3%2c10.5L66.9%2c39.2z'/%3e %3cg%3e %3ccircle class='st3' cx='-35.3' cy='78.3' r='3'/%3e %3ccircle class='st3' cx='-38.3' cy='67.8' r='3'/%3e %3ccircle class='st3' cx='-35.3' cy='78.3' r='3'/%3e %3ccircle class='st3' cx='15.8' cy='16.6' r='3'/%3e %3ccircle class='st3' cx='35.3' cy='51.3' r='3'/%3e %3ccircle class='st3' cx='66.9' cy='39.2' r='3'/%3e %3ccircle class='st3' cx='5.5' cy='47.5' r='3'/%3e %3ccircle class='st3' cx='20.3' cy='54.3' r='3'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='labels'%3e %3cg transform='translate(2%2c51)'%3e %3c/g%3e %3cg transform='translate(101%2c0)'%3e %3c/g%3e %3cg transform='translate(85%2c13)'%3e %3c/g%3e %3cg transform='translate(5%2c43)'%3e %3c/g%3e %3cg transform='translate(151%2c0)'%3e %3c/g%3e %3cg transform='translate(3%2c54)'%3e %3c/g%3e %3cg transform='translate(4%2c43)'%3e %3c/g%3e %3cg transform='translate(6%2c57)'%3e %3c/g%3e %3cg transform='translate(5%2c55)'%3e %3c/g%3e %3cg transform='translate(110%2c16)'%3e %3c/g%3e %3cg transform='translate(1%2c51)'%3e %3c/g%3e %3cg transform='translate(27%2c38)'%3e %3c/g%3e %3cg transform='translate(4%2c50)'%3e %3c/g%3e %3cg transform='translate(152%2c16)'%3e %3c/g%3e %3cg transform='translate(5%2c51)'%3e %3c/g%3e %3cg transform='translate(2%2c54)'%3e %3c/g%3e %3cg transform='translate(19%2c39)'%3e %3c/g%3e %3cg transform='translate(64%2c24)'%3e %3c/g%3e %3cg transform='translate(2%2c52)'%3e %3c/g%3e %3cg transform='translate(49%2c38)'%3e %3c/g%3e %3cg transform='translate(6%2c57)'%3e %3c/g%3e %3cg transform='translate(94%2c27)'%3e %3c/g%3e %3cg transform='translate(40%2c36)'%3e %3c/g%3e %3cg transform='translate(10%2c48)'%3e %3c/g%3e %3cg transform='translate(32%2c42)'%3e %3c/g%3e %3cg transform='translate(108%2c24)'%3e %3c/g%3e %3cg transform='translate(81%2c28)'%3e %3c/g%3e %3cg transform='translate(53%2c39)'%3e %3c/g%3e %3cg transform='translate(1%2c54)'%3e %3c/g%3e %3cg transform='translate(74%2c31)'%3e %3c/g%3e %3cg transform='translate(4%2c57)'%3e %3c/g%3e %3cg transform='translate(0%2c54)'%3e %3c/g%3e %3cg transform='translate(96%2c37)'%3e %3c/g%3e %3cg transform='translate(155%2c30)'%3e %3c/g%3e %3cg transform='translate(1%2c57)'%3e %3c/g%3e %3cg transform='translate(3%2c51)'%3e %3c/g%3e %3cg transform='translate(23%2c45)'%3e %3c/g%3e %3cg transform='translate(40%2c40)'%3e %3c/g%3e %3cg transform='translate(40%2c41)'%3e %3c/g%3e %3cg transform='translate(64%2c33)'%3e %3c/g%3e %3cg transform='translate(64%2c29)'%3e %3c/g%3e %3cg transform='translate(40%2c40)'%3e %3c/g%3e %3cg transform='translate(43%2c41)'%3e %3c/g%3e %3cg transform='translate(64%2c40)'%3e %3c/g%3e %3cg transform='translate(85%2c31)'%3e %3c/g%3e %3cg transform='translate(110%2c31)'%3e %3c/g%3e %3cg transform='translate(14%2c50)'%3e %3c/g%3e %3cg transform='translate(85%2c34)'%3e %3c/g%3e %3cg transform='translate(76%2c32)'%3e %3c/g%3e %3cg transform='translate(2%2c55)'%3e %3c/g%3e %3c/g%3e %3cg id='axis'%3e %3cg transform='translate(0%2c60)'%3e %3cpath class='st4' d='M-48.1%2c34.1v-8.3h255.6v8.3'/%3e %3cg transform='translate(0.5%2c0)'%3e %3cline class='st4' x1='-48.6' y1='25.1' x2='-48.6' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -52.7808 49.2707)' class='st5 st6'%3e0%3c/text%3e %3c/g%3e %3cg transform='translate(21.5%2c0)'%3e %3cline class='st4' x1='-38' y1='25.1' x2='-38' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -46.3911 49.2707)' class='st5 st6'%3e50%3c/text%3e %3c/g%3e %3cg transform='translate(43.5%2c0)'%3e %3cline class='st4' x1='-27' y1='25.1' x2='-27' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -39.4995 49.2707)' class='st5 st6'%3e100%3c/text%3e %3c/g%3e %3cg transform='translate(64.5%2c0)'%3e %3cline class='st4' x1='-16.4' y1='25.1' x2='-16.4' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -28.9302 49.2707)' class='st5 st6'%3e150%3c/text%3e %3c/g%3e %3cg transform='translate(85.5%2c0)'%3e %3cline class='st4' x1='-5.8' y1='25.1' x2='-5.8' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -18.3613 49.2707)' class='st5 st6'%3e200%3c/text%3e %3c/g%3e %3cg transform='translate(106.5%2c0)'%3e %3cline class='st4' x1='4.7' y1='25.1' x2='4.7' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 -7.793 49.2707)' class='st5 st6'%3e250%3c/text%3e %3c/g%3e %3cg transform='translate(128.5%2c0)'%3e %3cline class='st4' x1='15.8' y1='25.1' x2='15.8' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 3.2793 49.2707)' class='st5 st6'%3e300%3c/text%3e %3c/g%3e %3cg transform='translate(149.5%2c0)'%3e %3cline class='st4' x1='26.4' y1='25.1' x2='26.4' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 13.8496 49.2707)' class='st5 st6'%3e350%3c/text%3e %3c/g%3e %3cg transform='translate(170.5%2c0)'%3e %3cline class='st4' x1='37' y1='25.1' x2='37' y2='34.1'/%3e %3ctext transform='matrix(1 0 0 1 24.418 49.2707)' class='st5 st6'%3e400%3c/text%3e %3c/g%3e %3c/g%3e %3cpath class='st4' d='M-57.9%2c85.8h9.8V-39.8h-9.8'/%3e %3cline class='st4' x1='-48.9' y1='85.8' x2='-57.9' y2='85.8'/%3e %3ctext transform='matrix(1 0 0 1 -70.7417 90.6301)' class='st5 st6'%3e0%3c/text%3e %3cline class='st4' x1='-48.9' y1='67' x2='-57.9' y2='67'/%3e %3ctext transform='matrix(1 0 0 1 -87.4624 72.694)' class='st5 st6'%3e400%3c/text%3e %3cline class='st4' x1='-48.9' y1='50.2' x2='-57.9' y2='50.2'/%3e %3ctext transform='matrix(1 0 0 1 -87.4624 54.758)' class='st5 st6'%3e800%3c/text%3e %3cline class='st4' x1='-48.9' y1='31.4' x2='-57.9' y2='31.4'/%3e %3ctext transform='matrix(1 0 0 1 -100.0005 36.822)' class='st5 st6'%3e1%2c200%3c/text%3e %3cline class='st4' x1='-48.9' y1='14.6' x2='-57.9' y2='14.6'/%3e %3ctext transform='matrix(1 0 0 1 -100.0005 18.8857)' class='st5 st6'%3e1%2c600%3c/text%3e %3cline class='st4' x1='-48.9' y1='-4.2' x2='-57.9' y2='-4.2'/%3e %3ctext transform='matrix(1 0 0 1 -100.0005 0.9496)' class='st5 st6'%3e2%2c000%3c/text%3e %3cline class='st4' x1='-48.9' y1='-21' x2='-57.9' y2='-21'/%3e %3ctext transform='matrix(1 0 0 1 -100.0005 -16.9861)' class='st5 st6'%3e2%2c400%3c/text%3e %3cline class='st4' x1='-48.9' y1='-39.8' x2='-57.9' y2='-39.8'/%3e %3ctext transform='matrix(1 0 0 1 -100.0005 -34.922)' class='st5 st6'%3e2%2c800%3c/text%3e %3c/g%3e%3c/g%3e%3c/svg%3e";

  const metadata$m = {
    name: 'Convex hull',
    id: 'rawgraphs.convexhull',
    thumbnail: img$H,
    icon: img$G,
    categories: ['correlations', 'proportions'],
    description: 'In mathematics, the convex hull is the smallest convex shape containing a set of points. Applied to a scatterplot, it is useful to identify points belonging to the same category.',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions$m = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'group',
    name: 'Groups',
    validTypes: ['string'],
    required: false
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true
  }];

  const mapData$m = {
    x: 'get',
    y: 'get',
    group: 'get',
    label: 'get'
  };

  function render$m(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      xOrigin,
      yOrigin,
      showPoints,
      dotsDiameter,
      groupStrokeWidth,
      groupOpacity,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      colorScale,
      showLabelsOutline,
      autoHideLabels,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // x scale

    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const x = mapping.x.dataType.type === 'date' ? time() : linear$2();
    x.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const y = mapping.y.dataType.type === 'date' ? time() : linear$2();
    y.domain(yDomain).rangeRound([chartHeight, 0]).nice();

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(x)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(y)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['y'].value).styles(styles.axisLabel));
    };

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    const vizLayer = svg.append('g').attr('id', 'viz');
    const hullsData = groups(data, d => d.group && d.group.length ? d.group : null);
    const hulls = vizLayer.selectAll('g.hulls').data(hullsData).join('g').attr('class', 'hulls');
    hulls.append('path').attr('d', d => {
      const points = d[1].map(p => [x(p.x), y(p.y)]);

      if (points.length === 1) {
        return arc()({
          innerRadius: 0,
          outerRadius: groupStrokeWidth / 2,
          startAngle: 0,
          endAngle: 360
        });
      } else if (points.length === 2) {
        return `M${points.join('L')}Z`;
      } else {
        const hull$1 = hull(points);
        return `M${hull$1.join('L')}Z`;
      }
    }).attr('fill', d => colorScale(d[0])).attr('stroke', d => colorScale(d[0])).attr('stroke-width', d => d[1].length === 1 ? 0 : groupStrokeWidth).attr('stroke-linejoin', 'round').attr('opacity', groupOpacity).filter(d => d[1].length === 1).attr('transform', d => `translate(${x(d[1][0].x)}, ${y(d[1][0].y)})`);
    const points = hulls.append('g').selectAll('cirlce').data(d => d[1]).join('circle');

    if (showPoints) {
      points.attr('cx', d => x(d.x)).attr('cy', d => y(d.y)).attr('fill', d => {
        return colorScale(d.group);
      }).attr('r', dotsDiameter / 2);
    }

    const labelsLayer = svg.append('g').attr('id', 'labels');
    labelsLayer.selectAll('g').data(mapping.label.value ? data : []).join('g').attr('transform', d => `translate(${x(d.x)},${y(d.y)})`).append('text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => Array.isArray(d.label) ? d.label : [d.label]).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * 12).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats$1[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${-height / 2})`;
      });
    });
    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis);

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(labelsLayer.selectAll('text'), d => d.size);
    }

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.group.value) {
        chartLegend.addColor(mapping.group.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$m = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard',
      requiredDimensions: ['x', 'y', 'group']
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    xOrigin: {
      type: 'boolean',
      label: 'Origine des X à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    groupStrokeWidth: {
      type: 'number',
      label: 'Groups stroke width',
      default: 10,
      step: 1,
      min: 1,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    groupOpacity: {
      type: 'number',
      label: 'Fill opacity',
      default: 0.5,
      step: 0.1,
      min: 0,
      max: 1,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: true,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      },
      requiredDimensions: ['x', 'y']
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'group',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors',
      requiredDimensions: ['x', 'y']
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic'],
      requiredDimensions: ['x', 'y', 'label']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y', 'label']
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels',
      requiredDimensions: ['x', 'y', 'label']
    }
  };

  var convexHull = {
    metadata: metadata$m,
    dimensions: dimensions$m,
    mapData: mapData$m,
    render: render$m,
    visualOptions: visualOptions$m,
    styles: styles$1
  };

  var img$I = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M23.5286%2c24.4514c1.2226-.9042%2c2.1708-2.8385%2c3.027-5.0461C25.4194%2c16.268%2c24.0343%2c14%2c22%2c14c-6.6416%2c0-7.3584%2c3-14%2c3v8c6.6416%2c0%2c7.3584-1%2c14-1A2.8974%2c2.8974%2c0%2c0%2c1%2c23.5286%2c24.4514Z'/%3e %3cpath class='cls-1' d='M35%2c38a11.8359%2c11.8359%2c0%2c0%2c0-5.2772%2c1.04C30.9988%2c42.9069%2c32.5164%2c46%2c35%2c46c4.7651%2c0%2c5.9744-5.1755%2c8.7442-8.08a17.9385%2c17.9385%2c0%2c0%2c1-2.57-4.2376C39.9042%2c35.8521%2c38.3113%2c38%2c35%2c38Z'/%3e %3cpath class='cls-1' d='M48%2c36V28a7.1682%2c7.1682%2c0%2c0%2c0-.9037.0736%2c5.4882%2c5.4882%2c0%2c0%2c0-2.8935%2c1.4053C45.2312%2c33.1176%2c46.457%2c36%2c48%2c36Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M8%2c33c6.6416%2c0%2c7.3584%2c7%2c14%2c7%2c6.6235%2c0%2c6.3765-3%2c13-3s5-10%2c13-10V15c-6.6235%2c0-6.3765%2c11-13%2c11s-6.3765%2c9-13%2c9c-6.6416%2c0-7.3584-9-14-9Z'/%3e %3cpath class='cls-2' d='M15.7742%2c29.867C17.5874%2c32.0847%2c19.1533%2c34%2c22%2c34a6.2%2c6.2%2c0%2c0%2c0%2c.9881-.0869c2.1463-.3934%2c3.3405-2.0781%2c4.6959-3.9912q.1486-.21.3-.4224c1.29-2.0409%2c2.7418-4.0632%2c5.9826-4.4244A7.6248%2c7.6248%2c0%2c0%2c1%2c35%2c25c2.7355%2c0%2c4.0791-2.3177%2c5.6349-5.0015.0734-.1267.1479-.2547.2224-.3825C39.4494%2c13.4455%2c37.87%2c8%2c35%2c8c-6.6235%2c0-6.3765%2c18-13%2c18-2.9321%2c0-4.7091%2c1.7546-6.3513%2c3.714Z'/%3e %3cpath class='cls-2' d='M43.3555%2c30.1727A17.9405%2c17.9405%2c0%2c0%2c0%2c41.7832%2c32.62C43.2888%2c35.9017%2c44.8841%2c39%2c48%2c39V37C45.9127%2c37%2c44.5082%2c34.1176%2c43.3555%2c30.1727Z'/%3e %3cpath class='cls-2' d='M10.5426%2c34.4705A6.2893%2c6.2893%2c0%2c0%2c1%2c8%2c35v4a10.3825%2c10.3825%2c0%2c0%2c0%2c6.1459-1.931A11.4313%2c11.4313%2c0%2c0%2c0%2c10.5426%2c34.4705Z'/%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 7.5 48 7.5 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3c/g%3e%3c/svg%3e";

  var img$J = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %239e0142%3b %7d .cls-2 %7b fill: %23e0f3a1%3b %7d .cls-3 %7b fill: %23f0704a%3b %7d .cls-4 %7b fill: %23fedd8d%3b %7d .cls-5 %7b fill: %235e4fa2%3b %7d .cls-6 %7b fill: %2369bda9%3b %7d .cls-7 %7b fill: none%3b stroke: black%3b %7d .cls-8 %7b font-size: 10px%3b font-family: Helvetica%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cpath class='cls-1' d='M49.30307%2c104.9359c17.26325%2c0%2c17.26325-3.334%2c34.5265-3.334%2c17.2538%2c0%2c17.2538%2c8.46788%2c34.5076%2c8.46788s17.25379-7.92986%2c34.5076-7.92986%2c17.25379%2c22.76886%2c34.50759%2c22.76886c17.26324%2c0%2c17.26324-21.68757%2c34.5265-21.68757%2c17.25379%2c0%2c17.25379-37.08151%2c34.50758-37.08151S273.64023%2c87.5315%2c290.89405%2c87.5315c13.80493%2c0%2c13.80493%2c11.3125%2c27.60985%2c11.3125V94.96949c-13.80492%2c0-13.80492-17.27063-27.60985-17.27063-17.25382%2c0-17.25382-36.62338-34.50761-36.62338s-17.25379-24.7692-34.50758-24.7692C204.6156%2c16.30628%2c204.6156%2c0%2c187.35236%2c0c-17.2538%2c0-17.2538%2c1.88305-34.50759%2c1.88305S135.591%2c67.46977%2c118.33717%2c67.46977s-17.2538%2c28.303-34.5076%2c28.303C66.56632%2c95.77276%2c66.56632%2c104.9359%2c49.30307%2c104.9359Z'/%3e %3cpath class='cls-2' d='M187.35236%2c137.91575c17.26324%2c0%2c17.26324-26.08116%2c34.5265-26.08116%2c17.25379%2c0%2c17.25379-24.81226%2c34.50758-24.81226s17.25379-10.31567%2c34.50761-10.31567c13.80493%2c0%2c13.80493%2c17.27063%2c27.60985%2c17.27063v-5.38c-13.80492%2c0-13.80492-27.58951-27.60985-27.58951-17.25382%2c0-17.25382%2c6.12414-34.50761%2c6.12414s-17.25379%2c37.0815-34.50758%2c37.0815c-17.26326%2c0-17.26326%2c33.70233-34.5265%2c33.70233'/%3e %3cpath class='cls-3' d='M83.82957%2c103.58632c17.2538%2c0%2c17.2538%2c12.81955%2c34.5076%2c12.81955s17.25379%2c16.88376%2c34.5076%2c16.88376%2c17.25379%2c2.13675%2c34.50759%2c2.13675c17.26324%2c0%2c17.26324-17.53365%2c34.5265-17.53365%2c17.25379%2c0%2c17.25379-22.71816%2c34.50758-22.71816s17.25379-1.43534%2c34.50761-1.43534c13.80493%2c0%2c13.80493%2c12.19748%2c27.60985%2c12.19748v-1.93133C304.699%2c104.00538%2c304.699%2c91.82%2c290.89405%2c91.82c-17.25382%2c0-17.25382.59558-34.50761.59558s-17.25379%2c20.41121-34.50758%2c20.41121c-17.26326%2c0-17.26326%2c19.96343-34.5265%2c19.96343-17.2538%2c0-17.2538-1.82836-34.50759-1.82836S135.591%2c114.283%2c118.33717%2c114.283%2c101.08337%2c103.58632%2c83.82957%2c103.58632Z'/%3e %3cpath class='cls-4' d='M187.35236%2c138.908c17.26324%2c0%2c17.26324-18.62461%2c34.5265-18.62461%2c17.25379%2c0%2c17.25379-28.86%2c34.50758-28.86s17.25379-31.4078%2c34.50761-31.4078c13.80493%2c0%2c13.80493%2c27.58951%2c27.60985%2c27.58951V31.979c-13.80492%2c0-13.80492%2c12.19748-27.60985%2c12.19748-17.25382%2c0-17.25382%2c43.838-34.50761%2c43.838s-17.25379%2c30.8704-34.50758%2c30.8704c-17.26326%2c0-17.26326%2c20.023-34.5265%2c20.023'/%3e %3cpath class='cls-5' d='M221.87886%2c122.49366c-17.26326%2c0-17.26326%2c3.40734-34.5265%2c3.40734-17.2538%2c0-17.2538-22.76886-34.50759-22.76886S135.591%2c20.51768%2c118.33717%2c20.51768s-17.2538%2c13.81175-34.5076%2c13.81175c-17.26325%2c0-17.26325%2c45.53772-34.5265%2c45.53772-17.25379%2c0-17.25379%2c3.13162-34.50759%2c3.13162-6.89774%2c0-6.89774.47888-13.79548.47888v21.0574c6.89774%2c0%2c6.89774-.82368%2c13.79548-.82368%2c17.2538%2c0%2c17.2538.23233%2c34.50759.23233%2c17.26325%2c0%2c17.26325-33.52436%2c34.5265-33.52436%2c17.2538%2c0%2c17.2538-3.94177%2c34.5076-3.94177s17.25379%2c63.49209%2c34.5076%2c63.49209%2c17.25379%2c1.82836%2c34.50759%2c1.82836C204.6156%2c131.798%2c204.6156%2c122.49366%2c221.87886%2c122.49366Z'/%3e %3cpath class='cls-6' d='M1%2c82.48545c6.89774%2c0%2c6.89774-.47887%2c13.79548-.47887%2c17.2538%2c0%2c17.2538-3.13163%2c34.50759-3.13163%2c17.26325%2c0%2c17.26325%2c15.90561%2c34.5265%2c15.90561%2c17.2538%2c0%2c17.2538%2c18.51026%2c34.5076%2c18.51026s17.25379%2c21.74968%2c34.5076%2c21.74968%2c17.25379%2c1.883%2c34.50759%2c1.883c17.26324%2c0%2c17.26324-15.42209%2c34.5265-15.42209%2c17.25379%2c0%2c17.25379-24.66119%2c34.50758-24.66119s17.25379-6.01247%2c34.50761-6.01247c13.80493%2c0%2c13.80493%2c12.18538%2c27.60985%2c12.18538v-3.177c-13.80492%2c0-13.80492-11.3125-27.60985-11.3125-17.25382%2c0-17.25382%2c7.64307-34.50761%2c7.64307s-17.25379%2c25.10877-34.50758%2c25.10877c-17.26326%2c0-17.26326%2c15.143-34.5265%2c15.143-17.2538%2c0-17.2538-2.13675-34.50759-2.13675S135.591%2c111.062%2c118.33717%2c111.062s-17.2538-39.65046-34.5076-39.65046c-17.26325%2c0-17.26325-40.41609-34.5265-40.41609-17.25379%2c0-17.25379.23233-34.50759.23233-6.89774%2c0-6.89774-.82368-13.79548-.82368Z'/%3e %3cg%3e %3cpath class='cls-7' d='M1.4961%2c144.86115v-5.4571H319v5.4571'/%3e %3cg%3e %3cline class='cls-7' x1='15.29079' y1='138.90795' x2='15.29079' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(4.25488 154.88281)'%3e1975%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='49.79839' y1='138.90795' x2='49.79839' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(38.7627 154.88281)'%3e1980%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='84.32488' y1='138.90795' x2='84.32488' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(73.28809 154.88281)'%3e1985%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='118.83248' y1='138.90795' x2='118.83248' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(107.7959 154.88281)'%3e1990%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='153.34008' y1='138.90795' x2='153.34008' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(142.30371 154.88281)'%3e1995%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='187.84768' y1='138.90795' x2='187.84768' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(176.81152 154.88281)'%3e2000%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='222.37417' y1='138.90795' x2='222.37417' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(211.33691 154.88281)'%3e2005%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='256.88175' y1='138.90795' x2='256.88175' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(245.84473 154.88281)'%3e2010%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-7' x1='291.38937' y1='138.90795' x2='291.38937' y2='144.86115'/%3e %3ctext class='cls-8' transform='translate(280.35352 154.88281)'%3e2015%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$n = {
    name: 'Bumpchart',
    id: 'rawgraphs.bumpchart',
    thumbnail: img$J,
    icon: img$I,
    categories: ['Series temporelles', 'correlations', 'proportions'],
    description: 'It allows the comparison of multiple categories over a continuous dimension and the evolution of its sorting. By default, sorting is based on the stream size.' // code: '',
    // tutorial: "https://rawgraphs.io/learning/",

  };

  const dimensions$n = [{
    id: 'x',
    name: 'Axe X',
    operation: 'get',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'size',
    name: 'Taille',
    operation: 'get',
    validTypes: ['number'],
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'rank',
    name: 'Ranking',
    operation: 'get',
    validTypes: ['number'],
    aggregation: true,
    aggregationDefault: 'sum'
  }, {
    id: 'streams',
    name: 'Streams',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }, {
    id: 'series',
    name: 'Séries',
    validTypes: ['number', 'string', 'date'],
    required: false,
    operation: 'get'
  }];

  const mapData$n = function (data, mapping, dataTypes, dimensions) {
    const sizeAggregator = getDimensionAggregator('size', mapping, dataTypes, dimensions);
    const rankAggregator = getDimensionAggregator('rank', mapping, dataTypes, dimensions);
    let results = [];
    rollups(data, v => rollups(v, vv => {
      const item = {
        x: vv[0][mapping.x.value],
        //get the first one since it's grouped
        size: sizeAggregator(vv.map(d => d[mapping.size.value])),
        // aggregate
        rank: rankAggregator(vv.map(d => d[mapping.rank.value])),
        // aggregate
        series: vv[0][mapping.series.value],
        //get the first one since it's grouped
        streams: vv[0][mapping.streams.value] //get the first one since it's grouped

      };
      results.push(item);
    }, d => d[mapping.x.value].toString() // sub-group functions. toString() to enable grouping on dates
    ), d => d[mapping.series.value], // series grouping
    d => d[mapping.streams.value] // group functions
    );
    return results;
  };

  function render$n(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      // artboard options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      streamsOrder,
      streamsPadding,
      //@TODO: fix padding for different sortings
      streamsOffset,
      interpolation,
      showYAxis,
      // series options
      columnsNumber,
      useSameScale,
      sortSeriesBy,
      showSeriesLabels,
      repeatAxesLabels,
      showGrid = true,
      // color options
      colorScale,
      // legend
      showLegend,
      legendWidth,
      // labels
      showLabels,
      labelsType,
      showLabelsOutline
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; //check if there are negative values, in case throw error

    data.forEach(d => {
      if (d.size < 0) {
        throw new Error('Values cannot be negative');
      }
    });
    const streamsDomain = [...new Set(data.map(d => d.streams))]; // create the stack function
    // define the function to retrieve the value
    // inspired by https://observablehq.com/@stevndegwa/stack-chart

    let stack$1 = stack().keys(streamsDomain).value((data, key) => data[1].has(key) ? data[1].get(key).size : 0).order(d3[streamsOrder]).offset(d3[streamsOffset]); // create nest structure

    const nestedData = rollups(data, v => {
      let localStack = Array.from(rollup(v.sort((a, b) => ascending(a.x, b.x)), // check that x axis is properly sorted
      ([e]) => e, e => e.x, e => e.streams));
      let stackedData = stack$1(localStack); // re-sort streams

      stackedData[0].map((row, rowIndex) => {
        // get the value for each vertical stack
        let vStack = stackedData.map(d => d[rowIndex]); // get min value (depending from stack function)

        let minValue = min(vStack, d => d[0]); // keep original order

        vStack.forEach((d, i) => {
          d.originalIndex = i;
        });

        if (mapping.rank.value) {
          let rankedKeys = stackedData.map(d => d.key);
          vStack.forEach((d, i) => {
            if (d.data[1].has(rankedKeys[i])) {
              d.rank = d.data[1].get(rankedKeys[i]).rank;
            } else {
              d.rank = Infinity;
            }
          }); // sort by ranking value

          vStack.sort((a, b) => descending(a.rank, b.rank));
        } else {
          //sort by size
          vStack.sort((a, b) => ascending(a[1] - a[0], b[1] - b[0]));
        } // re-calculate positions


        vStack.forEach((d, i) => {
          const delta = d[1] - d[0];
          d[0] = minValue;
          d[1] = minValue + delta;
          d.rankIndex = i;
          minValue += delta;
        });
      });
      return stackedData;
    }, d => d.series).map(d => ({
      data: d,
      totalSize: sum(d[1], d => d.size)
    })); // series sorting functions

    const seriesSortings = {
      'Total value (descending)': function (a, b) {
        return descending(a.totalValue, b.totalValue);
      },
      'Total value (ascending)': function (a, b) {
        return ascending(a.totalValue, b.totalValue);
      },
      Name: function (a, b) {
        return ascending(a[0], b[0]);
      }
    }; // sort series

    nestedData.sort(seriesSortings[sortSeriesBy]); // add background

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // set up grid

    const gridding$1 = gridding().size([width, height]).mode('grid').padding(0) // no padding, margins will be applied inside
    .cols(columnsNumber);
    const griddingData = gridding$1(nestedData);
    const svg = select(svgNode).append('g').attr('id', 'viz');
    const series = svg.selectAll('g').data(griddingData).join('g').attr('id', d => d[0]).attr('transform', d => 'translate(' + d.x + ',' + d.y + ')'); // calculate global stacks value

    const stacksValues = nestedData.map(d => d.data[1]).flat(2);
    const globalDomain = [min(stacksValues, d => d[0]), max(stacksValues, d => d[1])]; // x scale

    const xDomain = extent(data, e => e.x);
    const xScale = mapping.x.dataType.type === 'date' ? time() : linear$2();
    xScale.domain(xDomain).range([0, griddingData[0].width - margin.right - margin.left]); // add grid

    if (showGrid) {
      svg.append('g').attr('id', 'grid').selectAll('rect').data(griddingData).enter().append('rect').attr('x', d => d.x).attr('y', d => d.y).attr('width', d => d.width).attr('height', d => d.height).attr('fill', 'none').attr('stroke', '#ccc');
    }
    /*
        YOU CAN PUT HERE CODE THAT APPLIES TO ALL THE SERIES
      */


    series.each(function (d, serieIndex) {
      // make a local selection for each serie
      const selection = select(this).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // compute each serie width and height

      const serieWidth = d.width - margin.right - margin.left;
      const serieHeight = d.height - margin.top - margin.bottom;
      const stackedData = d.data[1]; //add padding to data

      stackedData[0].map((row, rowIndex) => {
        // get the value for each vertical stack
        let vStack = stackedData.map(d => d[rowIndex]);
        let index = 0;
        vStack.sort((a, b) => ascending(a.rankIndex, b.rankIndex)).forEach((e, i) => {
          rowIndex > 0 ? stackedData[e.originalIndex][rowIndex - 1] : [null, null];
          const nv = rowIndex < stackedData[0].length - 1 ? stackedData[e.originalIndex][rowIndex + 1] : ['a', 'b'];
          e.padding = index * streamsPadding;

          if (e[0] != e[1] || nv[0] != nv[1]) {
            index++;
          }
        });
      });
      let localDomain = [min(stackedData, d => min(d, d => d[0])), max(stackedData, d => max(d, d => d[1]))];
      const sizeScale = linear$2().domain(useSameScale ? globalDomain : localDomain).nice().range([serieHeight, 0]);
      selection.append('g').selectAll('path').data(stackedData).join('path').attr('fill', ({
        key
      }) => {
        return colorScale(key);
      }).attr('d', area$3().curve(d3[interpolation]).x(d => xScale(d.data[0])).y0(d => sizeScale(d[0]) - d.padding).y1(d => sizeScale(d[1]) - d.padding)).append('title').text(({
        key
      }) => key);
      selection.append('g').attr('id', 'xAxis').attr('transform', 'translate(0,' + serieHeight + ')').call(axisBottom(xScale).tickSizeOuter(0));

      if (showYAxis) {
        selection.append('g').attr('id', 'yAxis') //.attr('transform', 'translate(0,' + serieHeight + ')')
        .call(axisLeft(sizeScale).tickSizeOuter(0));
      }

      if (showSeriesLabels) {
        select(this).append('text').attr('x', 4).attr('y', 4).text(d => d.data[0]).styles(styles.seriesLabel);
      } // add the axes titles


      selection.append('text').styles(styles.axisLabel).attr('y', serieHeight - 4).attr('x', serieWidth).attr('text-anchor', 'end').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping.x.value);
      selection.append('text').styles(styles.axisLabel).attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').attr('display', serieIndex == 0 || repeatAxesLabels ? null : 'none').text(mapping['size'].value);

      if (showLabels) {
        // if is on path, add paths to defs and then add texts
        if (labelsType == 'On path') {
          let defs = select(svgNode).append('defs');
          defs.selectAll('path').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('path').attr('id', (d, i) => 'path-' + serieIndex + '-' + i).attr('d', line().curve(d3[interpolation]).x(d => xScale(d.data[0])).y(d => sizeScale((d[0] + d[1]) / 2)));
          selection.append('g').attr('id', 'labels').selectAll('text').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('text').attr('dy', '0.5ex').attr('class', 'label').append('textPath').attr('xlink:xlink:href', (d, i) => '#path-' + serieIndex + '-' + i).attr('startOffset', d => {
            // find max value
            const maxIndex$1 = maxIndex(d, e => e[1] - e[0]); // get x position

            d.offset = Math.round(maxIndex$1 / d.length * 100); //clamp offset between 5% and 95%, return it

            return Math.min(95, Math.max(5, d.offset)) + '%';
          }).attr('alignment-baseline', 'middle').attr('text-anchor', d => d.offset > 90 ? 'end' : d.offset < 10 ? 'start' : 'middle').text(d => d.key).styles(styles.labelPrimary);

          if (showLabelsOutline) {
            labels.styles(styles.labelOutline);
          }
        } // if it is on point, find the maximum point


        if (labelsType == 'On point') {
          let labels = selection.append('g').attr('id', 'labels').selectAll('text').data(stackedData.filter(d => sum(d, e => e[1] - e[0]) > 0)).join('text').attr('x', d => {
            // find max value index
            const maxIndex$1 = maxIndex(d, e => e[1] - e[0]);
            d.maxElement = d[maxIndex$1]; // get x position

            return xScale(d.maxElement.data[0]);
          }).attr('y', d => sizeScale((d.maxElement[0] + d.maxElement[1]) / 2)).attr('text-anchor', d => xScale(d.maxElement.data[0]) > serieWidth - 10 ? 'end' : xScale(d.maxElement.data[0]) < 10 ? 'start' : 'middle').attr('alignment-baseline', 'middle').text(d => d.key).styles(styles.labelPrimary);

          if (showLabelsOutline) {
            labels.styles(styles.labelOutline);
          }
        }
      }
    }); // add legend

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);
      chartLegend.addColor('Colors', colorScale);
      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$n = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 10,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 10,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    interpolation: {
      type: 'text',
      label: 'Curves type',
      default: 'curveMonotoneX',
      options: [{
        label: 'Basis',
        value: 'curveBasis'
      }, {
        label: 'Cardinal',
        value: 'curveCardinal'
      }, {
        label: 'Catmull–Rom',
        value: 'curveCatmullRom'
      }, {
        label: 'Linear',
        value: 'curveLinear'
      }, {
        label: 'Monotone X',
        value: 'curveMonotoneX'
      }, {
        label: 'Natural',
        value: 'curveNatural'
      }, {
        label: 'Step',
        value: 'curveStep'
      }, {
        label: 'Step After',
        value: 'curveStepAfter'
      }, {
        label: 'Step Before',
        value: 'curveStepBefore'
      }],
      group: 'chart'
    },
    streamsOffset: {
      type: 'text',
      label: 'Streams vertical alignment',
      group: 'chart',
      options: [{
        label: 'Expand',
        value: 'stackOffsetExpand'
      }, {
        label: 'Silhouette',
        value: 'stackOffsetSilhouette'
      }, {
        label: 'None',
        value: 'stackOffsetNone'
      }],
      default: 'stackOffsetNone'
    },
    streamsPadding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    showYAxis: {
      type: 'boolean',
      label: 'Show Y axis',
      default: false,
      group: 'chart',
      disabled: {
        streamsOffset: 'stackOffsetSilhouette'
      }
    },
    useSameScale: {
      type: 'boolean',
      label: 'Utiliser la même échelle',
      default: true,
      group: 'series'
    },
    columnsNumber: {
      type: 'number',
      label: 'Nombre de colonnes',
      default: 0,
      group: 'series'
    },
    sortSeriesBy: {
      type: 'text',
      label: 'Trier les séries par',
      group: 'series',
      options: ['Total value (descending)', 'Total value (ascending)', 'Name', 'Original'],
      default: 'Total value (descending)'
    },
    showSeriesLabels: {
      type: 'boolean',
      label: 'Show series titles',
      default: true,
      group: 'series'
    },
    showGrid: {
      type: 'boolean',
      label: 'Show series grid',
      default: false,
      group: 'series'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'streams',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    showLabels: {
      type: 'boolean',
      label: 'Show streams labels',
      default: true,
      group: 'Labels'
    },
    labelsType: {
      type: 'text',
      label: 'Labels position',
      group: 'Labels',
      options: ['On path', 'On point'],
      default: 'On point',
      disabled: {
        showLabels: false
      }
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'Labels',
      disabled: {
        showLabels: false
      }
    }
  };

  var bumpchart = {
    metadata: metadata$n,
    dimensions: dimensions$n,
    mapData: mapData$n,
    render: render$n,
    visualOptions: visualOptions$n,
    styles: styles$1
  };

  var img$K = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3crect class='cls-1' x='34' y='20' width='8' height='4'/%3e %3crect class='cls-1' x='14' y='30' width='22' height='4'/%3e %3crect class='cls-1' x='22' y='35' width='10' height='4'/%3e %3crect class='cls-1' x='28' y='40' width='17' height='4'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 7.5 48 7.5 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3crect class='cls-2' x='8' y='10' width='10' height='4'/%3e %3crect class='cls-2' x='8' y='25' width='6' height='4'/%3e %3crect class='cls-2' x='18' y='15' width='18' height='4'/%3e %3crect class='cls-2' x='30' y='20' width='3' height='4'/%3e %3crect class='cls-2' x='33' y='35' width='7' height='4'/%3e %3c/g%3e%3c/svg%3e";

  var img$L = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Generator: Adobe Illustrator 25.1.0%2c SVG Export Plug-In . SVG Version: 6.00 Build 0) --%3e%3csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 320 160' style='enable-background:new 0 0 320 160%3b' xml:space='preserve'%3e%3cstyle type='text/css'%3e .st0%7bfill:white%3b%7d .st1%7bfill:none%3bstroke:black%3b%7d .st2%7bfont-family:'Helvetica'%3b%7d .st3%7bfont-size:10px%3b%7d .st4%7bfont-family:'ArialMT'%3b%7d .st5%7bfill:%23D5EE9F%3b%7d .st6%7bfill:none%3bstroke:%23CCCCCC%3b%7d .st7%7bfill:%239E0142%3b%7d%3c/style%3e%3crect id='background' y='0' class='st0' width='320' height='160'/%3e%3cpath class='st1' d='M10.5%2c146v-5.5h297v5.5'/%3e%3cline class='st1' x1='30.5' y1='140' x2='30.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 19.377 156.1)' class='st2 st3'%3e1950%3c/text%3e%3cline class='st1' x1='69.5' y1='140' x2='69.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 58.377 156.1)' class='st2 st3'%3e1960%3c/text%3e%3cline class='st1' x1='109.5' y1='140' x2='109.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 98.377 156.1)' class='st2 st3'%3e1970%3c/text%3e%3cline class='st1' x1='149.5' y1='140' x2='149.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 138.377 156.1)' class='st2 st3'%3e1980%3c/text%3e%3cline class='st1' x1='188.5' y1='140' x2='188.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 177.377 156.1)' class='st2 st3'%3e1990%3c/text%3e%3cline class='st1' x1='228.5' y1='140' x2='228.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 217.377 156.1)' class='st2 st3'%3e2000%3c/text%3e%3cline class='st1' x1='267.5' y1='140' x2='267.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 256.377 156.1)' class='st2 st3'%3e2010%3c/text%3e%3cline class='st1' x1='307.5' y1='140' x2='307.5' y2='146'/%3e%3ctext transform='matrix(1 0 0 1 296.377 156.1)' class='st2 st3'%3e2020%3c/text%3e%3ctext transform='matrix(1 0 0 1 1.8893 14.1364)' class='st4 st3'%3eA%3c/text%3e%3crect x='79' y='5' class='st5' width='10' height='12.3'/%3e%3cline class='st6' x1='10' y1='5' x2='307' y2='5'/%3e%3ctext transform='matrix(1 0 0 1 1.9083 26.4091)' class='st4 st3'%3eB%3c/text%3e%3crect x='225' y='17.3' class='st7' width='28' height='12.3'/%3e%3cline class='st6' x1='10' y1='17.3' x2='307' y2='17.3'/%3e%3ctext transform='matrix(1 0 0 1 1.3566 38.6818)' class='st4 st3'%3eC%3c/text%3e%3crect x='22' y='29.5' class='st5' width='1' height='12.3'/%3e%3cline class='st6' x1='10' y1='29.5' x2='307' y2='29.5'/%3e%3ctext transform='matrix(1 0 0 1 1.3566 50.9545)' class='st4 st3'%3eD%3c/text%3e%3crect x='170' y='41.8' class='st7' width='27' height='12.3'/%3e%3crect x='103.5' y='41.8' class='st5' width='11' height='12.3'/%3e%3cline class='st6' x1='10' y1='41.8' x2='307' y2='41.8'/%3e%3ctext transform='matrix(1 0 0 1 1.9083 63.2273)' class='st4 st3'%3eE%3c/text%3e%3crect x='253' y='54.1' class='st5' width='34' height='12.3'/%3e%3cline class='st6' x1='10' y1='54.1' x2='307' y2='54.1'/%3e%3ctext transform='matrix(1 0 0 1 2.4698 75.5)' class='st4 st3'%3eF%3c/text%3e%3crect x='51' y='66.4' class='st7' width='28' height='12.3'/%3e%3cline class='st6' x1='10' y1='66.4' x2='307' y2='66.4'/%3e%3ctext transform='matrix(1 0 0 1 0.7999 87.7727)' class='st4 st3'%3eG%3c/text%3e%3crect x='117' y='78.6' class='st7' width='25' height='12.3'/%3e%3crect x='296.4' y='78.6' class='st5' width='10.6' height='12.3'/%3e%3cline class='st6' x1='10' y1='78.6' x2='307' y2='78.6'/%3e%3ctext transform='matrix(1 0 0 1 1.3566 100.0455)' class='st4 st3'%3eH%3c/text%3e%3crect x='89' y='90.9' class='st7' width='28' height='12.3'/%3e%3cline class='st6' x1='10' y1='90.9' x2='307' y2='90.9'/%3e%3ctext transform='matrix(1 0 0 1 5.7999 112.3182)' class='st4 st3'%3eI%3c/text%3e%3crect x='23' y='103.2' class='st7' width='28' height='12.3'/%3e%3cline class='st6' x1='10' y1='103.2' x2='307' y2='103.2'/%3e%3ctext transform='matrix(1 0 0 1 3.3785 124.5909)' class='st4 st3'%3eL%3c/text%3e%3crect x='198' y='115.5' class='st5' width='27' height='12.3'/%3e%3cline class='st6' x1='10' y1='115.5' x2='307' y2='115.5'/%3e%3ctext transform='matrix(1 0 0 1 0.2482 136.8636)' class='st4 st3'%3eM%3c/text%3e%3crect x='143' y='127.7' class='st5' width='27' height='12.3'/%3e%3cline class='st6' x1='10' y1='127.7' x2='307' y2='127.7'/%3e%3c/svg%3e";

  const metadata$o = {
    name: 'Gantt chart',
    thumbnail: img$L,
    icon: img$K,
    categories: ['Series temporelles', 'correlations'],
    description: 'A Gantt chart is a type of bar chart, developed by Henry Gantt in the 1910s, that illustrates a project schedule. Gantt charts illustrate the start and finish dates of the terminal elements and summary elements of a project.',
    code: 'https://github.com/rawgraphs/raw',
    tutorial: 'https://rawgraphs.io/learning/'
  };

  const dimensions$o = [{
    id: 'startDate',
    name: 'Start date',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'endDate',
    name: 'End Date',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'group',
    name: 'Groups',
    validTypes: ['string'],
    required: false
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['string'],
    required: false
  }];

  const mapData$o = {
    startDate: 'get',
    endDate: 'get',
    group: 'get',
    color: 'get'
  };

  function render$o(svgNode, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      sortGroupsBy,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      barPadding,
      colorScale,
      alignLabels
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    if (mapping.startDate.dataType.type != mapping.endDate.dataType.type) {
      throw new Error('startDate and endDate must have the same data type');
    }

    const groups = rollups(data, v => {
      v.sort((a, b) => ascending(a.startDate, b.startDate));
      let levels = [],
          level = 0;
      v.forEach(function (item) {
        let l = 0;

        while (overlap(item, levels[l])) l++;

        if (!levels[l]) levels[l] = [];
        levels[l].push({
          level: l + level,
          ...item
        });
      });
      level++;
      return levels.flat();
    }, d => d.group && d.group.length ? d.group : null);
    groups.sort((a, b) => {
      if (!sortGroupsBy) return;

      if (sortGroupsBy === 'group') {
        return ascending(a[0], b[0]);
      } else {
        return d3[sortGroupsBy](a[1][0].startDate, b[1][0].startDate);
      }
    }); // x scale

    const xMin = min(data, d => d.startDate);
    const xMax = max(data, d => d.endDate);
    const x = mapping.startDate.dataType.type === 'date' ? time() : linear$2();
    x.domain([xMin, xMax]).rangeRound([0, chartWidth]).nice();
    const lines = sum(groups, g => max(g[1], d => d.level + 1));
    const heightScale = band().domain(sequence(lines)).range([0, chartHeight]).paddingInner(barPadding).paddingOuter(barPadding / 2).align(1);
    const lineHeight = heightScale.bandwidth();
    const lineStep = heightScale.step();

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(x));
    };

    select(svgNode).append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background');
    const svg = select(svgNode).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    const axisLayer = svg.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    let stack$1 = stack().keys(groups.map(d => d[0])).value((d, key) => {
      const a = d.filter(f => f[0] === key)[0];
      return max(a[1].map(c => c.level)) + 1;
    });
    const vizLayer = svg.append('g').attr('id', 'viz');
    const groupsG = vizLayer.selectAll('g').data(stack$1([groups])).join('g').attr('id', d => d.key).attr('transform', d => `translate(0,${d[0][0] * lineStep})`);
    groupsG.append('text').attr('x', d => alignLabels ? x(d[0].data[d.index][1][0].startDate) - 4 : -4).attr('y', lineStep / 2).attr('text-anchor', 'end').attr('dominant-baseline', 'middle').text(d => d.key).styles(styles.labelSecondary);
    groupsG.selectAll('rect').data((d, i) => d[0].data[d.index][1]).join('rect').attr('x', d => x(d.startDate)).attr('y', d => lineStep * d.level + (lineStep - lineHeight) / 2).attr('width', d => max([1, x(d.endDate) - x(d.startDate)])).attr('height', lineHeight).attr('fill', d => colorScale(d.color));
    groupsG.append('line').attr('x1', 0).attr('y1', 0).attr('x2', chartWidth).attr('y2', 0).styles(styles.axisLine);

    if (showLegend) {
      const legendLayer = select(svgNode).append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  function overlap(item, g) {
    if (!g) return false;

    for (const i in g) {
      if (item.startDate.getTime() > g[i].startDate.getTime() && item.startDate.getTime() < g[i].endDate.getTime() || item.endDate.getTime() > g[i].startDate.getTime() && item.endDate.getTime() < g[i].endDate.getTime() || item.startDate.getTime() < g[i].startDate.getTime() && item.endDate.getTime() > g[i].endDate.getTime()) {
        return true;
      }
    }

    return false;
  }

  const visualOptions$o = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    sortGroupsBy: {
      type: 'text',
      label: 'Sort groups by',
      group: 'chart',
      options: [{
        label: 'Original',
        value: ''
      }, {
        label: 'Start date (ascending)',
        value: 'ascending'
      }, {
        label: 'Start date (descending)',
        value: 'descending'
      }, {
        label: 'Name',
        value: 'group'
      }],
      default: ''
    },
    barPadding: {
      type: 'number',
      label: 'Padding (%)',
      default: 0,
      group: 'chart',
      step: 0.1,
      min: 0,
      max: 1
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    alignLabels: {
      type: 'boolean',
      label: 'Labels position',
      default: false,
      group: 'labels'
    }
  };

  var ganttChart = {
    metadata: metadata$o,
    dimensions: dimensions$o,
    mapData: mapData$o,
    render: render$o,
    visualOptions: visualOptions$o,
    styles: styles$1
  };

  var img$M = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M25.25%2c11H11v8.57l8.2656-.5908ZM18%2c14a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c18%2c14Z'/%3e %3cpath class='cls-1' d='M23.5752%2c23.667l-4.2188-3.6914L11%2c20.5732V33.5518L19.5889%2c37.62ZM19%2c26a1%2c1%2c0%2c1%2c1%2c1%2c1A1%2c1%2c0%2c0%2c1%2c19%2c26Z'/%3e %3cpath class='cls-1' d='M33.8789%2c30.4365%2c30.0166%2c24H24.52L20.4717%2c38.1689%2c23.79%2c41.292l9.7657-8.2627ZM26%2c29a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c26%2c29Z'/%3e %3cpath class='cls-1' d='M24.3076%2c42.1641%2c24.7275%2c45H45V38.8223L34.1084%2c33.8711ZM37%2c40a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c37%2c40Z'/%3e %3cpath class='cls-1' d='M34.5693%2c32.9824%2c45%2c37.7236V23L34.8662%2c30.6ZM42%2c30a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c42%2c30Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M19.6221%2c38.7422%2c11%2c34.6582V45H23.7168l-.4131-2.793ZM13%2c44a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c13%2c44Z'/%3e %3cpath class='cls-2' d='M24.33%2c23h5.6308l4.4219-11.0527L33.9834%2c11H26.5l-6.2939%2c8.3906ZM26%2c18a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c26%2c18Z'/%3e %3cpath class='cls-2' d='M30.8564%2c23.4551l3.6836%2c6.14L45%2c21.75V20.125l-9.8555-7.3916ZM36%2c22a1%2c1%2c0%2c1%2c1-1%2c1A1%2c1%2c0%2c0%2c1%2c36%2c22Z'/%3e %3cpath class='cls-2' d='M35.0684%2c11l.2627.624L45%2c18.875V11ZM43%2c14a1%2c1%2c0%2c1%2c1%2c1-1A1%2c1%2c0%2c0%2c1%2c43%2c14Z'/%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 8 48 8 9.939 9.195 11.135 9.195 9.695 7.5 8 5.805 9.695 5.805 11.135 7 9.939 7 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3c/g%3e%3c/svg%3e";

  var img$N = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: white%3b %7d .cls-2 %7b fill: %23e0f3a1%3b %7d .cls-3 %7b fill: %2369bda9%3b %7d .cls-4 %7b fill: %23fedd8d%3b %7d .cls-5 %7b fill: %23f0704a%3b %7d .cls-6 %7b fill: %235e4fa2%3b %7d .cls-7 %7b fill: %239e0142%3b %7d .cls-8 %7b fill: none%3b stroke: black%3b %7d .cls-9 %7b isolation: isolate%3b font-size: 10px%3b font-family: Helvetica%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3crect id='background' class='cls-1' width='320' height='160'/%3e %3cg id='visualization'%3e %3cg id='cells'%3e %3cpath class='cls-2' d='M319%2c1V54.4412L267.5993%2c18.1583%2c260.1852%2c1Z'/%3e %3cpath class='cls-3' d='M145.007%2c68.9414l7.4162%2c19.3961L90.7516%2c136.3044%2c81.3991%2c82.74l49.3273-19.731Z'/%3e %3cpath class='cls-2' d='M20%2c144V111.25L79.7192%2c81.39l1.68%2c1.35%2c9.3525%2c53.564L89.2857%2c144Z'/%3e %3cpath class='cls-4' d='M20%2c5.5484l41.8217%2c44.52-.3723%2c5.36L20%2c72.7791Z'/%3e %3cpath class='cls-3' d='M121.6667%2c1l-2.0941%2c43.9749L82.8113%2c27.3294%2c88.49%2c1Z'/%3e %3cpath class='cls-5' d='M285.6471%2c144l1.2734-9.2782L319%2c119.5263V144Z'/%3e %3cpath class='cls-5' d='M130.7264%2c63.0094%2c81.3991%2c82.74l-1.68-1.35-18.27-25.9623.3723-5.36%2c20.99-22.7388%2c36.7613%2c17.6455%2c8.07%2c11.0965Z'/%3e %3cpath class='cls-5' d='M200.2947%2c41.1884%2c251.2%2c1h8.9852l7.4141%2c17.1583-25.0737%2c70.52-17.4634%2c6.5488Z'/%3e %3cpath class='cls-2' d='M89.2857%2c144l1.4659-7.6956%2c61.6716-47.9669%2c46.8611%2c41.5561L198.72%2c144Z'/%3e %3cpath class='cls-6' d='M242.5256%2c88.6779l33.4816%2c7.8472%2c10.9133%2c38.1967L285.6471%2c144H198.72l.5643-14.1064%2c25.7779-34.6669Z'/%3e %3cpath class='cls-6' d='M319%2c74.2019v45.3244l-32.0795%2c15.1955L276.0072%2c96.5251Z'/%3e %3cpath class='cls-5' d='M165.9153%2c1%2c177.82%2c34.4459%2c145.007%2c68.9414l-14.2806-5.932-3.0835-6.938L146%2c1Z'/%3e %3cpath class='cls-3' d='M20%2c72.7791l41.4494-17.351L79.7192%2c81.39%2c20%2c111.25Z'/%3e %3cpath class='cls-6' d='M146%2c1%2c127.6429%2c56.0714l-8.07-11.0965L121.6667%2c1Z'/%3e %3cpath class='cls-4' d='M242.5256%2c88.6779l25.0737-70.52L319%2c54.4412V74.2019L276.0072%2c96.5251Z'/%3e %3cpath class='cls-7' d='M20%2c1H88.49L82.8113%2c27.3294l-20.99%2c22.7388L20%2c5.5484Z'/%3e %3cpath class='cls-4' d='M200.2947%2c41.1884l24.7675%2c54.0383-25.7779%2c34.6669L152.4232%2c88.3375%2c145.007%2c68.9414%2c177.82%2c34.4459Z'/%3e %3cpath class='cls-4' d='M251.2%2c1%2c200.2947%2c41.1884%2c177.82%2c34.4459%2c165.9153%2c1Z'/%3e %3c/g%3e %3cg%3e %3ccircle cx='313' cy='12' r='2'/%3e %3ccircle cx='116' cy='95' r='2'/%3e %3ccircle cx='53' cy='106' r='2'/%3e %3ccircle cx='26' cy='45' r='2'/%3e %3ccircle cx='110' cy='25' r='2'/%3e %3ccircle cx='313' cy='134' r='2'/%3e %3ccircle cx='98' cy='50' r='2'/%3e %3ccircle cx='232' cy='47' r='2'/%3e %3ccircle cx='137' cy='122' r='2'/%3e %3ccircle cx='262' cy='127' r='2'/%3e %3ccircle cx='304' cy='115' r='2'/%3e %3ccircle cx='143' cy='30' r='2'/%3e %3ccircle cx='44' cy='88' r='2'/%3e %3ccircle cx='131' cy='26' r='2'/%3e %3ccircle cx='277' cy='63' r='2'/%3e %3ccircle cx='59' cy='14' r='2'/%3e %3ccircle cx='184' cy='69' r='2'/%3e %3ccircle cx='202' cy='9' r='2'/%3e %3c/g%3e %3cg id='axis'%3e %3cg%3e %3cpath class='cls-8' d='M20.5%2c150v-5.5h299V150'/%3e %3cg%3e %3cline class='cls-8' x1='20.5' y1='144' x2='20.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(17.7192 160.1)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='50.5' y1='144' x2='50.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(44.9385 160.1)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='80.5' y1='144' x2='80.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(74.9385 160.1)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='110.5' y1='144' x2='110.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(104.9385 160.1)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='140.5' y1='144' x2='140.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(134.9385 160.1)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='170.5' y1='144' x2='170.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(164.9385 160.1)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='199.5' y1='144' x2='199.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(193.9385 160.1)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='229.5' y1='144' x2='229.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(223.9385 160.1)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='259.5' y1='144' x2='259.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(253.9385 160.1)'%3e80%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='289.5' y1='144' x2='289.5' y2='150'/%3e %3ctext class='cls-9' transform='translate(283.9385 160.1)'%3e90%3c/text%3e %3c/g%3e %3cline class='cls-8' x1='319.5' y1='144' x2='319.5' y2='150'/%3e %3c/g%3e %3cg%3e %3cpath class='cls-8' d='M14%2c144.5h6.5V1.5H14'/%3e %3cg%3e %3cline class='cls-8' x1='20' y1='144.5' x2='14' y2='144.5'/%3e %3ctext class='cls-9' transform='translate(5.4385 147.7)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='128.5' x2='14' y2='128.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 131.7)'%3e10%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='112.5' x2='14' y2='112.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 115.7)'%3e20%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='96.5' x2='14' y2='96.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 99.7)'%3e30%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='80.5' x2='14' y2='80.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 83.7)'%3e40%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='65.5' x2='14' y2='65.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 68.7)'%3e50%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='49.5' x2='14' y2='49.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 52.7)'%3e60%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='33.5' x2='14' y2='33.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 36.7)'%3e70%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-8' x1='20' y1='17.5' x2='14' y2='17.5'/%3e %3ctext class='cls-9' transform='translate(-0.123 20.7)'%3e80%3c/text%3e %3c/g%3e %3cline class='cls-8' x1='20' y1='1.5' x2='14' y2='1.5'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$p = {
    name: 'Voronoi Diagram',
    id: 'rawgraphs.voronoidiagram',
    thumbnail: img$N,
    icon: img$M,
    categories: ['Dispersions'],
    description: 'It creates the minimum area around each point defined by two variables. When applied to a scatterplot, it is useful to show the distance between points.' // code: 'https://github.com/rawgraphs',
    // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$p = [{
    id: 'x',
    name: 'Axe X',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'Axe Y',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false
  }, {
    id: 'label',
    name: 'Libellé',
    validTypes: ['number', 'date', 'string'],
    required: false,
    multiple: true
  }];

  const mapData$p = {
    x: 'get',
    y: 'get',
    color: 'get',
    label: 'get'
  };

  function render$p(node, data, visualOptions, mapping, originalData, styles) {
    const {
      width,
      height,
      background,
      xOrigin,
      yOrigin,
      showStroke,
      showPoints,
      dotsDiameter,
      showLegend,
      legendWidth,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      colorScale,
      showLabelsOutline,
      autoHideLabels,
      labelStyles
    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom; // select the SVG element

    const svg = select(node);
    svg.append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'background'); // scales
    // x scale

    const xDomain = xOrigin ? [0, max(data, d => d.x)] : extent(data, d => d.x);
    const xScale = mapping.x.dataType.type === 'date' ? time() : linear$2();
    xScale.domain(xDomain).rangeRound([0, chartWidth]).nice(); // y scale

    const yDomain = yOrigin ? [0, max(data, d => d.y)] : extent(data, d => d.y);
    const yScale = mapping.y.dataType.type === 'date' ? time() : linear$2();
    yScale.domain(yDomain).rangeRound([chartHeight, 0]).nice(); // axes

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(xScale)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const yAxis = g => {
      return g.call(axisLeft(yScale)).call(g => g.append('text').attr('x', 4).attr('text-anchor', 'start').attr('dominant-baseline', 'hanging').text(mapping['y'].value).styles(styles.axisLabel));
    };

    const vizLayer = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').attr('id', 'visualization');
    let points = data.map(d => [xScale(d.x), yScale(d.y)]);
    const delaunay = Delaunay.from(points);
    const voronoi = delaunay.voronoi([0, 0, chartWidth, chartHeight]);
    vizLayer.append('g').attr('id', 'cells').attr('stroke', showStroke ? '#ccc' : null).selectAll('path').data(points).join('path').attr('fill', (d, i) => colorScale(data[i].color)).attr('d', (d, i) => voronoi.renderCell(i));

    if (showPoints) {
      vizLayer.append('g').selectAll('cicle').data(data).join('circle').attr('cx', d => xScale(d.x)).attr('cy', d => yScale(d.y)).attr('r', dotsDiameter / 2).attr('fill', 'black');
    }

    const axisLayer = vizLayer.append('g').attr('id', 'axis');
    axisLayer.append('g').call(xAxis);
    axisLayer.append('g').call(yAxis);
    const labelsLayer = vizLayer.append('g').attr('id', 'labels');
    labelsLayer.selectAll('g').data(mapping.label.value ? data : []).join('g').attr('transform', d => `translate(${xScale(d.x)},${yScale(d.y)})`).append('text').attr('x', 0).attr('y', 0).attr('test', d => {
      console.log(d);
    }).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').selectAll('tspan').data(d => Array.isArray(d.label) ? d.label : [d.label]).join('tspan').attr('x', 0).attr('y', 0).attr('dy', (d, i) => i * 12).text((d, i) => {
      if (d && mapping.label.dataType[i].type === 'date') {
        return timeFormat(dateFormats$1[mapping.label.dataType[i].dateFormat])(d);
      } else {
        return d;
      }
    }).styles((d, i) => styles[labelStyles[i]]);
    labelsLayer.selectAll('text').call(sel => {
      return sel.attr('transform', function (d) {
        const height = sel.node().getBBox().height;
        return `translate(0,${showPoints ? -height - dotsDiameter / 2 - 2 : -height / 2})`;
      });
    });

    if (showLabelsOutline) {
      // NOTE: Adobe Illustrator does not support paint-order attr
      labelsLayer.selectAll('text').styles(styles.labelOutline);
    }

    if (autoHideLabels) {
      labelsOcclusion(labelsLayer.selectAll('text'), d => d.size);
    }

    if (showLegend) {
      const legendLayer = svg.append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$p = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 50,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 50,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 50,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 50,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    xOrigin: {
      type: 'boolean',
      label: 'Origine des X à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    yOrigin: {
      type: 'boolean',
      label: 'Origine des Y à 0',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showStroke: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    showPoints: {
      type: 'boolean',
      label: 'Afficher des points sur les valeurs de données ',
      default: false,
      group: 'chart',
      requiredDimensions: ['x', 'y']
    },
    dotsDiameter: {
      type: 'number',
      label: 'Diamètre des points',
      default: 2,
      group: 'chart',
      disabled: {
        showPoints: false
      },
      requiredDimensions: ['x', 'y']
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    },
    labelStyles: {
      type: 'text',
      label: 'Label',
      group: 'labels',
      options: [{
        label: 'Primary',
        value: 'labelPrimary'
      }, {
        label: 'Secondary',
        value: 'labelSecondary'
      }, {
        label: 'Italic',
        value: 'labelItalic'
      }],
      default: 'labelPrimary',
      repeatFor: 'label',
      repeatDefault: ['labelPrimary', 'labelSecondary', 'labelItalic']
    },
    showLabelsOutline: {
      type: 'boolean',
      label: 'Afficher le contour',
      default: false,
      group: 'labels'
    },
    autoHideLabels: {
      type: 'boolean',
      label: 'Cacher automatiquement les labels',
      default: false,
      group: 'labels'
    }
  };

  var voronoidiagram = {
    metadata: metadata$p,
    dimensions: dimensions$p,
    mapData: mapData$p,
    render: render$p,
    visualOptions: visualOptions$p,
    styles: styles$1
  };

  var img$O = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3cpath class='cls-1' d='M48%2c18V12c-4%2c0-4-3-8-3s-4%2c6-8%2c6-4%2c3-8%2c3Z'/%3e %3cpath class='cls-1' d='M11.2476%2c30.78C12.3657%2c25.8057%2c13.4258%2c22%2c16%2c22c2.7388%2c0%2c3.8662%2c3.6631%2c4.9565%2c7.2061.1539.5.3077.999.4649%2c1.4863L21.5206%2c31H32c-4%2c0-4-5-8-5-1.6895%2c0-2.665-2.3207-3.53-5H12.2233C11.1431%2c25.8076%2c10.1485%2c31%2c8%2c31h3.1982Z'/%3e %3cpath class='cls-1' d='M40%2c41c2.0234%2c0%2c3.1045%2c2.0664%2c3.7412%2c3.6211L43.8966%2c45H48c-2.7537%2c0-3.6119-6.1607-5.1843-10h-5.73C35.5755%2c38.5543%2c34.6954%2c44%2c32%2c44c-2.0786%2c0-3.0771-4.59-4.118-9H18.6439c-.6781%2c1.1745-1.496%2c2-2.6439%2c2-4%2c0-4%2c8-8%2c8h9.4893l.2885-.5A23.6038%2c23.6038%2c0%2c0%2c0%2c19.07%2c41.6289C20.126%2c38.99%2c21.3228%2c36%2c24%2c36c2.7861%2c0%2c3.8379%2c4.459%2c4.855%2c8.77l.0541.23h7.09l.1664-.3916C36.8242%2c43.06%2c37.938%2c41%2c40%2c41Z'/%3e %3c/g%3e %3cg id='primary'%3e %3cpath class='cls-2' d='M24%2c37c-2.8521%2c0-3.6713%2c5.082-5.3561%2c8H27.882C26.92%2c40.9232%2c25.9214%2c37%2c24%2c37Z'/%3e %3cpath class='cls-2' d='M40%2c42c-1.3046%2c0-2.1827%2c1.28-2.9139%2c3h5.73C42.1041%2c43.2624%2c41.2463%2c42%2c40%2c42Z'/%3e %3cpath class='cls-2' d='M16%2c23c-1.8515%2c0-2.8458%2c3.8572-3.7767%2c8H20.47C19.2868%2c27.3359%2c18.3105%2c23%2c16%2c23Z'/%3e %3cpolygon class='cls-2' points='46.305 46.805 44.865 46.805 46.061 48 7.5 48 7.5 49 46.061 49 44.865 50.195 46.305 50.195 48 48.5 46.305 46.805'/%3e %3c/g%3e%3c/svg%3e";

  var img$P = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-11 %7b fill: none%3b %7d .cls-2 %7b fill: white%3b %7d .cls-3 %7b clip-path: url(%23clip-path)%3b %7d .cls-4 %7b fill: %2369bda9%3b %7d .cls-4%2c .cls-5 %7b opacity: 0.5%3b %7d .cls-12%2c .cls-4%2c .cls-5 %7b isolation: isolate%3b %7d .cls-5 %7b fill: %239e0142%3b %7d .cls-6 %7b clip-path: url(%23clip-path-2)%3b %7d .cls-7 %7b clip-path: url(%23clip-path-3)%3b %7d .cls-8 %7b clip-path: url(%23clip-path-4)%3b %7d .cls-9 %7b clip-path: url(%23clip-path-5)%3b %7d .cls-10 %7b clip-path: url(%23clip-path-6)%3b %7d .cls-11 %7b stroke: black%3b %7d .cls-12 %7b font-size: 10px%3b font-family: Helvetica%3b %7d %3c/style%3e %3cclipPath id='clip-path'%3e %3crect class='cls-1' x='15' width='304' height='23.0441'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-2'%3e %3crect class='cls-1' x='15' y='23.9912' width='304' height='23.0441'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-3'%3e %3crect class='cls-1' x='15' y='47.9823' width='304' height='23.0441'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-4'%3e %3crect class='cls-1' x='15' y='71.9735' width='304' height='23.0441'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-5'%3e %3crect class='cls-1' x='15' y='95.9647' width='304' height='23.0441'/%3e %3c/clipPath%3e %3cclipPath id='clip-path-6'%3e %3crect class='cls-1' x='15' y='119.9558' width='304' height='23.0441'/%3e %3c/clipPath%3e %3c/defs%3e %3crect id='backgorund' class='cls-2' width='320' height='160'/%3e %3cg id='areas'%3e %3cg class='cls-3'%3e %3cg id='a'%3e %3cg id='positive'%3e %3cpath class='cls-4' d='M15-23.0441C25.1333-10.7495%2c35.2667%2c1.5452%2c45.4%2c6.7235s20.2667%2c3.24%2c30.4%2c2.404%2c20.2667-.5707%2c30.4-1.8546S126.4667%2c3.1553%2c136.6.922%2c156.8667-2.9446%2c167%2c.9006s20.2667%2c13.1687%2c30.4%2c14.8542%2c20.2667-4.2671%2c30.4-4.4754%2c20.2667%2c5.3277%2c30.4%2c2.1973S278.4667-1.45%2c288.6-4.5908%2c308.8667-2.2154%2c319%2c3.3005V23.0441H15Z'/%3e %3cpath class='cls-4' d='M15%2c0C25.1333%2c12.2947%2c35.2667%2c24.5894%2c45.4%2c29.7677s20.2667%2c3.24%2c30.4%2c2.4039%2c20.2667-.5706%2c30.4-1.8546%2c20.2667-4.1175%2c30.4-6.3509S156.8667%2c20.1%2c167%2c23.9448s20.2667%2c13.1687%2c30.4%2c14.8541%2c20.2667-4.2671%2c30.4-4.4754%2c20.2667%2c5.3277%2c30.4%2c2.1973%2c20.2667-14.927%2c30.4-18.0675%2c20.2667%2c2.3755%2c30.4%2c7.8913V46.0883H15Z'/%3e %3c/g%3e %3cg id='negative'%3e %3cpath class='cls-5' d='M15-46.0883C25.1333-33.7936%2c35.2667-21.4989%2c45.4-16.3206s20.2667%2c3.24%2c30.4%2c2.4039%2c20.2667-.5706%2c30.4-1.8546%2c20.2667-4.1175%2c30.4-6.3509%2c20.2667-3.8665%2c30.4-.0213S187.2667-8.9748%2c197.4-7.2894s20.2667-4.2671%2c30.4-4.4754%2c20.2667%2c5.3277%2c30.4%2c2.1973%2c20.2667-14.927%2c30.4-18.0675%2c20.2667%2c2.3755%2c30.4%2c7.8913V0H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg class='cls-6'%3e %3cg id='b'%3e %3cg id='positive-2' data-name='positive'%3e %3cpath class='cls-4' d='M15%2c23.3378C25.1333%2c21.2589%2c35.2667%2c19.18%2c45.4%2c25.593S65.6667%2c46.9106%2c75.8%2c48.8246s20.2667-9.1628%2c30.4-11.6762%2c20.2667%2c3.5367%2c30.4%2c6.4143S156.8667%2c46.1452%2c167%2c40.65s20.2667-16.1922%2c30.4-15.5971%2c20.2667%2c12.4815%2c30.4%2c20.1714%2c20.2667%2c11.1833%2c30.4%2c9.734%2c20.2667-7.8411%2c30.4-14.1531S308.8667%2c28.26%2c319%2c22.0281V47.0353H15Z'/%3e %3cpath class='cls-4' d='M15%2c46.382c10.1333-2.0789%2c20.2667-4.1578%2c30.4%2c2.2551S65.6667%2c69.9548%2c75.8%2c71.8687s20.2667-9.1628%2c30.4-11.6761%2c20.2667%2c3.5367%2c30.4%2c6.4142%2c20.2667%2c2.5826%2c30.4-2.9132%2c20.2667-16.1921%2c30.4-15.5971S217.6667%2c60.578%2c227.8%2c68.268s20.2667%2c11.1832%2c30.4%2c9.734%2c20.2667-7.8411%2c30.4-14.1532S308.8667%2c51.3045%2c319%2c45.0723V70.08H15Z'/%3e %3c/g%3e %3cg id='negative-2' data-name='negative'%3e %3cpath class='cls-5' d='M15%2c.2937C25.1333-1.7852%2c35.2667-3.8641%2c45.4%2c2.5488S65.6667%2c23.8665%2c75.8%2c25.78s20.2667-9.1628%2c30.4-11.6761%2c20.2667%2c3.5367%2c30.4%2c6.4142%2c20.2667%2c2.5826%2c30.4-2.9132S187.2667%2c1.4132%2c197.4%2c2.0082%2c217.6667%2c14.49%2c227.8%2c22.18s20.2667%2c11.1832%2c30.4%2c9.734%2c20.2667-7.8411%2c30.4-14.1532S308.8667%2c5.2162%2c319-1.016V23.9912H15Z'/%3e %3cpath class='cls-5' d='M15-22.75c10.1333-2.0789%2c20.2667-4.1577%2c30.4%2c2.2552S65.6667.8223%2c75.8%2c2.7363%2c96.0667-6.4265%2c106.2-8.94s20.2667%2c3.5367%2c30.4%2c6.4143S156.8667.0569%2c167-5.4388s20.2667-16.1922%2c30.4-15.5971S217.6667-8.5544%2c227.8-.8645s20.2667%2c11.1833%2c30.4%2c9.734%2c20.2667-7.8411%2c30.4-14.1531S308.8667-17.8279%2c319-24.06V.947H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg class='cls-7'%3e %3cg id='c'%3e %3cg id='positive-3' data-name='positive'%3e %3cpath class='cls-4' d='M15%2c38.9249C25.1333%2c56.7657%2c35.2667%2c74.6065%2c45.4%2c78.6433s20.2667-5.73%2c30.4-9.0552%2c20.2667-.2074%2c30.4-4.4695S126.4667%2c49.215%2c136.6%2c48.08s20.2667%2c8.2371%2c30.4%2c9.2625%2c20.2667-6.2956%2c30.4-10.4326%2c20.2667-5.09%2c30.4%2c2.3365S248.0667%2c72.48%2c258.2%2c76.0882s20.2667-4.9824%2c30.4-10.0493%2c20.2667-6.61%2c30.4-8.154V71.0265H15Z'/%3e %3cpath class='cls-4' d='M15%2c61.9691C25.1333%2c79.81%2c35.2667%2c97.6506%2c45.4%2c101.6875s20.2667-5.73%2c30.4-9.0552%2c20.2667-.2075%2c30.4-4.47%2c20.2667-15.9036%2c30.4-17.0384%2c20.2667%2c8.2372%2c30.4%2c9.2626%2c20.2667-6.2956%2c30.4-10.4327%2c20.2667-5.09%2c30.4%2c2.3366%2c20.2667%2c23.2334%2c30.4%2c26.8415S278.4667%2c94.15%2c288.6%2c89.083s20.2667-6.61%2c30.4-8.1539V94.0706H15Z'/%3e %3c/g%3e %3cg id='negative-3' data-name='negative'%3e %3cpath class='cls-5' d='M15%2c15.8808C25.1333%2c33.7216%2c35.2667%2c51.5623%2c45.4%2c55.5992s20.2667-5.73%2c30.4-9.0552%2c20.2667-.2075%2c30.4-4.47%2c20.2667-15.9036%2c30.4-17.0384%2c20.2667%2c8.2372%2c30.4%2c9.2626%2c20.2667-6.2956%2c30.4-10.4327%2c20.2667-5.09%2c30.4%2c2.3366%2c20.2667%2c23.2334%2c30.4%2c26.8415%2c20.2667-4.9823%2c30.4-10.0493%2c20.2667-6.61%2c30.4-8.1539V47.9823H15Z'/%3e %3cpath class='cls-5' d='M15-7.1634C25.1333%2c10.6774%2c35.2667%2c28.5182%2c45.4%2c32.555s20.2667-5.73%2c30.4-9.0552%2c20.2667-.2074%2c30.4-4.4695S126.4667%2c3.1267%2c136.6%2c1.9919s20.2667%2c8.2371%2c30.4%2c9.2625S187.2667%2c4.9588%2c197.4.8218s20.2667-5.09%2c30.4%2c2.3365S248.0667%2c26.3918%2c258.2%2c30s20.2667-4.9824%2c30.4-10.0493%2c20.2667-6.6105%2c30.4-8.154V24.9382H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg class='cls-8'%3e %3cg id='d'%3e %3cg id='positive-4' data-name='positive'%3e %3cpath class='cls-4' d='M15%2c105.0326C25.1333%2c94.9538%2c35.2667%2c84.875%2c45.4%2c80.0953s20.2667-4.26%2c30.4-6.6391%2c20.2667-7.6555%2c30.4-4.022%2c20.2667%2c16.1776%2c30.4%2c22.2983S156.8667%2c97.5506%2c167%2c97.37s20.2667-.2376%2c30.4-1.78a99.8407%2c99.8407%2c0%2c0%2c0%2c30.4-9.7c10.1333-5.1313%2c20.2667-12.3673%2c30.4-11.66s20.2667%2c9.3586%2c30.4%2c7.32S308.8667%2c66.7851%2c319%2c54.0576v40.96H15Z'/%3e %3cpath class='cls-4' d='M15%2c128.0767c10.1333-10.0788%2c20.2667-20.1575%2c30.4-24.9372s20.2667-4.26%2c30.4-6.6392%2c20.2667-7.6555%2c30.4-4.0219%2c20.2667%2c16.1776%2c30.4%2c22.2983%2c20.2667%2c5.818%2c30.4%2c5.6379%2c20.2667-.2377%2c30.4-1.78a99.8409%2c99.8409%2c0%2c0%2c0%2c30.4-9.7c10.1333-5.1313%2c20.2667-12.3672%2c30.4-11.66s20.2667%2c9.3585%2c30.4%2c7.32S308.8667%2c89.8293%2c319%2c77.1018v40.96H15Z'/%3e %3c/g%3e %3cg id='negative-4' data-name='negative'%3e %3cpath class='cls-5' d='M15%2c81.9884C25.1333%2c71.91%2c35.2667%2c61.8309%2c45.4%2c57.0512s20.2667-4.26%2c30.4-6.6391%2c20.2667-7.6556%2c30.4-4.022%2c20.2667%2c16.1776%2c30.4%2c22.2983%2c20.2667%2c5.818%2c30.4%2c5.6379%2c20.2667-.2377%2c30.4-1.78a99.8409%2c99.8409%2c0%2c0%2c0%2c30.4-9.7c10.1333-5.1313%2c20.2667-12.3672%2c30.4-11.66s20.2667%2c9.3585%2c30.4%2c7.32S308.8667%2c43.741%2c319%2c31.0135v40.96H15Z'/%3e %3cpath class='cls-5' d='M15%2c58.9443C25.1333%2c48.8655%2c35.2667%2c38.7867%2c45.4%2c34.007s20.2667-4.26%2c30.4-6.6391%2c20.2667-7.6555%2c30.4-4.0219%2c20.2667%2c16.1775%2c30.4%2c22.2982%2c20.2667%2c5.8181%2c30.4%2c5.638%2c20.2667-.2377%2c30.4-1.78a99.8407%2c99.8407%2c0%2c0%2c0%2c30.4-9.7c10.1333-5.1313%2c20.2667-12.3673%2c30.4-11.66s20.2667%2c9.3586%2c30.4%2c7.32S308.8667%2c20.6969%2c319%2c7.9693v40.96H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg class='cls-9'%3e %3cg id='e'%3e %3cg id='positive-5' data-name='positive'%3e %3cpath class='cls-4' d='M15%2c100.075c10.1333.3285%2c20.2667.6571%2c30.4%2c3.0845s20.2667%2c6.9536%2c30.4%2c8.0448%2c20.2667-1.2526%2c30.4%2c3.015%2c20.2667%2c15.1466%2c30.4%2c13.1642%2c20.2667-16.8262%2c30.4-17.4265%2c20.2667%2c13.0427%2c30.4%2c17.9%2c20.2667.9277%2c30.4-4.7273%2c20.2667-13.0358%2c30.4-10.231%2c20.2667%2c15.7953%2c30.4%2c13.4734%2c20.2667-19.9559%2c30.4-37.59v30.227H15Z'/%3e %3cpath class='cls-4' d='M15%2c123.1191c10.1333.3286%2c20.2667.6571%2c30.4%2c3.0845s20.2667%2c6.9537%2c30.4%2c8.0449%2c20.2667-1.2527%2c30.4%2c3.0149%2c20.2667%2c15.1466%2c30.4%2c13.1642%2c20.2667-16.8261%2c30.4-17.4265%2c20.2667%2c13.0428%2c30.4%2c17.9%2c20.2667.9277%2c30.4-4.7273%2c20.2667-13.0358%2c30.4-10.231%2c20.2667%2c15.7953%2c30.4%2c13.4735%2c20.2667-19.956%2c30.4-37.59v30.227H15Z'/%3e %3c/g%3e %3cg id='negative-5' data-name='negative'%3e %3cpath class='cls-5' d='M15%2c77.0308c10.1333.3286%2c20.2667.6571%2c30.4%2c3.0845S65.6667%2c87.069%2c75.8%2c88.16s20.2667-1.2527%2c30.4%2c3.0149%2c20.2667%2c15.1466%2c30.4%2c13.1642S156.8667%2c87.5132%2c167%2c86.9128s20.2667%2c13.0428%2c30.4%2c17.9%2c20.2667.9277%2c30.4-4.7273%2c20.2667-13.0358%2c30.4-10.231%2c20.2667%2c15.7953%2c30.4%2c13.4735%2c20.2667-19.956%2c30.4-37.59v30.227H15Z'/%3e %3cpath class='cls-5' d='M15%2c53.9867c10.1333.3285%2c20.2667.6571%2c30.4%2c3.0845s20.2667%2c6.9536%2c30.4%2c8.0448%2c20.2667-1.2526%2c30.4%2c3.015%2c20.2667%2c15.1466%2c30.4%2c13.1642S156.8667%2c64.469%2c167%2c63.8687s20.2667%2c13.0427%2c30.4%2c17.9%2c20.2667.9277%2c30.4-4.7273%2c20.2667-13.0358%2c30.4-10.231%2c20.2667%2c15.7953%2c30.4%2c13.4734%2c20.2667-19.9559%2c30.4-37.59v30.227H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg class='cls-10'%3e %3cg id='f'%3e %3cg id='positive-6' data-name='positive'%3e %3cpath class='cls-4' d='M15%2c167.2834c10.1333%2c9.3126%2c20.2667%2c18.6252%2c30.4%2c14.9864s20.2667-20.2291%2c30.4-29.5753%2c20.2667-11.4483%2c30.4-7.6977%2c20.2667%2c13.3537%2c30.4%2c12.28%2c20.2667-12.8235%2c30.4-12.1255%2c20.2667%2c13.8442%2c30.4%2c16.2806%2c20.2667-5.8367%2c30.4-6.8938%2c20.2667%2c5.1019%2c30.4%2c5.0833%2c20.2667-6.2148%2c30.4-7.7862%2c20.2667%2c1.482%2c30.4%2c4.5354V143H15Z'/%3e %3c/g%3e %3cg id='negative-6' data-name='negative'%3e %3cpath class='cls-5' d='M15%2c144.2393c10.1333%2c9.3126%2c20.2667%2c18.6252%2c30.4%2c14.9863S65.6667%2c138.9965%2c75.8%2c129.65s20.2667-11.4482%2c30.4-7.6977%2c20.2667%2c13.3538%2c30.4%2c12.28%2c20.2667-12.8235%2c30.4-12.1254%2c20.2667%2c13.8441%2c30.4%2c16.2806%2c20.2667-5.8367%2c30.4-6.8938%2c20.2667%2c5.1018%2c30.4%2c5.0833%2c20.2667-6.2148%2c30.4-7.7862%2c20.2667%2c1.482%2c30.4%2c4.5354v-13.371H15Z'/%3e %3cpath class='cls-5' d='M15%2c121.1951c10.1333%2c9.3126%2c20.2667%2c18.6252%2c30.4%2c14.9864s20.2667-20.2291%2c30.4-29.5753%2c20.2667-11.4483%2c30.4-7.6977%2c20.2667%2c13.3537%2c30.4%2c12.28S156.8667%2c98.3653%2c167%2c99.0633s20.2667%2c13.8442%2c30.4%2c16.2806%2c20.2667-5.8367%2c30.4-6.8938%2c20.2667%2c5.1019%2c30.4%2c5.0833%2c20.2667-6.2148%2c30.4-7.7862%2c20.2667%2c1.482%2c30.4%2c4.5354V96.9117H15Z'/%3e %3c/g%3e %3c/g%3e %3c/g%3e %3cg id='axis'%3e %3cg%3e %3cpath class='cls-11' d='M15.5.5v143'/%3e %3cg%3e %3cline class='cls-11' x1='15' y1='11.5221' x2='9' y2='11.5221'/%3e %3ctext class='cls-12' transform='translate(0.4385 14.722)'%3ea%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='15' y1='35.5132' x2='9' y2='35.5132'/%3e %3ctext class='cls-12' transform='translate(0.4385 38.7133)'%3eb%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='15' y1='59.5044' x2='9' y2='59.5044'/%3e %3ctext class='cls-12' transform='translate(1 62.7044)'%3ec%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='15' y1='83.4956' x2='9' y2='83.4956'/%3e %3ctext class='cls-12' transform='translate(0.4385 86.6956)'%3ed%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='15' y1='107.4868' x2='9' y2='107.4868'/%3e %3ctext class='cls-12' transform='translate(0.4385 110.6868)'%3ee%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='15' y1='131.4779' x2='9' y2='131.4779'/%3e %3ctext class='cls-12' transform='translate(3.2217 134.6779)'%3ef%3c/text%3e %3c/g%3e %3c/g%3e %3cg%3e %3cpath class='cls-11' d='M15.5%2c143.5h304'/%3e %3cg%3e %3cline class='cls-11' x1='15.5' y1='143' x2='15.5' y2='149'/%3e %3ctext class='cls-12' transform='translate(12.7192 159.1)'%3e0%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='45.9' y1='143' x2='45.9' y2='149'/%3e %3ctext class='cls-12' transform='translate(43.1192 159.1)'%3e1%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='76.3' y1='143' x2='76.3' y2='149'/%3e %3ctext class='cls-12' transform='translate(73.5192 159.1)'%3e2%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='106.7' y1='143' x2='106.7' y2='149'/%3e %3ctext class='cls-12' transform='translate(103.9192 159.1)'%3e3%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='137.1' y1='143' x2='137.1' y2='149'/%3e %3ctext class='cls-12' transform='translate(134.3192 159.1)'%3e4%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='167.5' y1='143' x2='167.5' y2='149'/%3e %3ctext class='cls-12' transform='translate(164.7192 159.1)'%3e5%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='197.9' y1='143' x2='197.9' y2='149'/%3e %3ctext class='cls-12' transform='translate(195.1192 159.1)'%3e6%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='228.3' y1='143' x2='228.3' y2='149'/%3e %3ctext class='cls-12' transform='translate(225.5192 159.1)'%3e7%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='258.7' y1='143' x2='258.7' y2='149'/%3e %3ctext class='cls-12' transform='translate(255.9193 159.1)'%3e8%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='289.1' y1='143' x2='289.1' y2='149'/%3e %3ctext class='cls-12' transform='translate(286.3192 159.1)'%3e9%3c/text%3e %3c/g%3e %3cg%3e %3cline class='cls-11' x1='319.5' y1='143' x2='319.5' y2='149'/%3e %3ctext class='cls-12' transform='translate(307.8159 159.1)'%3e10%3c/text%3e %3c/g%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$q = {
    name: 'Horizon graph',
    id: 'rawgraphs.horizongraph',
    thumbnail: img$P,
    icon: img$O,
    categories: ['Series temporelles', 'correlations'],
    description: 'It displays a quantitative dimension over a continuous interval or time period. Horizon graphs combine position and color to reduce vertical space.' // code: 'https://github.com/rawgraphs',
    // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$q = [{
    id: 'x',
    name: 'x axis',
    validTypes: ['number', 'date'],
    required: true
  }, {
    id: 'y',
    name: 'y axis',
    validTypes: ['number'],
    aggregation: true,
    aggregationDefault: 'sum',
    required: false
  }, {
    id: 'group',
    name: 'Groups',
    validTypes: ['number', 'date', 'string'],
    required: false
  }];

  const mapData$q = function (data, mapping, dataTypes, dimensions) {
    const yAggregator = getDimensionAggregator('y', mapping, dataTypes, dimensions);
    let results = [];
    rollups(data, v => {
      const item = {
        group: v[0][mapping.group.value],
        x: v[0][mapping.x.value],
        y: yAggregator(v.map(d => d[mapping.y.value])),
        color: yAggregator(v.map(d => d[mapping.y.value])) < 0 ? 'negative' : 'positive'
      };
      results.push(item);
    }, d => d[mapping.group.value], // series grouping
    d => d[mapping.x.value] // group functions
    );
    return results;
  };

  function render$q(node, data, visualOptions, mapping, originalData, styles) {
    // destructurate visual visualOptions
    const {
      // default options
      width,
      height,
      background,
      showLegend = false,
      //margins
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart options
      padding,
      interpolation,
      bands,
      negativeStyle,
      // color
      colorScale
    } = visualOptions; // Margin convention

    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    }; // select the SVG element

    const svg = select(node); // nest data

    let nestedData = groups(data, d => d.group);
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const groupsDomain = nestedData.map(d => d[0]);
    const groupsScale = band().range([0, chartHeight]).domain(groupsDomain).paddingOuter(0).paddingInner(padding / (chartWidth / groupsDomain.length)); // x scale

    const xDomain = extent(data, e => e.x);
    const xScale = mapping.x.dataType.type === 'date' ? time() : linear$2();
    xScale.domain(xDomain).range([0, chartWidth]); // y scale

    const yDomain = [0, max([-min(data, e => e.y), max(data, e => e.y)]) / bands];
    const yScale = linear$2().domain(yDomain).range([groupsScale.bandwidth(), 0]); // area function

    let area = area$3().curve(d3[interpolation]).x(d => xScale(d.x)).y0(groupsScale.bandwidth()).y1(d => yScale(d.y)); // create the clip path

    svg.append('clipPath').attr('id', 'groupClipPath').append('rect').attr('x', 0).attr('y', 0).attr('width', chartWidth).attr('height', groupsScale.bandwidth()); // add background

    svg.append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); // append areas

    let viz = svg.append('g').attr('transform', d => 'translate(' + margin.left + ',' + margin.top + ')');
    let horizons = viz.attr('id', 'areas').selectAll('g').data(nestedData).join('g').attr('transform', d => 'translate(0,' + groupsScale(d[0]) + ')').attr('id', d => d[0]).attr('clip-path', 'url(#groupClipPath)'); //draw the positive areas

    horizons.append('g').attr('id', 'positive').selectAll('path') // create an array corresponding to the amount of required bands
    .data(d => [...Array(bands).keys()].map((e, i) => ({
      index: i,
      data: d
    }))).join('path').attr('d', d => area(d.data[1])).attr('fill', colorScale('positive')).attr('opacity', 1 / bands).attr('transform', d => `translate(0, ${groupsScale.bandwidth() * d.index})`); // draw the negative areas

    horizons.append('g').attr('id', 'negative').selectAll('path').data(d => [...Array(bands).keys()].map((e, i) => ({
      index: i,
      data: d
    }))).join('path').attr('d', d => area(d.data[1])).attr('fill', colorScale('negative')).attr('opacity', 1 / bands) // if negative style is "top", just translate it.
    // otherwise, flip it and move to bottm.
    .attr('transform', d => {
      if (negativeStyle == 'top') {
        return `translate(0, ${-groupsScale.bandwidth() - groupsScale.bandwidth() * d.index})`;
      } else if (negativeStyle == 'mirrored') {
        return `scale(1,-1) translate(0, ${-2 * groupsScale.bandwidth() - groupsScale.bandwidth() * d.index})`;
      }
    });

    const yAxis = g => {
      return g.call(axisLeft(groupsScale).tickSizeOuter(0));
    };

    const xAxis = g => {
      return g.attr('transform', `translate(0,${chartHeight})`).call(axisBottom(xScale).tickSizeOuter(0)).call(g => g.append('text').attr('x', chartWidth).attr('dy', -5).attr('text-anchor', 'end').text(mapping['x'].value).styles(styles.axisLabel));
    };

    const axisLayer = viz.append('g').attr('id', 'axis');
    axisLayer.append('g').call(yAxis);
    axisLayer.append('g').call(xAxis);
  }

  const visualOptions$q = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 20,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 20,
      group: 'artboard'
    },
    bands: {
      type: 'number',
      label: 'Number of bands',
      default: 4,
      group: 'chart'
    },
    padding: {
      type: 'number',
      label: 'Padding',
      default: 1,
      group: 'chart'
    },
    interpolation: {
      type: 'text',
      label: 'Type de courbe',
      default: 'curveMonotoneX',
      options: [{
        label: 'Basis',
        value: 'curveBasis'
      }, {
        label: 'Cardinal',
        value: 'curveCardinal'
      }, {
        label: 'Catmull–Rom',
        value: 'curveCatmullRom'
      }, {
        label: 'Linear',
        value: 'curveLinear'
      }, {
        label: 'Monotone X',
        value: 'curveMonotoneX'
      }, {
        label: 'Natural',
        value: 'curveNatural'
      }, {
        label: 'Step',
        value: 'curveStep'
      }, {
        label: 'Step After',
        value: 'curveStepAfter'
      }, {
        label: 'Step Before',
        value: 'curveStepBefore'
      }],
      group: 'chart'
    },
    negativeStyle: {
      type: 'text',
      label: 'Show negative values as',
      group: 'chart',
      options: [{
        label: 'Mirrored',
        value: 'mirrored'
      }, {
        label: 'Offset',
        value: 'top'
      }],
      default: 'mirrored'
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var horizongraph = {
    metadata: metadata$q,
    dimensions: dimensions$q,
    mapData: mapData$q,
    render: render$q,
    visualOptions: visualOptions$q,
    styles: styles$1
  };

  var img$Q = "data:image/svg+xml,%3csvg id='rawgraphs-icons' xmlns='http://www.w3.org/2000/svg' width='56' height='56' viewBox='0 0 56 56'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %2395e5c0%3b %7d .cls-2 %7b fill: %2306c26c%3b %7d %3c/style%3e %3c/defs%3e %3cg id='secundary'%3e %3crect class='cls-1' x='8' y='8' width='1' height='40'/%3e %3crect class='cls-1' x='47' y='8' width='1' height='40'/%3e %3crect class='cls-1' x='21' y='8' width='1' height='40'/%3e %3crect class='cls-1' x='34' y='8' width='1' height='40'/%3e %3c/g%3e %3cg id='primary'%3e %3cpolygon class='cls-2' points='34.34 30.518 21.356 17.91 8.148 21.497 7.886 20.532 21.644 16.796 34.66 29.435 47.894 26.822 48.087 27.803 34.34 30.518'/%3e %3cpolygon class='cls-2' points='8.567 42.77 7.796 42.132 21.115 26.021 34.419 14.916 48.161 21.059 47.752 21.972 34.581 16.084 21.82 26.723 8.567 42.77'/%3e %3cpolygon class='cls-2' points='8.2 45.594 7.86 44.654 21.455 39.732 34.585 42.007 48.064 43.886 47.926 44.876 34.431 42.995 21.545 40.762 8.2 45.594'/%3e %3c/g%3e%3c/svg%3e";

  var img$R = "data:image/svg+xml,%3csvg id='Layer_1' data-name='Layer 1' xmlns='http://www.w3.org/2000/svg' width='320' height='160' viewBox='0 0 320 160'%3e %3cdefs%3e %3cstyle%3e .cls-1%2c .cls-2%2c .cls-3%2c .cls-4%2c .cls-5%2c .cls-6%2c .cls-7 %7b fill: none%3b %7d .cls-1 %7b stroke: %235e4fa2%3b %7d .cls-1%2c .cls-2%2c .cls-3%2c .cls-4%2c .cls-5%2c .cls-6 %7b stroke-miterlimit: 10%3b stroke-width: 0.5px%3b %7d .cls-2 %7b stroke: %239e0142%3b %7d .cls-3 %7b stroke: %2369bda9%3b %7d .cls-4 %7b stroke: %23e0f3a1%3b %7d .cls-5 %7b stroke: %23fedd8d%3b %7d .cls-6 %7b stroke: %23f0704a%3b %7d .cls-7 %7b stroke: black%3b %7d .cls-8 %7b isolation: isolate%3b font-size: 12.0609px%3b font-family: ArialMT%2c Arial%3b %7d %3c/style%3e %3c/defs%3e %3cg%3e %3cpath class='cls-1' d='M28.65%2c150.6186l96.5822-60.3047%2c96.5822%2c57.8516%2c96.5821%2c2.4531'/%3e %3cpath class='cls-1' d='M28.65%2c146.5983l96.5822-50.2539%2c96.5822%2c44.4619%2c96.5821%2c3.7818'/%3e %3cpath class='cls-1' d='M28.65%2c146.5983l96.5822-56.2844%2c96.5822%2c52.9455%2c96.5821%2c1.3287'/%3e %3cpath class='cls-1' d='M28.65%2c146.5983l96.5822-68.3454%2c96.5822%2c65.0065%2c96.5821%2c1.3287'/%3e %3cpath class='cls-1' d='M28.65%2c142.578l96.5822-10.0508%2c96.5822%2c10.7322%2c96.5821-4.7018'/%3e %3cpath class='cls-1' d='M28.65%2c138.5576l96.5822-54.2742%2c96.5822%2c54.07%2c96.5821%2c6.2349'/%3e %3cpath class='cls-1' d='M28.65%2c138.5576%2c125.2325%2c66.192l96.5822%2c74.6143%2c96.5821-2.2487'/%3e %3cpath class='cls-2' d='M28.65%2c138.5576l96.5822-84.4265%2c96.5822%2c96.4875%2c96.5821-6.03'/%3e %3cpath class='cls-1' d='M28.65%2c138.5576l96.5822-60.3047%2c96.5822%2c62.5534%2c96.5821%2c3.7818'/%3e %3cpath class='cls-1' d='M28.65%2c134.5373l96.5822-56.2844%2c96.5822%2c65.0065%2c96.5821%2c1.3287'/%3e %3cpath class='cls-1' d='M28.65%2c134.5373l96.5822-56.2844L221.8147%2c135.9l96.5821%2c8.688'/%3e %3cpath class='cls-2' d='M28.65%2c130.517l96.5822-64.325L221.8147%2c135.9l96.5821%2c8.688'/%3e %3cpath class='cls-1' d='M28.65%2c130.517l96.5822-40.2031%2c96.5822%2c50.4924%2c96.5821%2c9.8123'/%3e %3cpath class='cls-2' d='M28.65%2c130.517l96.5822-64.325%2c96.5822%2c62.3489%2c96.5821%2c16.0472'/%3e %3cpath class='cls-2' d='M28.65%2c130.517l96.5822-46.2336L221.8147%2c135.9l96.5821%2c8.688'/%3e %3cpath class='cls-1' d='M28.65%2c130.517l96.5822-40.2031%2c96.5822%2c50.4924%2c96.5821-2.2487'/%3e %3cpath class='cls-2' d='M28.65%2c126.4967l96.5822-36.1828%2c96.5822%2c50.4924%2c96.5821%2c3.7818'/%3e %3cpath class='cls-2' d='M28.65%2c126.4967l96.5822-42.2133%2c96.5822%2c54.07%2c96.5821%2c12.2654'/%3e %3cpath class='cls-2' d='M28.65%2c126.4967l96.5822-42.2133%2c96.5822%2c54.07%2c96.5821%2c12.2654'/%3e %3cpath class='cls-2' d='M28.65%2c126.4967l96.5822-42.2133%2c96.5822%2c54.07%2c96.5821%2c12.2654'/%3e %3cpath class='cls-1' d='M28.65%2c126.4967h96.5822l96.5822-32.2988%2c96.5821%2c2.1465'/%3e %3cpath class='cls-1' d='M28.65%2c126.4967l96.5822-6.0305L221.8147%2c64.761l96.5821-10.63'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-68.3453%2c96.5822%2c86.6752%2c96.5821%2c3.7818'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764%2c125.2325%2c66.192l96.5822%2c72.1612%2c96.5821%2c6.2349'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-32.1625L221.8147%2c135.9l96.5821%2c8.688'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764%2c125.2325%2c66.192%2c221.8147%2c135.9l96.5821-3.3729'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-44.2235%2c96.5822%2c67.46%2c96.5821-1.1243'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-62.3149%2c96.5822%2c83.0979%2c96.5821-4.7018'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-62.3149L221.8147%2c135.9l96.5821-15.4339'/%3e %3cpath class='cls-2' d='M28.65%2c122.4764l96.5822-50.2539%2c96.5822%2c68.5838%2c96.5821%2c3.7818'/%3e %3cpath class='cls-1' d='M28.65%2c122.4764l96.5822%2c28.1422%2c96.5822-61.3268%2c96.5821%2c7.0526'/%3e %3cpath class='cls-1' d='M28.65%2c122.4764l96.5822%2c10.0508%2c96.5822-38.3293%2c96.5821%2c2.1465'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561l96.5822-58.2946%2c96.5822%2c80.6448%2c96.5821%2c3.7818'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561l96.5822-58.2946%2c96.5822%2c80.6448%2c96.5821-2.2487'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561%2c125.2325%2c42.07l96.5822%2c96.2831%2c96.5821.2044'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561l96.5822-70.3555%2c96.5822%2c90.2526%2c96.5821-5.826'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561l96.5822-46.2336%2c96.5822%2c61.2246%2c96.5821-6.95'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561%2c125.2325%2c66.192l96.5822%2c72.1612%2c96.5821%2c6.2349'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561%2c125.2325%2c42.07l96.5822%2c86.4708%2c96.5821%2c3.9863'/%3e %3cpath class='cls-2' d='M28.65%2c118.4561%2c125.2325%2c42.07l96.5822%2c93.83%2c96.5821%2c8.688'/%3e %3cpath class='cls-1' d='M28.65%2c118.4561l96.5822%2c2.01%2c96.5822-18.9091%2c96.5821-11.2432'/%3e %3cpath class='cls-2' d='M28.65%2c114.4358l96.5822-54.2743%2c96.5822%2c78.1917%2c96.5821%2c6.2349'/%3e %3cpath class='cls-2' d='M28.65%2c114.4358%2c125.2325%2c66.192l96.5822%2c74.6143%2c96.5821%2c3.7818'/%3e %3cpath class='cls-2' d='M28.65%2c114.4358l96.5822-90.4571%2c96.5822%2c114.3745%2c96.5821%2c12.2654'/%3e %3cpath class='cls-3' d='M28.65%2c114.4358l96.5822-6.0305L221.8147%2c79.48l96.5821-7.257'/%3e %3cpath class='cls-2' d='M28.65%2c110.4154l96.5822-62.3148%2c96.5822%2c90.2526%2c96.5821%2c6.2349'/%3e %3cpath class='cls-2' d='M28.65%2c106.3951%2c125.2325%2c36.04l96.5822%2c97.4074%2c96.5821-.92'/%3e %3cpath class='cls-2' d='M28.65%2c106.3951l96.5822-58.2945%2c96.5822%2c90.2526%2c96.5821%2c6.2349'/%3e %3cpath class='cls-2' d='M28.65%2c106.3951%2c125.2325%2c36.04l96.5822%2c107.22%2c96.5821-10.7322'/%3e %3cpath class='cls-2' d='M28.65%2c106.3951%2c125.2325%2c66.192l96.5822%2c67.2551%2c96.5821%2c11.141'/%3e %3cpath class='cls-2' d='M28.65%2c106.3951%2c125.2325%2c66.192l96.5822%2c72.1612%2c96.5821-5.826'/%3e %3cpath class='cls-3' d='M28.65%2c106.3951l96.5822-16.0812L221.8147%2c64.761l96.5821%2c1.431'/%3e %3cpath class='cls-2' d='M28.65%2c102.3748l96.5822-84.4266%2c96.5822%2c122.8581%2c96.5821%2c3.7818'/%3e %3cpath class='cls-2' d='M28.65%2c102.3748l96.5822-42.2133%2c96.5822%2c83.0979%2c96.5821%2c1.3287'/%3e %3cpath class='cls-3' d='M28.65%2c102.3748l96.5822%2c30.1524%2c96.5822-55.5008%2c96.5821%2c1.2265'/%3e %3cpath class='cls-3' d='M28.65%2c102.3748l96.5822%2c24.1219%2c96.5822-44.5642%2c96.5821%2c8.3814'/%3e %3cpath class='cls-1' d='M28.65%2c102.3748l96.5822%2c24.1219%2c96.5822-42.1111%2c96.5821%2c11.9588'/%3e %3cpath class='cls-3' d='M28.65%2c102.3748l96.5822%2c18.0914%2c96.5822-43.44%2c96.5821%2c1.2265'/%3e %3cpath class='cls-3' d='M28.65%2c102.3748l96.5822%2c12.061%2c96.5822-47.2217%2c96.5821%2c17.0693'/%3e %3cpath class='cls-3' d='M28.65%2c98.3545l96.5822-2.01%2c96.5822-9.5057%2c96.5821-8.5858'/%3e %3cpath class='cls-3' d='M28.65%2c98.3545l96.5822-8.0406L221.8147%2c64.761l96.5821%2c1.431'/%3e %3cpath class='cls-3' d='M28.65%2c98.3545l96.5822%2c22.1117L221.8147%2c79.48l96.5821%2c10.8344'/%3e %3cpath class='cls-3' d='M28.65%2c98.3545l96.5822-8.0406%2c96.5822-15.7406%2c96.5821%2c3.68'/%3e %3cpath class='cls-3' d='M28.65%2c98.3545l96.5822%2c10.0508L221.8147%2c72.12l96.5821%2c6.1326'/%3e %3cpath class='cls-4' d='M28.65%2c98.3545l96.5822%2c4.02%2c96.5822-47.426L318.3968%2c36.04'/%3e %3cpath class='cls-2' d='M28.65%2c94.3342%2c125.2325%2c5.8873l96.5822%2c132.4659%2c96.5821-5.826'/%3e %3cpath class='cls-2' d='M28.65%2c94.3342%2c125.2325%2c42.07l96.5822%2c91.377%2c96.5821%2c5.1105'/%3e %3cpath class='cls-3' d='M28.65%2c94.3342l96.5822%2c8.0406L221.8147%2c64.761l96.5821%2c13.4919'/%3e %3cpath class='cls-1' d='M28.65%2c94.3342l96.5822%2c20.1016%2c96.5822-25.144%2c96.5821%2c7.0526'/%3e %3cpath class='cls-3' d='M28.65%2c94.3342l96.5822-4.02L221.8147%2c72.12l96.5821%2c12.1631'/%3e %3cpath class='cls-3' d='M28.65%2c94.3342l96.5822%2c2.01L221.8147%2c72.12l96.5821%2c6.1326'/%3e %3cpath class='cls-3' d='M28.65%2c94.3342l96.5822%2c8.0406%2c96.5822-27.8015%2c96.5821%2c3.68'/%3e %3cpath class='cls-4' d='M28.65%2c94.3342l96.5822%2c26.132%2c96.5822-67.97L318.3968%2c36.04'/%3e %3cpath class='cls-2' d='M28.65%2c90.3139l96.5822-60.3047%2c96.5822%2c115.7032%2c96.5821-1.1243'/%3e %3cpath class='cls-3' d='M28.65%2c90.3139l96.5822%2c18.0914%2c96.5822-33.832%2c96.5821%2c21.7711'/%3e %3cpath class='cls-3' d='M28.65%2c90.3139l96.5822%2c18.0914L221.8147%2c79.48l96.5821%2c4.8039'/%3e %3cpath class='cls-3' d='M28.65%2c90.3139l96.5822%2c24.1219%2c96.5822-37.4094%2c96.5821%2c7.257'/%3e %3cpath class='cls-4' d='M28.65%2c90.3139l96.5822%2c18.0914%2c96.5822-58.3627L318.3968%2c42.07'/%3e %3cpath class='cls-5' d='M28.65%2c90.3139l96.5822%2c12.0609%2c96.5822-52.3322%2c96.5821-38.1248'/%3e %3cpath class='cls-4' d='M28.65%2c90.3139l96.5822%2c18.0914%2c96.5822-58.3627L318.3968%2c42.07'/%3e %3cpath class='cls-3' d='M28.65%2c86.2936l96.5822%2c4.02L221.8147%2c72.12l96.5821-5.9283'/%3e %3cpath class='cls-4' d='M28.65%2c86.2936l96.5822-8.0407%2c96.5822-20.8511%2c96.5821-9.3012'/%3e %3cpath class='cls-4' d='M28.65%2c86.2936l96.5822%2c4.02%2c96.5822-40.2713%2c96.5821-1.942'/%3e %3cpath class='cls-3' d='M28.65%2c82.2733l96.5822%2c56.2843%2c96.5822-61.5312%2c96.5821%2c19.318'/%3e %3cpath class='cls-3' d='M28.65%2c82.2733l96.5822%2c14.0711L221.8147%2c64.761l96.5821%2c1.431'/%3e %3cpath class='cls-4' d='M28.65%2c82.2733l96.5822%2c26.132%2c96.5822-58.3627%2c96.5821%2c10.1189'/%3e %3cpath class='cls-3' d='M28.65%2c82.2733%2c125.2325%2c66.192l96.5822-1.431%2c96.5821-4.5995'/%3e %3cpath class='cls-4' d='M28.65%2c82.2733l96.5822%2c56.2843%2c96.5822-86.0619L318.3968%2c66.192'/%3e %3cpath class='cls-4' d='M28.65%2c82.2733l96.5822%2c8.0406%2c96.5822-32.9121%2c96.5821-9.3012'/%3e %3cpath class='cls-3' d='M28.65%2c78.2529l96.5822%2c18.0915%2c96.5822-36.4895%2c96.5821%2c12.3676'/%3e %3cpath class='cls-3' d='M28.65%2c78.2529l96.5822%2c24.1219%2c96.5822-25.3484%2c96.5821%2c1.2265'/%3e %3cpath class='cls-3' d='M28.65%2c78.2529l96.5822%2c24.1219%2c96.5822-42.52%2c96.5821%2c24.4285'/%3e %3cpath class='cls-3' d='M28.65%2c78.2529l96.5822%2c12.061L221.8147%2c62.308l96.5821%2c9.9145'/%3e %3cpath class='cls-4' d='M28.65%2c78.2529l96.5822%2c12.061%2c96.5822-35.3651%2c96.5821-6.8482'/%3e %3cpath class='cls-4' d='M28.65%2c78.2529l96.5822%2c36.1829%2c96.5822-76.6586%2c96.5821%2c34.4453'/%3e %3cpath class='cls-3' d='M28.65%2c74.2326l96.5822%2c64.325L221.8147%2c64.761l96.5821%2c1.431'/%3e %3cpath class='cls-3' d='M28.65%2c74.2326l96.5822%2c22.1118%2c96.5822-26.6772%2c96.5821%2c8.5857'/%3e %3cpath class='cls-4' d='M28.65%2c74.2326l96.5822%2c28.1422%2c96.5822-44.973%2c96.5821-9.3012'/%3e %3cpath class='cls-5' d='M28.65%2c74.2326l96.5822-8.0406%2c96.5822-23.5086%2c96.5821-24.7352'/%3e %3cpath class='cls-3' d='M28.65%2c70.2123l96.5822%2c2.01%2c96.5822-12.3676%2c96.5821.3066'/%3e %3cpath class='cls-3' d='M28.65%2c70.2123l96.5822%2c50.2539%2c96.5822-65.5174L318.3968%2c66.192'/%3e %3cpath class='cls-3' d='M28.65%2c70.2123l96.5822%2c62.3149%2c96.5822-65.3131%2c96.5821%2c11.0388'/%3e %3cpath class='cls-6' d='M28.65%2c70.2123l96.5822%2c2.01L221.8147%2c27.965%2c318.3968%2c5.8873'/%3e %3cpath class='cls-4' d='M28.65%2c70.2123l96.5822%2c26.1321%2c96.5822-58.5672%2c96.5821%2c10.3234'/%3e %3cpath class='cls-4' d='M28.65%2c70.2123l96.5822%2c38.193%2c96.5822-53.4565%2c96.5821-6.8482'/%3e %3cpath class='cls-4' d='M28.65%2c70.2123l96.5822%2c32.1625%2c96.5822-52.3322L318.3968%2c66.192'/%3e %3cpath class='cls-5' d='M28.65%2c70.2123l96.5822-4.02%2c96.5822-28.4148%2c96.5821-25.8594'/%3e %3cpath class='cls-4' d='M28.65%2c70.2123l96.5822%2c50.2539%2c96.5822-67.97L318.3968%2c42.07'/%3e %3cpath class='cls-3' d='M28.65%2c66.192l96.5822%2c12.0609L221.8147%2c64.761l96.5821%2c1.431'/%3e %3cpath class='cls-3' d='M28.65%2c66.192l96.5822%2c30.1524%2c96.5822-26.6772%2c96.5821%2c8.5857'/%3e %3cpath class='cls-4' d='M28.65%2c66.192l96.5822%2c42.2133%2c96.5822-63.2688L318.3968%2c42.07'/%3e %3cpath class='cls-5' d='M28.65%2c66.192l96.5822%2c12.0609%2c96.5822-33.1164%2c96.5821-27.1883'/%3e %3cpath class='cls-5' d='M28.65%2c66.192l96.5822%2c36.1828%2c96.5822-64.5976%2c96.5821-7.768'/%3e %3cpath class='cls-5' d='M28.65%2c66.192l96.5822%2c36.1828%2c96.5822-64.5976%2c96.5821-13.7985'/%3e %3cpath class='cls-4' d='M28.65%2c66.192l96.5822%2c18.0914L221.8147%2c40.23l96.5821%2c7.87'/%3e %3cpath class='cls-3' d='M28.65%2c62.1717l96.5822%2c40.2031L221.8147%2c62.308l96.5821%2c3.884'/%3e %3cpath class='cls-5' d='M28.65%2c62.1717l96.5822%2c28.1422%2c96.5822-57.4428%2c96.5821-8.8924'/%3e %3cpath class='cls-4' d='M28.65%2c62.1717l96.5822%2c16.0812%2c96.5822-28.21L318.3968%2c36.04'/%3e %3cpath class='cls-4' d='M28.65%2c62.1717l96.5822%2c28.1422L221.8147%2c40.23l96.5821%2c7.87'/%3e %3cpath class='cls-4' d='M28.65%2c62.1717l96.5822%2c28.1422L221.8147%2c47.59l96.5821-11.55'/%3e %3cpath class='cls-3' d='M28.65%2c58.1514l96.5822%2c38.193L221.8147%2c62.308l96.5821%2c15.9449'/%3e %3cpath class='cls-3' d='M28.65%2c58.1514l96.5822%2c32.1625%2c96.5822-23.1%2c96.5821%2c5.0084'/%3e %3cpath class='cls-3' d='M28.65%2c54.1311l96.5822%2c30.1523%2c96.5822-17.0693%2c96.5821%2c5.0084'/%3e %3cpath class='cls-4' d='M28.65%2c54.1311l96.5822%2c36.1828%2c96.5822-37.8182%2c96.5821%2c1.6354'/%3e %3cpath class='cls-3' d='M28.65%2c54.1311l96.5822%2c30.1523%2c96.5822-24.4285%2c96.5821%2c6.3371'/%3e %3cpath class='cls-5' d='M28.65%2c54.1311l96.5822%2c66.3351%2c96.5822-87.5951%2c96.5821%2c15.23'/%3e %3cpath class='cls-5' d='M28.65%2c54.1311l96.5822%2c18.0914%2c96.5822-36.8983%2c96.5821-5.315'/%3e %3cpath class='cls-5' d='M28.65%2c54.1311l96.5822%2c30.1523%2c96.5822-46.5062%2c96.5821-25.8594'/%3e %3cpath class='cls-6' d='M28.65%2c54.1311l96.5822%2c18.0914%2c96.5822-36.8983L318.3968%2c5.8873'/%3e %3cpath class='cls-5' d='M28.65%2c54.1311l96.5822%2c36.1828L221.8147%2c47.59l96.5821-29.6413'/%3e %3cpath class='cls-3' d='M28.65%2c50.1107l96.5822%2c52.2641%2c96.5822-44.973%2c96.5821%2c14.8207'/%3e %3cpath class='cls-5' d='M28.65%2c50.1107l96.5822%2c40.2032L221.8147%2c40.23l96.5821-10.2211'/%3e %3cpath class='cls-6' d='M28.65%2c50.1107l96.5822%2c28.1422L221.8147%2c30.418l96.5821-12.47'/%3e %3cpath class='cls-3' d='M28.65%2c46.09l96.5822%2c38.193%2c96.5822-29.3346L318.3968%2c66.192'/%3e %3cpath class='cls-5' d='M28.65%2c46.09l96.5822%2c32.1625%2c96.5822-42.9287%2c96.5821-17.376'/%3e %3cpath class='cls-5' d='M28.65%2c46.09l96.5822%2c38.193%2c96.5822-41.6%2c96.5821-12.6742'/%3e %3cpath class='cls-5' d='M28.65%2c46.09l96.5822%2c38.193%2c96.5822-34.2408%2c96.5821-32.0944'/%3e %3cpath class='cls-3' d='M28.65%2c42.07l96.5822%2c36.1828%2c96.5822-18.398%2c96.5821%2c12.3676'/%3e %3cpath class='cls-5' d='M28.65%2c38.05l96.5822%2c52.2641L221.8147%2c30.418l96.5821-.4088'/%3e %3cpath class='cls-6' d='M28.65%2c34.03l96.5822%2c20.1016%2c96.5822-28.6192L318.3968%2c5.8873'/%3e %3cpath class='cls-5' d='M28.65%2c34.03l96.5822%2c44.2234L221.8147%2c27.965l96.5821%2c20.1356'/%3e %3cpath class='cls-4' d='M28.65%2c34.03l96.5822%2c56.2844%2c96.5822-57.4428%2c96.5821%2c27.29'/%3e %3cpath class='cls-5' d='M28.65%2c30.0092l96.5822%2c66.3352%2c96.5822-75.7387%2c96.5821%2c27.4949'/%3e %3cpath class='cls-5' d='M28.65%2c25.9889l96.5822%2c76.3859%2c96.5822-76.8629L318.3968%2c42.07'/%3e %3cpath class='cls-6' d='M28.65%2c17.9482l96.5822%2c72.3657%2c96.5822-77.0674%2c96.5821%2c16.7627'/%3e %3cpath class='cls-6' d='M28.65%2c13.9279%2c125.2325%2c42.07l96.5822-31.2767%2c96.5821%2c13.1853'/%3e %3cpath class='cls-6' d='M28.65%2c13.9279l96.5822%2c100.5079L221.8147%2c5.8873l96.5821%2c12.0609'/%3e %3cpath class='cls-6' d='M28.65%2c13.9279l96.5822%2c88.4469%2c96.5822-91.5814L318.3968%2c36.04'/%3e %3cpath class='cls-6' d='M28.65%2c13.9279l96.5822%2c76.386%2c96.5822-64.802%2c96.5821-7.5637'/%3e %3cpath class='cls-6' d='M28.65%2c5.8873%2c125.2325%2c42.07l96.5822-23.9174L318.3968%2c36.04'/%3e %3cg%3e %3cpath class='cls-7' d='M21.4066%2c151.2216H29.254V6.49H21.4066'/%3e %3cline class='cls-7' x1='28.6503' y1='123.0794' x2='21.4066' y2='123.0794'/%3e %3cline class='cls-7' x1='28.6503' y1='82.8763' x2='21.4066' y2='82.8763'/%3e %3cline class='cls-7' x1='28.6503' y1='42.6732' x2='21.4066' y2='42.6732'/%3e %3cpath class='cls-7' d='M117.9888%2c151.2216h7.8473V6.49'/%3e %3cline class='cls-7' x1='125.2325' y1='151.2216' x2='117.9888' y2='151.2216'/%3e %3cline class='cls-7' x1='125.2325' y1='90.9169' x2='117.9888' y2='90.9169'/%3e %3cline class='cls-7' x1='125.2325' y1='30.6122' x2='117.9888' y2='30.6122'/%3e %3cline class='cls-7' x1='125.2325' y1='60.7646' x2='117.9888' y2='60.7646'/%3e %3cline class='cls-7' x1='125.8361' y1='6.4903' x2='118.5925' y2='6.4903'/%3e %3cline class='cls-7' x1='125.2325' y1='121.0693' x2='117.9888' y2='121.0693'/%3e %3cpath class='cls-7' d='M214.571%2c151.2216h7.8473V6.49H214.571'/%3e %3cline class='cls-7' x1='221.8147' y1='151.2216' x2='214.571' y2='151.2216'/%3e %3cline class='cls-7' x1='221.8147' y1='126.6909' x2='214.571' y2='126.6909'/%3e %3cline class='cls-7' x1='221.8147' y1='102.1602' x2='214.571' y2='102.1602'/%3e %3cline class='cls-7' x1='221.8147' y1='77.6295' x2='214.571' y2='77.6295'/%3e %3cline class='cls-7' x1='221.8147' y1='53.0987' x2='214.571' y2='53.0987'/%3e %3cline class='cls-7' x1='221.8147' y1='28.568' x2='214.571' y2='28.568'/%3e %3cpath class='cls-7' d='M311.1532%2c151.2216h7.8473V6.49h-7.8473'/%3e %3cline class='cls-7' x1='318.3968' y1='133.1302' x2='311.1532' y2='133.1302'/%3e %3cline class='cls-7' x1='318.3968' y1='109.0083' x2='311.1532' y2='109.0083'/%3e %3cline class='cls-7' x1='318.3968' y1='84.8865' x2='311.1532' y2='84.8865'/%3e %3cline class='cls-7' x1='318.3968' y1='60.7646' x2='311.1532' y2='60.7646'/%3e %3cline class='cls-7' x1='318.3968' y1='36.6427' x2='311.1532' y2='36.6427'/%3e %3cline class='cls-7' x1='318.3968' y1='12.5208' x2='311.1532' y2='12.5208'/%3e %3c/g%3e %3cg%3e %3ctext class='cls-8' transform='translate(12.2871 126.9392)'%3e5%3c/text%3e %3ctext class='cls-8' transform='translate(12.2871 86.7351)'%3e6%3c/text%3e %3ctext class='cls-8' transform='translate(12.2866 46.5327)'%3e6%3c/text%3e %3ctext class='cls-8' transform='translate(12.2861 10.3498)'%3e7%3c/text%3e %3ctext class='cls-8' transform='translate(108.8701 155.0818)'%3e2%3c/text%3e %3ctext class='cls-8' transform='translate(108.8701 94.7771)'%3e3%3c/text%3e %3ctext class='cls-8' transform='translate(108.8701 34.4724)'%3e4%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 155.0818)'%3e1%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 130.5515)'%3e2%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 106.0193)'%3e3%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 81.489)'%3e4%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 56.9587)'%3e5%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 32.4272)'%3e5%3c/text%3e %3ctext class='cls-8' transform='translate(205.4512 10.3498)'%3e6%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 136.989)'%3e0.4%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 112.8679)'%3e0.8%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 88.7458)'%3e1.2%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 64.6242)'%3e1.6%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 40.5027)'%3e2.0%3c/text%3e %3ctext class='cls-8' transform='translate(291.9648 16.3811)'%3e2.4%3c/text%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

  const metadata$r = {
    name: 'Parallel coordinates',
    id: 'rawgraphs.parallelcoordinates',
    thumbnail: img$R,
    icon: img$Q,
    categories: ['correlations', 'distributions'],
    description: 'It displays multiple continuous dimensions as axes, and each row in the dataset produces a line connecting its values across the axes.',
    code: 'https://observablehq.com/@d3/parallel-coordinates' // tutorial: 'https://rawgraphs.io/learning/',

  };

  const dimensions$r = [{
    id: 'dimensions',
    name: 'Dimensions',
    validTypes: ['number', 'date'],
    required: true,
    multiple: true
  }, {
    id: 'color',
    name: 'Couleur',
    validTypes: ['number', 'date', 'string'],
    required: false
  }];

  const mapData$r = {
    dimensions: 'get',
    color: 'get'
  };

  function render$r(node, data, visualOptions, mapping, originalData, styles) {
    // destructurate visual visualOptions
    const {
      // default options
      width,
      height,
      background,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      // chart
      orientation,
      strokeWidth,
      strokeOpacity,
      // color
      colorScale,
      // legend
      showLegend,
      legendWidth // add below other options defined in visualOptions.js

    } = visualOptions;
    const margin = {
      top: marginTop,
      right: marginRight,
      bottom: marginBottom,
      left: marginLeft
    };
    let chartWidth = width - margin.left - margin.right;
    let chartHeight = height - margin.top - margin.bottom; // select the SVG element

    const svg = select(node); // add background

    svg.append('rect').attr('width', showLegend ? width + legendWidth : width).attr('height', height).attr('x', 0).attr('y', 0).attr('fill', background).attr('id', 'backgorund'); //add viz group

    let viz = svg.append('g').attr('id', 'viz').attr('transform', `translate(${margin.left},${margin.top})`); // create a boolean variable for simplicity

    const horizontal = orientation == 'horizontal';
    const keys = mapping.dimensions.value;
    const axesScales = new Map(Array.from(keys, (key, i) => [key, linear$2(extent(data, d => d.dimensions[i]), [0, horizontal ? chartWidth : chartHeight])]));
    const catScales = point(keys, [0, horizontal ? chartHeight : chartWidth]);
    const line$1 = line();

    if (horizontal) {
      line$1.x((d, i) => axesScales.get(keys[i])(d)).y((d, i) => catScales(keys[i]));
    } else {
      line$1.y((d, i) => axesScales.get(keys[i])(d)).x((d, i) => catScales(keys[i]));
    } //add lines


    viz.append('g').attr('id', 'lines').attr('fill', 'none').selectAll('path').data(data).join('path').attr('d', d => line$1(d.dimensions)).attr('stroke', d => colorScale(d.color)).attr('stroke-width', strokeWidth).attr('stroke-opacity', strokeOpacity); // add axes

    viz.append('g').selectAll('g').data(keys).join('g').attr('transform', d => horizontal ? `translate(0,${catScales(d)})` : `translate(${catScales(d)},0)`).each(function (d) {
      if (horizontal) {
        select(this).call(axisBottom(axesScales.get(d)));
      } else {
        select(this).call(axisLeft(axesScales.get(d)));
      }
    }).call(g => g.append('text').attr('y', -6).attr('text-anchor', 'start').attr('fill', 'currentColor').text(d => d));

    if (showLegend) {
      // svg width is adjusted automatically because of the "container:height" annotation in legendWidth visual option
      const legendLayer = svg.append('g').attr('id', 'legend').attr('transform', `translate(${width},${marginTop})`);
      const chartLegend = legend().legendWidth(legendWidth);

      if (mapping.color.value) {
        chartLegend.addColor(mapping.color.value, colorScale);
      }

      legendLayer.call(chartLegend);
    }
  }

  const visualOptions$r = {
    marginTop: {
      type: 'number',
      label: 'Marge (haut)',
      default: 20,
      group: 'artboard'
    },
    marginRight: {
      type: 'number',
      label: 'Marge (droite)',
      default: 20,
      group: 'artboard'
    },
    marginBottom: {
      type: 'number',
      label: 'Marge (bas)',
      default: 20,
      group: 'artboard'
    },
    marginLeft: {
      type: 'number',
      label: 'Marge (gauche)',
      default: 20,
      group: 'artboard'
    },
    showLegend: {
      type: 'boolean',
      label: 'Afficher la légende',
      default: false,
      group: 'artboard'
    },
    legendWidth: {
      type: 'number',
      label: 'Largeur de la légende',
      default: 200,
      group: 'artboard',
      disabled: {
        showLegend: false
      },
      container: 'width',
      containerCondition: {
        showLegend: true
      }
    },
    orientation: {
      type: 'text',
      label: 'Orientation',
      group: 'chart',
      options: [{
        label: 'Vertical',
        value: 'vertical'
      }, {
        label: 'Horizontal',
        value: 'horizontal'
      }],
      default: 'vertical'
    },
    strokeWidth: {
      type: 'number',
      label: 'Stroke width',
      default: 1,
      group: 'chart'
    },
    strokeOpacity: {
      group: 'chart',
      type: 'number',
      label: 'Lines opacity (0-1)',
      default: 0.5,
      step: 0.1,
      min: 0,
      max: 1
    },
    colorScale: {
      type: 'colorScale',
      label: 'Echelle de couleurs',
      dimension: 'color',
      default: {
        scaleType: 'ordinal',
        interpolator: 'interpolateSpectral'
      },
      group: 'colors'
    }
  };

  var parallelcoordinates = {
    metadata: metadata$r,
    dimensions: dimensions$r,
    mapData: mapData$r,
    render: render$r,
    visualOptions: visualOptions$r,
    styles: styles$1
  };

  exports.alluvialdiagram = alluvialdiagram;
  exports.arcdiagram = arcdiagram;
  exports.barchart = barchart;
  exports.barchartmultiset = barchartmultiset;
  exports.barchartstacked = barchartstacked;
  exports.beeswarm = beeswarm;
  exports.boxplot = boxplot;
  exports.bubblechart = bubblechart;
  exports.bumpchart = bumpchart;
  exports.circlepacking = circlepacking;
  exports.circularDendrogram = circularDendrogram;
  exports.colortest = colortest;
  exports.contourPlot = contourPlot;
  exports.convexHull = convexHull;
  exports.dendrogram = dendrogram;
  exports.ganttChart = ganttChart;
  exports.hexagonalBinning = hexagonalBinning;
  exports.horizongraph = horizongraph;
  exports.linechart = linechart;
  exports.matrixplot = matrixplot;
  exports.parallelcoordinates = parallelcoordinates;
  exports.radarchart = radarchart;
  exports.sankeydiagram = sankeydiagram;
  exports.streamgraph = streamgraph;
  exports.sunburst = sunburst;
  exports.treemap = treemap$1;
  exports.violinplot = violinplot;
  exports.voronoidiagram = voronoidiagram;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
